--- START OF FILE modification_rules.txt ---
修改规则：

项目文件组成:
- gemini_chat.html (主聊天界面)
- editor.html (本编辑器界面, 一般不需你修改)
- backend.py (后端服务)
- core.js (核心逻辑与状态)
- ui_elements.js (DOM元素引用)
- ui_settings.js (设置界面逻辑)
- ui_chat.js (聊天界面逻辑)
- main.js (初始化与事件)
- auto_get_files (XX).txt (包含此规则和所有代码, 用于提供上下文)

核心要求:
1.  **完整代码输出**: 当我要求修改代码时, 你必须输出 **修改后** 的、**完整** 的脚本文件内容。如果一个文件有修改, 就输出那个文件的 **全部** 内容。**绝对禁止** 只输出修改部分或省略未修改部分。如果某个文件完全没有修改, 则 **不要** 输出该文件。
2.  **单一文件操作**: 我只会对单个文件进行整体复制粘贴替换, 无法进行局部修改。你的输出必须严格遵守第 1 条规则。
3.  **保持极简**: 这是自用工具, 追求轻量和简约。**禁止** 添加任何我未明确要求的功能、库或复杂的代码结构, 即使你认为那样更“健壮”。
4.  **移除注释**: 输出的代码中 **不得包含任何注释**。如果原始代码中有注释, 输出时必须移除。
5.  **一致性**:
    *   **UI风格**: 所有 HTML/CSS 必须保持统一的视觉风格 (暗色背景、指定颜色、紧凑布局)。
    *   **跨文件修改**: 如果修改一个功能涉及多个文件, 必须同时修改所有相关文件中的对应部分, 确保功能完整且无 BUG。修复 BUG 时也要检查并修复所有文件中类似的问题。
6.  **移动端优先**: `gemini_chat.html` 是设计在手机 Termux 环境下使用的, 布局需紧凑, 元素间不留白。`editor.html` 主要在桌面端使用, 但也要保持简洁。

请严格遵守以上规则进行代码修改。
--- END OF FILE modification_rules.txt ---

--- START OF FILE backend.py ---
```python
import base64
import io
import zipfile
from flask import Flask, request, jsonify, send_from_directory, send_file
from flask_cors import CORS
import requests
import json
import os
import logging
import uuid
import re
import math
import sys
import traceback
from datetime import datetime
import shutil

app = Flask(__name__)
CORS(app)

CONFIG_FILENAME = 'config.json'
CHATROOMS_DIR = 'chatrooms'
HISTORY_FILENAME = 'history.json'
CHATROOM_CONFIG_FILENAME = 'chatroom_config.json'
ROLES_SUBDIR = 'roles'
NOVELS_SUBDIR = 'novels'
IMAGES_DIR = 'images'
GENERATED_SUBDIR = 'generated'


MAX_ZIP_SIZE = 100 * 1024 * 1024


default_config = {
    "temperature": "1.0",
    "topP": "0.9",
    "topK": "40",
    "maxOutputTokens": "2048",
    "responseMimeType": "application/json",
    "promptPresetTurns": [],
    "model": "",
    "responseSchemaJson": "",
    "responseSchemaParserJs": "",
    "sharedDatabaseInstruction": "",
    "mainPrompt": "",
    "toolSettings": {
        "drawingMaster": { "responseSchemaJson": "", "responseSchemaParserJs": "", "toolDatabaseInstruction": "", "enabled": False, "model": "", "mainPrompt": "", "novelContent": ""},
        "gameHost": { "responseSchemaJson": "", "responseSchemaParserJs": "", "toolDatabaseInstruction": "", "enabled": False, "model": "", "mainPrompt": "" },
        "writingMaster": { "responseSchemaJson": "", "responseSchemaParserJs": "", "toolDatabaseInstruction": "", "enabled": False, "model": "", "mainPrompt": "" },
        "characterUpdateMaster": { "responseSchemaJson": "", "responseSchemaParserJs": "", "toolDatabaseInstruction": "", "enabled": False, "model": "", "mainPrompt": "" },
        "privateAssistant": { "responseSchemaJson": "", "responseSchemaParserJs": "", "toolDatabaseInstruction": "", "enabled": False, "model": "", "mainPrompt": "" },
    },
    "activeChatRoomName": None,
    "chatRoomOrder": [],
    "isRunPaused": True,
    "isRoleListVisible": False,
    "lastViewedNovelId": None,
    "originalNovelLength": 10000,
    "novelaiModel": "",
    "novelaiArtistChain": "",
    "novelaiDefaultPositivePrompt": "",
    "novelaiDefaultNegativePrompt": "",
    "novelaiWidth": 1024,
    "novelaiHeight": 1024,
    "novelaiSteps": 28,
    "novelaiScale": 5.0,
    "novelaiCfgRescale": 0.0,
    "novelaiSampler": "k_euler",
    "novelaiNoiseSchedule": "native",
    "novelaiSeed": 0,
    "systemInstruction": ""
}


default_chatroom_override_settings = {
    "general": {
        "enabled": False,
        "model": "",
        "responseSchemaJson": "",
        "responseSchemaParserJs": "",
        "sharedDatabaseInstruction": "",
        "mainPrompt": ""
    },
    "drawingMaster": {
        "enabled": False,
        "model": "",
        "responseSchemaJson": "",
        "responseSchemaParserJs": "",
        "toolDatabaseInstruction": "",
        "mainPrompt": "",
        "novelContent": ""
    },
    "gameHost": {
        "enabled": False,
        "model": "",
        "responseSchemaJson": "",
        "responseSchemaParserJs": "",
        "toolDatabaseInstruction": "",
        "mainPrompt": ""
    },
    "writingMaster": {
        "enabled": False,
        "model": "",
        "responseSchemaJson": "",
        "responseSchemaParserJs": "",
        "toolDatabaseInstruction": "",
        "mainPrompt": ""
    },
    "characterUpdateMaster": {
        "enabled": False,
        "model": "",
        "responseSchemaJson": "",
        "responseSchemaParserJs": "",
        "toolDatabaseInstruction": "",
        "mainPrompt": ""
    },
    "privateAssistant": {
        "enabled": False,
        "model": "",
        "responseSchemaJson": "",
        "responseSchemaParserJs": "",
        "toolDatabaseInstruction": "",
        "mainPrompt": ""
    }
}

default_chatroom_config = {
    "name": "",
    "roleplayRules": "",
    "publicInfo": "",
    "user": "",
    "activeNovelIds": [],
    "roleStates": {"管理员": "默"},
    "roleDetailedStates": {},
    "novelCurrentSegmentIds": {},
    "backgroundImageFilename": None,
    "overrideSettings": default_chatroom_override_settings.copy(),
    "roleVisibility": {"管理员": True}
}


log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

os.makedirs(CHATROOMS_DIR, exist_ok=True)
os.makedirs(os.path.join(IMAGES_DIR, GENERATED_SUBDIR), exist_ok=True)


@app.errorhandler(Exception)
def handle_exception(e):
    exc_type, exc_value, exc_traceback = sys.exc_info()
    print(f"Unhandled Exception: {e}", file=sys.stderr)
    traceback.print_tb(exc_traceback, limit=5, file=sys.stderr)
    response = jsonify({"error": "Internal Server Error", "details": str(e)})
    response.status_code = 500
    return response

def is_safe_path(path, base_dir=None):
    if base_dir is None:
        base_dir = os.path.abspath(os.path.dirname(__file__))
    else:
        base_dir = os.path.abspath(base_dir)

    target_path_abs = os.path.abspath(path)
    return target_path_abs.startswith(base_dir)


def load_current_config():
    config_to_return = default_config.copy()
    loaded_data = {}

    if os.path.exists(CONFIG_FILENAME):
        try:
            with open(CONFIG_FILENAME, 'r', encoding='utf-8') as f:
                 loaded_data = json.load(f)
            if not isinstance(loaded_data, dict):
                 print(f"Warning: Config file '{CONFIG_FILENAME}' is not a valid JSON object. Using defaults.", file=sys.stderr)
                 loaded_data = {}
        except Exception as e:
            print(f"Error loading config file '{CONFIG_FILENAME}': {e}. Using defaults.", file=sys.stderr)
            loaded_data = {}


    for key, default_value in default_config.items():
        if key == 'toolSettings':
            if isinstance(loaded_data.get(key), dict):
                config_to_return[key] = {}
                for tool_name, default_tool_config in default_config[key].items():
                    loaded_tool_config = loaded_data[key].get(tool_name)
                    if isinstance(loaded_tool_config, dict):
                        config_to_return[key][tool_name] = default_tool_config.copy()
                        config_to_return[key][tool_name].update({
                            k: v for k, v in loaded_tool_config.items()
                            if k in default_tool_config
                        })
                    else:
                        config_to_return[key][tool_name] = default_tool_config.copy()
            else:
                config_to_return[key] = default_config[key].copy()
        elif key == 'chatRoomOrder':
             if isinstance(loaded_data.get(key), list):
                 config_to_return[key] = [str(name) for name in loaded_data[key] if isinstance(name, str) and name.strip()]
             else:
                 config_to_return[key] = []
        elif key == 'activeChatRoomName':
             config_to_return[key] = loaded_data.get(key) if isinstance(loaded_data.get(key), str) else None
        elif key not in ['chatRooms', 'activeNovelIdsInChatroom', 'novelCurrentSegmentIds', 'errorLogs']:
            if key in loaded_data:
                config_to_return[key] = loaded_data[key]


    obsolete_keys_set = set(['chatRooms', 'activeNovelIdsInChatroom', 'novelCurrentSegmentIds', 'errorLogs', 'roleStates',
                             'apiKeys', 'currentApiKeyIndex', 'novelaiApiKey', 'chatroomHistories',
                             'user1Instruction', 'model1Instruction', 'user2Instruction',
                             'model2Instruction', 'user3Instruction', 'primaryModel', 'secondaryModel',
                             'roles', 'temporaryRoles', 'novels'])
    for key in list(config_to_return.keys()):
         if key.endswith('_setting') or key.endswith('_memory') or key.endswith('_drawingTemplate'):
             del config_to_return[key]
         elif key in obsolete_keys_set:
             pass


    chatrooms_base_path = os.path.abspath(CHATROOMS_DIR)
    found_room_names = set()
    if os.path.isdir(chatrooms_base_path):
        for item in os.listdir(chatrooms_base_path):
            item_path = os.path.join(chatrooms_base_path, item)
            chatroom_config_path = os.path.join(item_path, CHATROOM_CONFIG_FILENAME)
            if os.path.isdir(item_path) and os.path.exists(chatroom_config_path) and is_safe_path(item_path, chatrooms_base_path):
                try:
                    with open(chatroom_config_path, 'r', encoding='utf-8') as cf:
                        room_conf = json.load(cf)
                    if isinstance(room_conf, dict) and 'name' in room_conf and room_conf['name'] == item:
                        found_room_names.add(item)
                    else:
                         print(f"Warning: Chatroom directory '{item}' has invalid or mismatched config file. Skipping.", file=sys.stderr)
                except Exception as e:
                    print(f"Warning: Error reading chatroom config '{chatroom_config_path}': {e}. Skipping.", file=sys.stderr)


    current_order = config_to_return['chatRoomOrder']
    valid_ordered_rooms = [name for name in current_order if name in found_room_names]
    newly_found_rooms = list(found_room_names - set(valid_ordered_rooms))
    newly_found_rooms.sort()

    config_to_return['chatRoomOrder'] = valid_ordered_rooms + newly_found_rooms


    if config_to_return['activeChatRoomName'] not in found_room_names:
        config_to_return['activeChatRoomName'] = config_to_return['chatRoomOrder'][0] if config_to_return['chatRoomOrder'] else None

    return config_to_return

def save_current_config(config_data):
    clean_config = {}
    allowed_keys = set(default_config.keys()) - {'chatRooms', 'activeNovelIdsInChatroom', 'novelCurrentSegmentIds', 'errorLogs'}

    for key in allowed_keys:
        if key in config_data:
            clean_config[key] = config_data[key]
        elif key in default_config:
            clean_config[key] = default_config[key]

    if 'toolSettings' in clean_config:
        for tool_name, tool_config in list(clean_config['toolSettings'].items()):
            if tool_name not in default_config['toolSettings']:
                del clean_config['toolSettings'][tool_name]
            else:
                default_tool_keys = set(default_config['toolSettings'][tool_name].keys())
                for k in list(tool_config.keys()):
                    if k not in default_tool_keys:
                        del clean_config['toolSettings'][tool_name][k]


    if not isinstance(clean_config.get('chatRoomOrder'), list):
        clean_config['chatRoomOrder'] = []
    if not isinstance(clean_config.get('activeChatRoomName'), str) and clean_config.get('activeChatRoomName') is not None:
         clean_config['activeChatRoomName'] = None

    try:
        with open(CONFIG_FILENAME, 'w', encoding='utf-8') as f:
            json.dump(clean_config, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"Error saving config: {e}", file=sys.stderr)
        raise

@app.route('/autosave-config', methods=['POST'])
def autosave_config_route():
    config_data = request.json
    if not config_data:
        return jsonify({"error": "Missing config data"}), 400

    try:
        save_current_config(config_data)
        return jsonify({"message": "Config automatically saved"})
    except Exception as e:
        return jsonify({"error": f"Auto-save failed: {e}"}), 500

@app.route('/load-config', methods=['GET'])
def load_config_route():
    try:
        current_config = load_current_config()

        config_to_send = {}
        allowed_keys = set(default_config.keys()) - {'chatRooms', 'activeNovelIdsInChatroom', 'novelCurrentSegmentIds', 'errorLogs'}
        for key in allowed_keys:
            if key in current_config:
                config_to_send[key] = current_config[key]

        return jsonify(config_to_send)
    except Exception as e:
        print(f"Error in /load-config: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return jsonify({"error": "Failed to load configuration"}), 500

@app.route('/ai-proxy', methods=['POST'])
def ai_proxy():
    api_key = request.json.get('apiKey')
    model_name = request.json.get('model')
    contents = request.json.get('contents')
    system_instruction = request.json.get('systemInstruction')
    generation_config = request.json.get('generationConfig', {})
    response_mime_type = generation_config.get('responseMimeType', 'application/json')
    response_schema = generation_config.get('responseSchema')

    if not api_key or not model_name or not contents:
        return jsonify({"error": "Missing required parameters (apiKey, model, contents)"}), 400

    GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models"
    gemini_api_url = f"{GEMINI_API_BASE_URL}/{model_name}:generateContent?key={api_key}"

    gemini_payload = {
        "contents": contents,
        "generationConfig": {
            "temperature": float(generation_config.get("temperature", 1.0)),
            "topP": float(generation_config.get("topP", 0.9)),
            "topK": int(generation_config.get("topK", 40)),
            "maxOutputTokens": int(generation_config.get("maxOutputTokens", 2048)),
            "responseMimeType": response_mime_type,
        },
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "OFF"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "OFF"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "OFF"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "OFF"},
        ]
    }

    if system_instruction and isinstance(system_instruction, dict) and 'parts' in system_instruction and system_instruction['parts']:
         gemini_payload["systemInstruction"] = {"parts": [{"text": system_instruction['parts'][0].get('text', '')}]}
    elif system_instruction and isinstance(system_instruction, str) and system_instruction.strip():
         gemini_payload["systemInstruction"] = {"parts": [{"text": system_instruction}]}


    if response_schema:
        gemini_payload["generationConfig"]["responseSchema"] = response_schema


    ai_response_json = None
    try:
        print("--- Sending to Gemini ---")
        print(json.dumps(gemini_payload, indent=2, ensure_ascii=False))
        response = requests.post(gemini_api_url, headers={'Content-Type': 'application/json'}, json=gemini_payload)
        ai_response_json = response.json()
        print("--- Received from Gemini ---")
        print(json.dumps(ai_response_json, indent=2, ensure_ascii=False))
        response.raise_for_status()


        if response.status_code == 200 and ai_response_json:
            if 'candidates' not in ai_response_json and 'content' in ai_response_json:
                 ai_response_json = {"candidates": [{"content": ai_response_json['content']}]}

            if not ai_response_json.get('candidates'):
                error_message = "AI response has no candidates"
                block_reason = ai_response_json.get('promptFeedback', {}).get('blockReason')
                if block_reason:
                     error_message = f"AI request blocked: {block_reason}"
                     safety_ratings = ai_response_json.get('promptFeedback', {}).get('safetyRatings')
                     if safety_ratings:
                          error_message += f" (Details: {safety_ratings})"
                return jsonify({"error": error_message, "full_response_for_error": ai_response_json}), 500

            if not ai_response_json['candidates'][0].get('content') or not ai_response_json['candidates'][0]['content'].get('parts'):
                 finish_reason = ai_response_json['candidates'][0].get('finishReason', 'UNKNOWN')
                 safety_ratings = ai_response_json['candidates'][0].get('safetyRatings', [])
                 if finish_reason == 'SAFETY':
                     error_message = f"AI response blocked due to safety settings. Ratings: {safety_ratings}"
                 elif finish_reason == 'RECITATION':
                     error_message = f"AI response blocked due to recitation policy."
                 elif finish_reason == 'MAX_TOKENS':
                     return jsonify({"text_content": "[输出被截断]"})
                 else:
                     error_message = f"AI response missing content/parts. Finish reason: {finish_reason}"
                 return jsonify({"error": error_message, "full_response_for_error": ai_response_json}), 500


            text_content = ai_response_json['candidates'][0]['content']['parts'][0]['text']
            return jsonify({"text_content": text_content})
        else:
            error_message = ai_response_json.get("error", {}).get("message", "AI response format error or unknown error")
            return jsonify({"error": error_message, "full_response_for_error": ai_response_json}), response.status_code if response.status_code >= 400 else 500

    except requests.exceptions.RequestException as e:
        print(f"Error: {e}", file=sys.stderr)
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        exc_type, exc_value, exc_traceback_obj = sys.exc_info()
        traceback.print_tb(exc_traceback_obj, limit=2, file=sys.stderr)
        return jsonify({"error": f"Error processing AI response: {e}"}), 500

@app.route('/novelai-proxy', methods=['POST'])
def novelai_proxy():
    nai_api_key = request.json.get('nai_api_key')
    parameters = request.json.get('parameters')

    if not nai_api_key or not parameters:
        return jsonify({"error": "Missing NovelAI API Key or parameters"}), 400

    novelai_api_url = "https://image.novelai.net/ai/generate-image"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {nai_api_key}"
    }


    try:
        print("--- Sending to NovelAI ---")
        print(json.dumps(parameters, indent=2, ensure_ascii=False))
        response = requests.post(novelai_api_url, headers=headers, json=parameters)

        if not response.ok:
            error_msg = f"NovelAI API request failed with status code: {response.status_code}"
            try:
                error_detail = response.json()
                error_msg += f"\nError details: {error_detail.get('message', response.text)}"
            except json.JSONDecodeError:
                 error_msg += f"\nResponse content: {response.text}"

            if response.status_code == 401: error_msg += "\nPossible reason: Invalid or expired API Key"
            elif response.status_code == 402: error_msg += "\nPossible reason: Active subscription required"
            elif response.status_code == 400: error_msg += "\nPossible reason: Bad request parameters"
            elif response.status_code == 429: error_msg += "\nPossible reason: Rate limit exceeded"
            elif response.status_code >= 500: error_msg += "\nPossible reason: NovelAI server internal error"
            return jsonify({"error": error_msg}), response.status_code

        if response.status_code == 200:
            zip_buffer = io.BytesIO(response.content)
            try:
                with zipfile.ZipFile(zip_buffer, 'r') as zip_ref:
                    image_filename = None
                    for name in zip_ref.namelist():
                        if not zip_ref.getinfo(name).is_dir() and name.lower().endswith(('.png', '.jpg', '.jpeg', '.webp')):
                            image_filename = name
                            break

                    if not image_filename:
                        return jsonify({"error": "No image file found in the ZIP response"}), 500

                    image_bytes = zip_ref.read(image_filename)
                    base64_image = base64.b64encode(image_bytes).decode('utf-8')
                    mime_type = f"image/{os.path.splitext(image_filename)[1][1:].lower()}"
                    if mime_type == 'image/jpg': mime_type = 'image/jpeg'
                    image_data_url = f"data:{mime_type};base64,{base64_image}"
                    return jsonify({"imageDataUrl": image_data_url})
            except zipfile.BadZipFile:
                return jsonify({"error": "NovelAI returned an invalid ZIP file"}), 500
        else:
             return jsonify({"error": f"NovelAI returned unexpected status: {response.status_code}, Content-Type: {response.headers.get('Content-Type')}"}), 500
    except requests.exceptions.RequestException as e:
        return jsonify({"error": f"Connection error to NovelAI: {e}"}), 500
    except Exception as e:
         return jsonify({"error": f"Error processing NovelAI response: {e}"}), 500


GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models"

@app.route('/models', methods=['GET'])
def list_models_proxy():
    api_key = request.args.get('key')
    if not api_key:
        return jsonify({"error": "API key is missing"}), 400

    models_api_url = f"{GEMINI_API_BASE_URL}?key={api_key}"
    try:
        response = requests.get(models_api_url)
        response.raise_for_status()
        return jsonify(response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": f"Failed to request model list: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Failed to process model list response: {e}"}), 500

@app.route('/get-file-content', methods=['GET'])
def get_file_content():
    filename = request.args.get('filename')
    if not filename:
        return jsonify({"error": "Missing filename"}), 400

    root_dir = os.path.dirname(os.path.abspath(__file__))
    safe_path = os.path.abspath(os.path.join(root_dir, filename))

    if not safe_path.startswith(root_dir):
         return jsonify({"error": "Access denied outside project directory"}), 403

    if not os.path.exists(safe_path):
         return jsonify({"error": "File not found"}), 404

    try:
        with open(safe_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return jsonify({"content": content})
    except Exception as e:
        return jsonify({"error": f"Failed to read file: {e}"}), 500

@app.route('/save-file-content', methods=['POST'])
def save_file_content():
    filename = request.json.get('filename')
    content = request.json.get('content')
    if not filename or content is None:
        return jsonify({"error": "Missing filename or content"}), 400

    root_dir = os.path.dirname(os.path.abspath(__file__))

    try:
        dir_path = os.path.dirname(filename)
        if dir_path:
            full_dir_path = os.path.abspath(os.path.join(root_dir, dir_path))
            if not full_dir_path.startswith(root_dir):
                 return jsonify({"error": "Cannot create directory outside project"}), 403
            os.makedirs(full_dir_path, exist_ok=True)
    except Exception as e:
        return jsonify({"error": f"Failed to create directory: {e}"}), 500

    safe_path = os.path.abspath(os.path.join(root_dir, filename))

    if not safe_path.startswith(root_dir):
         return jsonify({"error": "Access denied outside project directory"}), 403

    try:
        with open(safe_path, 'w', encoding='utf-8') as f:
            f.write(content)
        return jsonify({"message": "File saved successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to save file: {e}"}), 500

@app.route('/process-novel-content', methods=['POST'])
def process_novel_content_route():
    content = request.json.get('content')
    if content is None:
        return jsonify({"error": "Missing novel content 'content'"}), 400

    SEGMENT_TARGET_LENGTH = 200
    AUTO_TOC_SEGMENT_THRESHOLD = 50
    CHAPTER_TITLE_MAX_LENGTH = 20

    def find_best_split_point(text, target_length, lookback=50):
        if len(text) <= target_length:
            return len(text)
        end_index = target_length
        best_split = -1
        split_chars = ['\n', '。', '！', '？', '.', '!', '?']
        search_start = max(0, end_index - lookback)
        for i in range(end_index, search_start -1, -1):
            if text[i] in split_chars:
                best_split = i + 1
                break
            if i > search_start and text[i-1:i+1] == '\n\n':
                 best_split = i
                 break
        if best_split != -1 and best_split > 0:
            return best_split
        return target_length

    try:
        normalized_content = content.replace('\r\n', '\n').replace('\r', '\n').strip()
        segments = []
        toc_entries = []
        current_pos = 0
        segment_id_counter = 0
        segments_since_last_toc = 0
        auto_chapter_counter = 0
        last_segment_id_for_toc = -1

        while current_pos < len(normalized_content):
            remaining_text = normalized_content[current_pos:]
            split_point = find_best_split_point(remaining_text, SEGMENT_TARGET_LENGTH)
            segment_content = remaining_text[:split_point].strip()

            if segment_content:
                segment_id = segment_id_counter
                segments.append({"id": segment_id, "content": segment_content})

                native_toc_found_in_segment = False
                lines = segment_content.split('\n')
                for line in lines:
                    trimmed_line = line.strip()
                    if trimmed_line.startswith('第') and len(trimmed_line) < CHAPTER_TITLE_MAX_LENGTH:
                        toc_entries.append({
                            "title": trimmed_line,
                            "segmentId": segment_id,
                            "type": "native"
                        })
                        segments_since_last_toc = 0
                        last_segment_id_for_toc = segment_id
                        native_toc_found_in_segment = True
                        break

                if not native_toc_found_in_segment:
                    segments_since_last_toc += 1
                    if segments_since_last_toc >= AUTO_TOC_SEGMENT_THRESHOLD and segment_id > last_segment_id_for_toc:
                         auto_chapter_counter += 1
                         toc_entries.append({
                             "title": f"Auto Paragraph {auto_chapter_counter}",
                             "segmentId": segment_id,
                             "type": "auto"
                         })
                         segments_since_last_toc = 0
                         last_segment_id_for_toc = segment_id

                segment_id_counter += 1

            current_pos += split_point

            while current_pos < len(normalized_content) and normalized_content[current_pos] == '\n':
                current_pos += 1

        toc_entries.sort(key=lambda x: x.get("segmentId", 0))

        return jsonify({"segments": segments, "toc": toc_entries})
    except Exception as e:
        print(f"Error processing novel content: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return jsonify({"error": f"Failed to process novel content: {e}"}), 500


@app.route('/history/<chatroom_name>', methods=['GET'])
def get_history(chatroom_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    filepath = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, HISTORY_FILENAME))

    if not is_safe_path(filepath, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid chatroom name or path"}), 400

    if not os.path.exists(filepath):
        return jsonify([])

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            history_data = json.load(f)
        return jsonify(history_data)
    except Exception as e:
        return jsonify({"error": f"Failed to read history: {e}"}), 500

@app.route('/history/<chatroom_name>', methods=['POST'])
def save_history(chatroom_name):
    history_data = request.json
    if history_data is None or not isinstance(history_data, list):
        return jsonify({"error": "Invalid history data format"}), 400

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    filepath = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, HISTORY_FILENAME))

    if not is_safe_path(filepath, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid chatroom name or path"}), 400

    try:
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(history_data, f, ensure_ascii=False)
        return jsonify({"message": "History saved successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to save history: {e}"}), 500

@app.route('/history/<chatroom_name>', methods=['DELETE'])
def delete_history(chatroom_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    filepath = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, HISTORY_FILENAME))

    if not is_safe_path(filepath, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid chatroom name or path"}), 400

    try:
        if os.path.exists(filepath):
            os.remove(filepath)
        return jsonify({"message": "History file deleted (if existed)"})
    except Exception as e:
        return jsonify({"error": f"Failed to delete history file: {e}"}), 500

def _update_chatroom_config(chatroom_name, updates):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    config_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, CHATROOM_CONFIG_FILENAME))

    if not is_safe_path(config_path, base_dir=chatrooms_dir):
        raise ValueError("Invalid chatroom name or path")

    if not os.path.exists(config_path):
        raise FileNotFoundError("Chatroom config file not found")

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
        if not isinstance(config_data, dict):
             config_data = {}
    except Exception as e:
        raise IOError(f"Failed to read chatroom config: {e}")

    for key, value in updates.items():
        if key in default_chatroom_config:
            config_data[key] = value

    if "roleStates" not in config_data:
        config_data["roleStates"] = {}
    if "roleDetailedStates" not in config_data:
        config_data["roleDetailedStates"] = {}
    if "overrideSettings" not in config_data:
        config_data["overrideSettings"] = default_chatroom_override_settings.copy()
    if "roleVisibility" not in config_data:
         config_data["roleVisibility"] = {}
    if "user" not in config_data:
         config_data["user"] = default_chatroom_config["user"]

    try:
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        raise IOError(f"Failed to write chatroom config: {e}")

@app.route('/background/<chatroom_name>', methods=['POST'])
def set_background_image(chatroom_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    chatroom_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name))

    if not is_safe_path(chatroom_path, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid chatroom name or path"}), 400
    if not os.path.isdir(chatroom_path):
        return jsonify({"error": "Chatroom directory not found"}), 404

    image_data_url = None
    file = None
    if 'image' in request.files:
        file = request.files['image']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
        allowed_extensions = {'png', 'jpg', 'jpeg', 'webp', 'gif'}
        file_ext = os.path.splitext(file.filename)[1].lower()[1:]
        if not file_ext or file_ext not in allowed_extensions:
            return jsonify({"error": f"Unsupported file type: {file_ext}"}), 400
    elif request.json and 'imageDataUrl' in request.json:
        image_data_url = request.json['imageDataUrl']
        try:
            header, encoded = image_data_url.split(',', 1)
            mime_match = re.match(r'data:image/(\w+);base64', header)
            if not mime_match:
                return jsonify({"error": "Invalid image Data URL format"}), 400
            img_format = mime_match.group(1).lower()
            if img_format == 'jpeg': img_format = 'jpg'
            allowed_extensions = {'png', 'jpg', 'jpeg', 'webp', 'gif'}
            if img_format not in allowed_extensions:
                 return jsonify({"error": f"Unsupported image format: {img_format}"}), 400
            img_data = base64.b64decode(encoded)
            file_ext = img_format
        except Exception as e:
             return jsonify({"error": f"Failed to process image Data URL: {e}"}), 500
    else:
        return jsonify({"error": "Missing image file or image data"}), 400

    new_filename = f"background.{file_ext}"
    filepath = os.path.join(chatroom_path, new_filename)

    for ext in allowed_extensions:
         old_bg_path = os.path.join(chatroom_path, f"background.{ext}")
         if os.path.exists(old_bg_path) and old_bg_path != filepath:
             try:
                 os.remove(old_bg_path)
             except Exception as e:
                 print(f"Warning: Failed to remove old background {old_bg_path}: {e}", file=sys.stderr)

    try:
        if file:
            file.save(filepath)
        else:
            with open(filepath, 'wb') as f:
                f.write(img_data)

        _update_chatroom_config(chatroom_name, {"backgroundImageFilename": new_filename})
        relative_path = os.path.join(CHATROOMS_DIR, chatroom_name, new_filename).replace('\\', '/')
        return jsonify({"message": "Background image set successfully", "path": relative_path})
    except Exception as e:
        return jsonify({"error": f"Failed to save background image or update config: {e}"}), 500


@app.route('/background/<chatroom_name>', methods=['DELETE'])
def delete_background_image(chatroom_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    chatroom_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name))

    if not is_safe_path(chatroom_path, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid chatroom name or path"}), 400
    if not os.path.isdir(chatroom_path):
        return jsonify({"message": "Chatroom directory not found, nothing to delete"}), 200

    deleted = False
    last_error = None
    possible_extensions = ['png', 'jpg', 'jpeg', 'webp', 'gif']
    filename_to_remove = None

    try:
         with open(os.path.join(chatroom_path, CHATROOM_CONFIG_FILENAME), 'r', encoding='utf-8') as f:
             config_data = json.load(f)
         current_bg_filename = config_data.get("backgroundImageFilename")
         if current_bg_filename:
             filepath_to_remove = os.path.join(chatroom_path, current_bg_filename)
             if is_safe_path(filepath_to_remove, base_dir=chatroom_path) and os.path.exists(filepath_to_remove):
                  try:
                      os.remove(filepath_to_remove)
                      deleted = True
                  except Exception as e:
                      last_error = str(e)
             else:
                 print(f"Warning: Background filename '{current_bg_filename}' in config but file not found or unsafe.", file=sys.stderr)
         else:

             for ext in possible_extensions:
                 filepath = os.path.join(chatroom_path, f"background.{ext}")
                 if os.path.exists(filepath) and is_safe_path(filepath, base_dir=chatroom_path):
                     try:
                         os.remove(filepath)
                         deleted = True
                     except Exception as e:
                         last_error = str(e)

         if deleted or current_bg_filename:
            _update_chatroom_config(chatroom_name, {"backgroundImageFilename": None})

         if deleted:
             return jsonify({"message": "Background image deleted"})
         elif last_error:
              return jsonify({"error": f"Error deleting background image: {last_error}"}), 500
         else:
              return jsonify({"message": "No background image found to delete"})

    except Exception as e:
        return jsonify({"error": f"Error processing background deletion: {e}"}), 500

@app.route('/export-chatroom-zip/<chatroom_name>', methods=['GET'])
def export_chatroom_zip(chatroom_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    chatroom_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name))

    if not is_safe_path(chatroom_path, base_dir=chatrooms_dir) or not os.path.isdir(chatroom_path):
        return jsonify({"error": "Chatroom not found or invalid path"}), 404

    memory_file = io.BytesIO()
    try:
        with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zf:
            for root, _, files in os.walk(chatroom_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, chatroom_path)
                    zf.write(file_path, arcname)

        memory_file.seek(0)
        download_name = f'chatroom_{chatroom_name}_{datetime.now().strftime("%Y%m%d%H%M")}.zip'
        return send_file(memory_file, mimetype='application/zip', as_attachment=True, download_name=download_name)

    except Exception as e:
        print(f"Error exporting chatroom {chatroom_name}: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return jsonify({"error": f"Error exporting chatroom: {e}"}), 500

@app.route('/import-chatroom-zip', methods=['POST'])
def import_chatroom_zip():
    if 'chatroom_zip' not in request.files:
        return jsonify({"error": "No uploaded file found ('chatroom_zip')"}), 400

    file = request.files['chatroom_zip']
    if file.filename == '' or not file.filename.lower().endswith('.zip'):
        return jsonify({"error": "No file selected or invalid file type (must be .zip)"}), 400

    if file.content_length > MAX_ZIP_SIZE:
         return jsonify({"error": f"File too large (max {MAX_ZIP_SIZE // 1024 // 1024}MB)"}), 413

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    temp_extract_dir = os.path.join(chatrooms_dir, f"__import_temp_{uuid.uuid4()}__")
    imported_room_name = None
    final_room_name = None

    try:
        os.makedirs(temp_extract_dir, exist_ok=True)

        file_content = file.read()
        zip_buffer = io.BytesIO(file_content)

        with zipfile.ZipFile(zip_buffer, 'r') as zf:
            if CHATROOM_CONFIG_FILENAME not in [os.path.basename(f) for f in zf.namelist() if not f.endswith('/')]:
                 raise ValueError(f"ZIP file is missing '{CHATROOM_CONFIG_FILENAME}' at the root level")

            zf.extractall(temp_extract_dir)


            config_path = os.path.join(temp_extract_dir, CHATROOM_CONFIG_FILENAME)
            if not os.path.exists(config_path):
                 raise ValueError(f"Extracted files missing '{CHATROOM_CONFIG_FILENAME}'")

            with open(config_path, 'r', encoding='utf-8') as f:
                room_config = json.load(f)
            if not isinstance(room_config, dict) or 'name' not in room_config:
                 raise ValueError(f"'{CHATROOM_CONFIG_FILENAME}' is invalid or missing 'name'")

            imported_room_name = room_config['name']
            if not imported_room_name or not isinstance(imported_room_name, str):
                 raise ValueError("Room name in config is invalid")

            if "overrideSettings" not in room_config:
                 room_config["overrideSettings"] = default_chatroom_override_settings.copy()
            else:
                current_override_settings = room_config["overrideSettings"]
                default_override_copy = default_chatroom_override_settings.copy()
                for section, default_section_config in default_override_copy.items():
                    if section not in current_override_settings:
                        current_override_settings[section] = default_section_config
                    else:
                        for key, default_value in default_section_config.items():
                            if key not in current_override_settings[section]:
                                current_override_settings[section][key] = default_value
            if "roleVisibility" not in room_config:
                 room_config["roleVisibility"] = {}
            if "user" not in room_config:
                room_config["user"] = default_chatroom_config["user"]


            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(room_config, f, indent=2, ensure_ascii=False)


        config = load_current_config()
        current_room_names = set(config['chatRoomOrder'])
        final_room_name = imported_room_name
        name_counter = 1
        while final_room_name in current_room_names:
            final_room_name = f"{imported_room_name}_imported_{name_counter}"
            name_counter += 1


        target_room_path = os.path.join(chatrooms_dir, final_room_name)
        shutil.move(temp_extract_dir, target_room_path)


        if final_room_name != imported_room_name:
            final_config_path = os.path.join(target_room_path, CHATROOM_CONFIG_FILENAME)
            try:
                with open(final_config_path, 'r', encoding='utf-8') as f:
                    final_room_config = json.load(f)
                final_room_config['name'] = final_room_name
                with open(final_config_path, 'w', encoding='utf-8') as f:
                    json.dump(final_room_config, f, indent=2, ensure_ascii=False)
            except Exception as e:
                 print(f"Warning: Failed to update room name in imported config '{final_config_path}': {e}", file=sys.stderr)


        config['chatRoomOrder'].append(final_room_name)
        save_current_config(config)

        return jsonify({"message": f"Chatroom '{imported_room_name}' successfully imported as '{final_room_name}'"})

    except (zipfile.BadZipFile, ValueError, FileNotFoundError) as e:
         if os.path.exists(temp_extract_dir):
             shutil.rmtree(temp_extract_dir, ignore_errors=True)
         return jsonify({"error": f"Import failed: {e}"}), 400
    except Exception as e:
        if os.path.exists(temp_extract_dir):
            shutil.rmtree(temp_extract_dir, ignore_errors=True)
        print(f"Error importing chatroom: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return jsonify({"error": f"An unexpected error occurred during import: {e}"}), 500

@app.route('/export-full-config-zip', methods=['GET'])
def export_full_config_zip():
    memory_file = io.BytesIO()
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    try:
        with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zf:

            if os.path.exists(CONFIG_FILENAME):
                zf.write(CONFIG_FILENAME, CONFIG_FILENAME)


            if os.path.isdir(chatrooms_dir):
                for item in os.listdir(chatrooms_dir):
                    item_path = os.path.join(chatrooms_dir, item)
                    if os.path.isdir(item_path):
                         arc_dir = os.path.join(CHATROOMS_DIR, item)
                         for root, _, files in os.walk(item_path):
                            for file in files:
                                file_path = os.path.join(root, file)
                                arcname = os.path.join(arc_dir, os.path.relpath(file_path, item_path))
                                zf.write(file_path, arcname)

        memory_file.seek(0)
        download_name = f'full_config_{datetime.now().strftime("%Y%m%d%H%M")}.zip'
        return send_file(memory_file, mimetype='application/zip', as_attachment=True, download_name=download_name)

    except Exception as e:
        print(f"Error exporting full config: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return jsonify({"error": f"Error exporting full configuration: {e}"}), 500

@app.route('/import-full-config-zip', methods=['POST'])
def import_full_config_zip():
    if 'config_zip' not in request.files:
        return jsonify({"error": "No uploaded file found ('config_zip')"}), 400

    file = request.files['config_zip']
    if file.filename == '' or not file.filename.lower().endswith('.zip'):
        return jsonify({"error": "No file selected or invalid file type (must be .zip)"}), 400
    if file.content_length > MAX_ZIP_SIZE:
         return jsonify({"error": f"File too large (max {MAX_ZIP_SIZE // 1024 // 1024}MB)"}), 413

    project_root_abs = os.path.abspath(os.path.dirname(__file__))
    chatrooms_dir_abs = os.path.abspath(CHATROOMS_DIR)

    try:

        if os.path.exists(CONFIG_FILENAME):
            os.remove(CONFIG_FILENAME)
        if os.path.isdir(chatrooms_dir_abs):
            shutil.rmtree(chatrooms_dir_abs, ignore_errors=True)
        os.makedirs(chatrooms_dir_abs, exist_ok=True)

        with zipfile.ZipFile(file.stream, 'r') as zf:
            extract_list = zf.namelist()
            if CONFIG_FILENAME not in extract_list:
                raise ValueError("ZIP file is missing config.json")

            for member_info in zf.infolist():
                target_path_part = member_info.filename.replace('\\', '/')
                if '..' in target_path_part or target_path_part.startswith('/'):
                     print(f"Skipping potentially unsafe path in ZIP: {member_info.filename}", file=sys.stderr)
                     continue

                target_filepath_abs = None
                if target_path_part == CONFIG_FILENAME:
                     target_filepath_abs = os.path.join(project_root_abs, CONFIG_FILENAME)
                elif target_path_part.startswith(CHATROOMS_DIR + '/'):
                     target_filepath_abs = os.path.join(project_root_abs, target_path_part)
                     if not is_safe_path(target_filepath_abs, base_dir=chatrooms_dir_abs):
                         print(f"Skipping unsafe extracted chatroom path: {target_filepath_abs}", file=sys.stderr)
                         continue
                else:
                     print(f"Skipping unexpected file/folder in ZIP root: {member_info.filename}", file=sys.stderr)
                     continue

                if target_filepath_abs:
                    if member_info.is_dir():
                        os.makedirs(target_filepath_abs, exist_ok=True)
                    else:
                        os.makedirs(os.path.dirname(target_filepath_abs), exist_ok=True)
                        with zf.open(member_info) as source, open(target_filepath_abs, "wb") as target:
                            target.write(source.read())
                        if target_filepath_abs.endswith(CHATROOM_CONFIG_FILENAME):
                             try:
                                 with open(target_filepath_abs, 'r+', encoding='utf-8') as f:
                                     room_config = json.load(f)
                                     if "overrideSettings" not in room_config:
                                         room_config["overrideSettings"] = default_chatroom_override_settings.copy()
                                     else:
                                         current_override_settings = room_config["overrideSettings"]
                                         default_override_copy = default_chatroom_override_settings.copy()
                                         for section, default_section_config in default_override_copy.items():
                                             if section not in current_override_settings:
                                                 current_override_settings[section] = default_section_config
                                             else:
                                                 for key, default_value in default_section_config.items():
                                                     if key not in current_override_settings[section]:
                                                         current_override_settings[section][key] = default_value
                                     if "roleVisibility" not in room_config:
                                          room_config["roleVisibility"] = {}
                                     if "user" not in room_config:
                                         room_config["user"] = default_chatroom_config["user"]
                                     f.seek(0)
                                     json.dump(room_config, f, indent=2, ensure_ascii=False)
                                     f.truncate()
                             except Exception as e:
                                  print(f"Warning: Failed to check/update settings in imported {target_filepath_abs}: {e}", file=sys.stderr)


        load_current_config()

        return jsonify({"message": "Full configuration imported successfully!"})

    except (zipfile.BadZipFile, ValueError) as e:
        return jsonify({"error": f"Import failed: {e}"}), 400
    except Exception as e:
        print(f"Error importing full config: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return jsonify({"error": f"An unexpected error occurred during import: {e}"}), 500

@app.route('/clear-all-config', methods=['POST'])
def clear_all_config_route():
    if request.method != 'POST':
        return jsonify({"error": "Only POST requests allowed"}), 405

    errors = []
    project_root_abs = os.path.abspath(os.path.dirname(__file__))
    chatrooms_dir_abs = os.path.abspath(CHATROOMS_DIR)
    images_generated_dir = os.path.abspath(os.path.join(IMAGES_DIR, GENERATED_SUBDIR))


    def safe_remove(path_to_remove):
        path_abs = os.path.abspath(path_to_remove)
        is_safe = path_abs.startswith(project_root_abs)

        if not is_safe and path_abs != chatrooms_dir_abs and not path_abs.startswith(images_generated_dir):
             errors.append(f"Skipping unsafe path: {path_to_remove}")
             return

        try:
            if os.path.isfile(path_abs):
                os.remove(path_abs)
            elif os.path.isdir(path_abs):
                if path_abs == chatrooms_dir_abs or path_abs == images_generated_dir:
                    shutil.rmtree(path_abs, ignore_errors=True)
                    os.makedirs(path_abs, exist_ok=True)
                else:
                    errors.append(f"Skipping directory removal for non-standard path: {path_to_remove}")
        except Exception as e:
            errors.append(f"Failed to remove {path_to_remove}: {e}")

    try:
        safe_remove(CONFIG_FILENAME)
        safe_remove(chatrooms_dir_abs)
        safe_remove(images_generated_dir)

        if not errors:
            return jsonify({"message": "All configuration and data successfully cleared!"})
        else:
            return jsonify({"error": "Errors occurred during cleanup.", "details": errors}), 500

    except Exception as e:
        print(f"Error during clear all config: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        errors.append(f"An unexpected error occurred during cleanup: {e}")
        return jsonify({"error": "A critical error occurred while clearing configuration.", "details": errors}), 500


@app.route('/images/<subdir>/<path:filename>')
def serve_subdir_image(subdir, filename):
    if subdir != GENERATED_SUBDIR:
        return jsonify({"error": "Invalid image subdirectory"}), 404

    images_dir_abs = os.path.abspath(IMAGES_DIR)
    target_dir_abs = os.path.abspath(os.path.join(images_dir_abs, subdir))
    safe_path = os.path.abspath(os.path.join(target_dir_abs, filename))

    if not is_safe_path(safe_path, base_dir=images_dir_abs):
         return jsonify({"error": "Access denied outside allowed image directories"}), 403

    if not os.path.exists(safe_path) or os.path.isdir(safe_path):
         return jsonify({"error": "Image file not found"}), 404

    return send_from_directory(target_dir_abs, filename)

@app.route(f'/{CHATROOMS_DIR}/<chatroom_name>/<filename>')
def serve_chatroom_file(chatroom_name, filename):
    chatrooms_dir_abs = os.path.abspath(CHATROOMS_DIR)
    chatroom_path_abs = os.path.abspath(os.path.join(chatrooms_dir_abs, chatroom_name))
    safe_path = os.path.abspath(os.path.join(chatroom_path_abs, filename))

    if not is_safe_path(safe_path, base_dir=chatrooms_dir_abs):
        return jsonify({"error": "Access denied outside chatrooms directory"}), 403
    if '..' in filename or filename.startswith('/'):
         return jsonify({"error": "Invalid filename path components"}), 403


    allowed_subdirs = ['', ROLES_SUBDIR, NOVELS_SUBDIR]
    file_subdir = os.path.dirname(filename)
    base_filename = os.path.basename(filename)

    if file_subdir not in allowed_subdirs:
         if not filename.startswith('background.'):
             return jsonify({"error": f"Access denied to this file type/location: {filename}"}), 403


    if not os.path.exists(safe_path) or os.path.isdir(safe_path):
         return jsonify({"error": "File not found"}), 404

    return send_from_directory(chatroom_path_abs, filename)

@app.route('/<path:filename>')
def serve_static(filename):
    if '..' in filename or filename.startswith('/') or filename.startswith(CHATROOMS_DIR):
         return jsonify({"error": "Access denied to this path"}), 403

    root_dir = os.path.dirname(os.path.abspath(__file__))
    safe_path = os.path.abspath(os.path.join(root_dir, filename))

    if not safe_path.startswith(root_dir):
         return jsonify({"error": "Access denied outside project directory"}), 403

    if not os.path.exists(safe_path) or os.path.isdir(safe_path):
         return jsonify({"error": "File not found"}), 404

    return send_from_directory(root_dir, filename)

@app.route('/')
def serve_frontend():
    root_dir = os.path.dirname(os.path.abspath(__file__))
    return send_from_directory(root_dir, 'gemini_chat.html')

@app.route('/editor')
def serve_editor():
    root_dir = os.path.dirname(os.path.abspath(__file__))
    return send_from_directory(root_dir, 'editor.html')

@app.route('/chatroom-details/<chatroom_name>', methods=['GET'])
def get_chatroom_details(chatroom_name):

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    chatroom_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name))
    if not is_safe_path(chatroom_path, base_dir=chatrooms_dir) or not os.path.isdir(chatroom_path):
        return jsonify({"error": "Chatroom not found"}), 404

    details = {"config": None, "roles": [], "novels": []}
    permanent_role_names = set()


    try:
        roles_path = os.path.join(chatroom_path, ROLES_SUBDIR)
        if os.path.isdir(roles_path):
            for filename in os.listdir(roles_path):
                if filename.endswith('.json'):
                    role_file_path = os.path.join(roles_path, filename)
                    if is_safe_path(role_file_path, base_dir=roles_path):
                        try:
                            with open(role_file_path, 'r', encoding='utf-8') as rf:
                                role_data = json.load(rf)
                                if 'name' in role_data:
                                    permanent_role_names.add(role_data['name'])
                                    role_data['isTemporary'] = False
                                    details["roles"].append(role_data)
                        except Exception as e:
                            print(f"Warning: Failed to load role file {filename}: {e}", file=sys.stderr)
    except Exception as e:
        print(f"Warning: Error reading roles directory for {chatroom_name}: {e}", file=sys.stderr)


    try:
        config_path = os.path.join(chatroom_path, CHATROOM_CONFIG_FILENAME)
        config_needs_update = False
        with open(config_path, 'r+', encoding='utf-8') as f:
            details["config"] = json.load(f)
            if "roleDetailedStates" not in details["config"]:
                details["config"]["roleDetailedStates"] = {}
                config_needs_update = True
            if "overrideSettings" not in details["config"]:
                details["config"]["overrideSettings"] = default_chatroom_override_settings.copy()
                config_needs_update = True
            else:
                loaded_overrides = details["config"]["overrideSettings"]
                default_overrides_copy = default_chatroom_override_settings.copy()
                for section_key, default_section in default_overrides_copy.items():
                     if section_key not in loaded_overrides:
                         loaded_overrides[section_key] = default_section
                         config_needs_update = True
                     else:
                          loaded_section = loaded_overrides[section_key]
                          for key, default_value in default_section.items():
                              if key not in loaded_section:
                                  loaded_section[key] = default_value
                                  config_needs_update = True

            if "roleVisibility" not in details["config"] or not isinstance(details["config"]["roleVisibility"], dict):
                 details["config"]["roleVisibility"] = {}
                 config_needs_update = True

            if "user" not in details["config"]:
                details["config"]["user"] = default_chatroom_config["user"]
                config_needs_update = True

            current_visibility = details["config"]["roleVisibility"]
            for role_name in permanent_role_names:
                if role_name not in current_visibility:
                    current_visibility[role_name] = True
                    config_needs_update = True
                elif not isinstance(current_visibility[role_name], bool):
                     current_visibility[role_name] = True
                     config_needs_update = True

            for role_name in list(current_visibility.keys()):
                 if role_name != "管理员" and role_name not in permanent_role_names:
                      del current_visibility[role_name]
                      config_needs_update = True

            if config_needs_update:
                 f.seek(0)
                 json.dump(details["config"], f, indent=2, ensure_ascii=False)
                 f.truncate()

    except Exception as e:
        print(f"Error loading/processing chatroom config '{config_path}': {e}", file=sys.stderr)
        return jsonify({"error": f"Failed to load chatroom config: {e}"}), 500


    try:
        novels_path = os.path.join(chatroom_path, NOVELS_SUBDIR)
        if os.path.isdir(novels_path):
             for filename in os.listdir(novels_path):
                 if filename.endswith('.json'):
                    novel_file_path = os.path.join(novels_path, filename)
                    if is_safe_path(novel_file_path, base_dir=novels_path):
                         try:
                             with open(novel_file_path, 'r', encoding='utf-8') as nf:
                                 details["novels"].append(json.load(nf))
                         except Exception as e:
                             print(f"Warning: Failed to load novel file {filename}: {e}", file=sys.stderr)
    except Exception as e:
        print(f"Warning: Error reading novels directory for {chatroom_name}: {e}", file=sys.stderr)

    return jsonify(details)


@app.route('/update-chatroom-config/<chatroom_name>', methods=['POST'])
def update_chatroom_config_route(chatroom_name):
    updates = request.json
    if not updates or not isinstance(updates, dict):
        return jsonify({"error": "Invalid update data"}), 400
    try:
        _update_chatroom_config(chatroom_name, updates)
        return jsonify({"message": "Chatroom config updated successfully"})
    except (FileNotFoundError, ValueError, IOError) as e:
        return jsonify({"error": str(e)}), 404 if isinstance(e, FileNotFoundError) else 500
    except Exception as e:
        return jsonify({"error": f"An unexpected error occurred: {e}"}), 500


@app.route('/create-chatroom', methods=['POST'])
def create_chatroom_route():
    data = request.json
    new_name = data.get('chatroom_name')
    if not new_name or not isinstance(new_name, str) or '..' in new_name or '/' in new_name or '\\' in new_name:
        return jsonify({"error": "Invalid chatroom name"}), 400

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    new_room_path = os.path.abspath(os.path.join(chatrooms_dir, new_name))

    if not is_safe_path(new_room_path, base_dir=chatrooms_dir):
         return jsonify({"error": "Invalid chatroom path generated"}), 400
    if os.path.exists(new_room_path):
        return jsonify({"error": "Chatroom name already exists"}), 409

    try:
        os.makedirs(os.path.join(new_room_path, ROLES_SUBDIR), exist_ok=True)
        os.makedirs(os.path.join(new_room_path, NOVELS_SUBDIR), exist_ok=True)

        initial_config = default_chatroom_config.copy()
        initial_config["name"] = new_name

        with open(os.path.join(new_room_path, CHATROOM_CONFIG_FILENAME), 'w', encoding='utf-8') as f:
            json.dump(initial_config, f, indent=2, ensure_ascii=False)

        with open(os.path.join(new_room_path, HISTORY_FILENAME), 'w', encoding='utf-8') as f:
            json.dump([], f)

        config = load_current_config()
        if new_name not in config['chatRoomOrder']:
             config['chatRoomOrder'].append(new_name)
             save_current_config(config)

        return jsonify({"message": f"Chatroom '{new_name}' created successfully"}), 201

    except Exception as e:
        if os.path.exists(new_room_path):
             shutil.rmtree(new_room_path, ignore_errors=True)
        return jsonify({"error": f"Failed to create chatroom: {e}"}), 500

@app.route('/delete-chatroom/<chatroom_name>', methods=['DELETE'])
def delete_chatroom_route(chatroom_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    room_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name))

    if not is_safe_path(room_path, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid chatroom path"}), 400
    if not os.path.isdir(room_path):
        return jsonify({"error": "Chatroom not found"}), 404

    try:
        shutil.rmtree(room_path)
        config = load_current_config()
        if chatroom_name in config['chatRoomOrder']:
            config['chatRoomOrder'].remove(chatroom_name)
        if config['activeChatRoomName'] == chatroom_name:
            config['activeChatRoomName'] = config['chatRoomOrder'][0] if config['chatRoomOrder'] else None
        save_current_config(config)
        return jsonify({"message": f"Chatroom '{chatroom_name}' deleted successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to delete chatroom: {e}"}), 500


@app.route('/rename-chatroom/<old_name>', methods=['PUT'])
def rename_chatroom_route(old_name):
    data = request.json
    new_name = data.get('new_name')

    if not new_name or not isinstance(new_name, str) or '..' in new_name or '/' in new_name or '\\' in new_name:
        return jsonify({"error": "Invalid new chatroom name"}), 400
    if not old_name or not isinstance(old_name, str):
         return jsonify({"error": "Invalid old chatroom name"}), 400

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    old_path = os.path.abspath(os.path.join(chatrooms_dir, old_name))
    new_path = os.path.abspath(os.path.join(chatrooms_dir, new_name))

    if not is_safe_path(old_path, base_dir=chatrooms_dir):
        return jsonify({"error": "Invalid old chatroom path"}), 400
    if not os.path.isdir(old_path):
        return jsonify({"error": "Old chatroom not found"}), 404
    if not is_safe_path(new_path, base_dir=chatrooms_dir):
         return jsonify({"error": "Invalid new chatroom path"}), 400
    if os.path.exists(new_path):
        return jsonify({"error": "New chatroom name already exists"}), 409

    try:

        os.rename(old_path, new_path)


        config_file = os.path.join(new_path, CHATROOM_CONFIG_FILENAME)
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                room_config = json.load(f)
            room_config['name'] = new_name
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(room_config, f, indent=2, ensure_ascii=False)
        except Exception as e:
             print(f"Warning: Failed to update name in chatroom config during rename: {e}", file=sys.stderr)


        config = load_current_config()
        try:
            index = config['chatRoomOrder'].index(old_name)
            config['chatRoomOrder'][index] = new_name
        except ValueError:
             if new_name not in config['chatRoomOrder']:
                 config['chatRoomOrder'].append(new_name)

        if config['activeChatRoomName'] == old_name:
            config['activeChatRoomName'] = new_name
        save_current_config(config)

        return jsonify({"message": f"Chatroom renamed from '{old_name}' to '{new_name}'"})
    except Exception as e:

        if not os.path.exists(old_path) and os.path.exists(new_path):
             try: os.rename(new_path, old_path)
             except: pass
        return jsonify({"error": f"Failed to rename chatroom: {e}"}), 500


@app.route('/roles/<chatroom_name>', methods=['POST'])
def create_role_route(chatroom_name):
     role_data = request.json
     role_name = role_data.get('name') if isinstance(role_data, dict) else None
     if not role_name or not isinstance(role_name, str) or '..' in role_name or '/' in role_name or '\\' in role_name:
         return jsonify({"error": "Invalid role name"}), 400

     chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
     roles_dir = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, ROLES_SUBDIR))
     role_file_path = os.path.abspath(os.path.join(roles_dir, f"{role_name}.json"))
     config_path = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, CHATROOM_CONFIG_FILENAME))

     if not is_safe_path(roles_dir, base_dir=chatrooms_dir) or not is_safe_path(role_file_path, base_dir=roles_dir):
         return jsonify({"error": "Invalid role path"}), 400
     if not os.path.isdir(roles_dir):
         os.makedirs(roles_dir, exist_ok=True)
     if os.path.exists(role_file_path):
         return jsonify({"error": "Role already exists"}), 409

     role_definition = {
         "name": role_name,
         "setting": role_data.get("setting", ""),
         "memory": role_data.get("memory", ""),
         "drawingTemplate": role_data.get("drawingTemplate", "")
     }

     try:
         with open(role_file_path, 'w', encoding='utf-8') as f:
             json.dump(role_definition, f, indent=2, ensure_ascii=False)

         try:
             if not os.path.exists(config_path):
                  raise FileNotFoundError("Chatroom config file not found.")

             with open(config_path, 'r+', encoding='utf-8') as f:
                 room_config = json.load(f)
                 if not isinstance(room_config, dict):
                     room_config = {}

                 if 'roleStates' not in room_config or not isinstance(room_config['roleStates'], dict):
                     room_config['roleStates'] = {}
                 room_config['roleStates'][role_name] = "默"

                 if 'roleDetailedStates' not in room_config or not isinstance(room_config['roleDetailedStates'], dict):
                     room_config['roleDetailedStates'] = {}
                 room_config['roleDetailedStates'][role_name] = ""

                 if 'roleVisibility' not in room_config or not isinstance(room_config['roleVisibility'], dict):
                     room_config['roleVisibility'] = {}
                 room_config['roleVisibility'][role_name] = True

                 f.seek(0)
                 json.dump(room_config, f, indent=2, ensure_ascii=False)
                 f.truncate()

         except Exception as update_e:
              print(f"Warning: Role file created, but failed to update chatroom config states: {update_e}", file=sys.stderr)
              if os.path.exists(role_file_path):
                   try: os.remove(role_file_path)
                   except Exception as rem_e: print(f"Also failed to remove role file after config update failure: {rem_e}", file=sys.stderr)
              return jsonify({"error": f"Failed to update chatroom config: {update_e}"}), 500

         return jsonify({"message": f"Role '{role_name}' created successfully"}), 201
     except Exception as e:
         if os.path.exists(role_file_path):
            try: os.remove(role_file_path)
            except: pass
         return jsonify({"error": f"Failed to create role file or update config: {e}"}), 500


@app.route('/roles/<chatroom_name>/<role_name>', methods=['PUT'])
def update_role_route(chatroom_name, role_name):
    role_data = request.json
    new_name = role_data.get('name') if isinstance(role_data, dict) else None
    if not new_name or not isinstance(new_name, str) or '..' in new_name or '/' in new_name or '\\' in new_name:
        return jsonify({"error": "Invalid role name in update data"}), 400

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    roles_dir = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, ROLES_SUBDIR))
    old_file_path = os.path.abspath(os.path.join(roles_dir, f"{role_name}.json"))
    new_file_path = os.path.abspath(os.path.join(roles_dir, f"{new_name}.json"))

    if not is_safe_path(roles_dir, base_dir=chatrooms_dir) or \
       not is_safe_path(old_file_path, base_dir=roles_dir) or \
       not is_safe_path(new_file_path, base_dir=roles_dir):
        return jsonify({"error": "Invalid role path"}), 400
    if not os.path.exists(old_file_path):
        return jsonify({"error": "Role not found"}), 404
    if role_name != new_name and os.path.exists(new_file_path):
        return jsonify({"error": "New role name already exists"}), 409

    role_definition = {
        "name": new_name,
        "setting": role_data.get("setting", ""),
        "memory": role_data.get("memory", ""),
        "drawingTemplate": role_data.get("drawingTemplate", "")
    }

    try:
        with open(old_file_path if role_name == new_name else new_file_path, 'w', encoding='utf-8') as f:
             json.dump(role_definition, f, indent=2, ensure_ascii=False)
        if role_name != new_name:
             os.remove(old_file_path)


             try:
                  config_path = os.path.join(chatrooms_dir, chatroom_name, CHATROOM_CONFIG_FILENAME)
                  with open(config_path, 'r+', encoding='utf-8') as f:
                      room_config = json.load(f)
                      updated_config = False
                      visibility_value = True

                      if 'roleVisibility' in room_config and role_name in room_config['roleVisibility']:
                            visibility_value = room_config['roleVisibility'].pop(role_name)
                            room_config['roleVisibility'][new_name] = visibility_value
                            updated_config = True

                      if 'roleStates' in room_config and role_name in room_config['roleStates']:
                          room_config['roleStates'][new_name] = room_config['roleStates'].pop(role_name)
                          updated_config = True
                      if 'roleDetailedStates' in room_config and role_name in room_config['roleDetailedStates']:
                          room_config['roleDetailedStates'][new_name] = room_config['roleDetailedStates'].pop(role_name)
                          updated_config = True

                      if updated_config:
                          f.seek(0)
                          json.dump(room_config, f, indent=2, ensure_ascii=False)
                          f.truncate()
             except Exception as update_e:
                  print(f"Warning: Role file renamed/updated, but failed to update chatroom config states/visibility: {update_e}", file=sys.stderr)

        return jsonify({"message": f"Role '{new_name}' updated successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to update role: {e}"}), 500


@app.route('/roles/<chatroom_name>/<role_name>', methods=['DELETE'])
def delete_role_route(chatroom_name, role_name):
    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    roles_dir = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, ROLES_SUBDIR))
    role_file_path = os.path.abspath(os.path.join(roles_dir, f"{role_name}.json"))

    if not is_safe_path(roles_dir, base_dir=chatrooms_dir) or not is_safe_path(role_file_path, base_dir=roles_dir):
        return jsonify({"error": "Invalid role path"}), 400
    if not os.path.exists(role_file_path):
        return jsonify({"error": "Role file not found"}), 404

    try:
        os.remove(role_file_path)

        try:
             config_path = os.path.join(chatrooms_dir, chatroom_name, CHATROOM_CONFIG_FILENAME)
             with open(config_path, 'r+', encoding='utf-8') as f:
                 room_config = json.load(f)
                 updated_config = False
                 if 'roleStates' in room_config and role_name in room_config['roleStates']:
                     del room_config['roleStates'][role_name]
                     updated_config = True
                 if 'roleDetailedStates' in room_config and role_name in room_config['roleDetailedStates']:
                     del room_config['roleDetailedStates'][role_name]
                     updated_config = True
                 if 'roleVisibility' in room_config and role_name in room_config['roleVisibility']:
                     del room_config['roleVisibility'][role_name]
                     updated_config = True

                 if updated_config:
                     f.seek(0)
                     json.dump(room_config, f, indent=2, ensure_ascii=False)
                     f.truncate()
        except Exception as update_e:
             print(f"Warning: Role file deleted, but failed to update chatroom config states/visibility: {update_e}", file=sys.stderr)

        return jsonify({"message": f"Role '{role_name}' deleted successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to delete role: {e}"}), 500


@app.route('/novels/<chatroom_name>', methods=['POST'])
def create_novel_route(chatroom_name):
    novel_data = request.json
    novel_id = novel_data.get('id') if isinstance(novel_data, dict) else None
    novel_name = novel_data.get('name') if isinstance(novel_data, dict) else None

    if not novel_id or not isinstance(novel_id, str) or '..' in novel_id or '/' in novel_id or '\\' in novel_id:
        return jsonify({"error": "Invalid or missing novel ID"}), 400
    if not novel_name:
         novel_name = f"Novel_{novel_id}"

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    novels_dir = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, NOVELS_SUBDIR))
    novel_file_path = os.path.abspath(os.path.join(novels_dir, f"{novel_id}.json"))

    if not is_safe_path(novels_dir, base_dir=chatrooms_dir) or not is_safe_path(novel_file_path, base_dir=novels_dir):
        return jsonify({"error": "Invalid novel path"}), 400
    if not os.path.isdir(novels_dir):
         os.makedirs(novels_dir, exist_ok=True)
    if os.path.exists(novel_file_path):
        return jsonify({"error": "Novel ID already exists"}), 409

    novel_definition = {
        "id": novel_id,
        "name": novel_name,
        "segments": novel_data.get("segments", []),
        "toc": novel_data.get("toc", [])
    }

    try:
        with open(novel_file_path, 'w', encoding='utf-8') as f:
            json.dump(novel_definition, f, indent=2, ensure_ascii=False)
        return jsonify({"message": f"Novel '{novel_name}' (ID: {novel_id}) created successfully"}), 201
    except Exception as e:
        return jsonify({"error": f"Failed to create novel file: {e}"}), 500


@app.route('/novels/<chatroom_name>/<novel_id>', methods=['PUT'])
def update_novel_route(chatroom_name, novel_id):
    novel_data = request.json
    new_name = novel_data.get('name') if isinstance(novel_data, dict) else None

    if not novel_id or not isinstance(novel_id, str):
        return jsonify({"error": "Invalid novel ID in URL"}), 400
    if not new_name:
         new_name = f"Novel_{novel_id}"

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    novels_dir = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, NOVELS_SUBDIR))
    novel_file_path = os.path.abspath(os.path.join(novels_dir, f"{novel_id}.json"))

    if not is_safe_path(novels_dir, base_dir=chatrooms_dir) or not is_safe_path(novel_file_path, base_dir=novels_dir):
        return jsonify({"error": "Invalid novel path"}), 400
    if not os.path.exists(novel_file_path):
        return jsonify({"error": "Novel not found"}), 404

    novel_definition = {
        "id": novel_id,
        "name": new_name,
        "segments": novel_data.get("segments", []),
        "toc": novel_data.get("toc", [])
    }

    try:
        with open(novel_file_path, 'w', encoding='utf-8') as f:
            json.dump(novel_definition, f, indent=2, ensure_ascii=False)
        return jsonify({"message": f"Novel '{new_name}' (ID: {novel_id}) updated successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to update novel file: {e}"}), 500


@app.route('/novels/<chatroom_name>/<novel_id>', methods=['DELETE'])
def delete_novel_route(chatroom_name, novel_id):
    if not novel_id or not isinstance(novel_id, str):
        return jsonify({"error": "Invalid novel ID in URL"}), 400

    chatrooms_dir = os.path.abspath(CHATROOMS_DIR)
    novels_dir = os.path.abspath(os.path.join(chatrooms_dir, chatroom_name, NOVELS_SUBDIR))
    novel_file_path = os.path.abspath(os.path.join(novels_dir, f"{novel_id}.json"))

    if not is_safe_path(novels_dir, base_dir=chatrooms_dir) or not is_safe_path(novel_file_path, base_dir=novels_dir):
        return jsonify({"error": "Invalid novel path"}), 400
    if not os.path.exists(novel_file_path):
        return jsonify({"error": "Novel file not found"}), 404

    try:
        os.remove(novel_file_path)

        try:
             config_path = os.path.join(chatrooms_dir, chatroom_name, CHATROOM_CONFIG_FILENAME)
             with open(config_path, 'r+', encoding='utf-8') as f:
                 room_config = json.load(f)
                 updated = False
                 if 'activeNovelIds' in room_config and novel_id in room_config['activeNovelIds']:
                     room_config['activeNovelIds'].remove(novel_id)
                     updated = True
                 if 'novelCurrentSegmentIds' in room_config and novel_id in room_config['novelCurrentSegmentIds']:
                     del room_config['novelCurrentSegmentIds'][novel_id]
                     updated = True
                 if updated:
                     f.seek(0)
                     json.dump(room_config, f, indent=2, ensure_ascii=False)
                     f.truncate()
        except Exception as update_e:
             print(f"Warning: Novel file deleted, but failed to update chatroom config: {update_e}", file=sys.stderr)

        return jsonify({"message": f"Novel ID '{novel_id}' deleted successfully"})
    except Exception as e:
        return jsonify({"error": f"Failed to delete novel: {e}"}), 500


if __name__ == '__main__':
    app.run(debug=False, host='0.0.0.0', port=8888)
```
--- END OF FILE backend.py ---


--- START OF FILE gemini_chat.html ---
```html
<!DOCTYPE html>
<html>
<head>
    <title>绳墨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: sans-serif;
            background-color: #121212;
            color: #c0c0c0;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            font-size: 1.5em;
            -webkit-tap-highlight-color: transparent;
        }

        .std-button {
            color: #e0c2a3;
            background-color: #3a3a3a;
            border: 1px solid #e0c2a3;
            border-radius: 5px;
            text-align: center;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 36px;
            height: 36px;
            line-height: normal;
            z-index: 5;
            cursor: pointer;
            user-select: none;
        }

        .std-button.role-state-active {
            background-color: green;
        }

        .std-button.edit-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        #chat-container {
            width: 100%;
            max-width: 600px;
            background-color: inherit;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            position: relative;
            overflow: hidden;
            background-size: auto 100vh;
            background-position: center center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }

        #top-toolbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 36px;
            display: flex;
            align-items: center;
            z-index: 5;
            background-color: transparent;
            box-sizing: border-box;
            padding: 0;
        }

        #settings-icon {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 11;
            background-color: transparent;
        }

        #novel-button {
            position: absolute;
            top: 0;
            right: 75px;
            z-index: 9;
            background-color: transparent;
        }


        #role-button {
            margin-left: 36px;
            background-color: transparent;
        }
        #rule-button {
             margin-left: 0;
             background-color: transparent;
        }

        #add-admin-button {
             background-color: transparent;
             margin-left: 5px;
        }

        #run-pause-button {
            background-color: transparent;
        }

        #loading-spinner {
            display: none;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, calc(-50% + 5px));
            width: 24px;
            height: 24px;
            border: 3px solid rgba(224, 194, 163, 0.3);
            border-radius: 50%;
            border-top-color: #e0c2a3;
            z-index: 6;
        }

        #loading-spinner.spinning {
            animation: spin 1s linear infinite;
        }

        #loading-spinner.retry-indicator {
             border-top-color: red;
        }

        @keyframes spin {
            to {
                transform: translate(-50%, calc(-50% + 5px)) rotate(360deg);
            }
        }


        #role-buttons-wrapper {
            position: absolute;
            top: 36px;
            left: 0;
            right: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            z-index: 5;
            max-height: calc(100vh - 36px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #555 #121212;
        }


        #role-buttons-list-container {
            display: none;
            flex-direction: column;
            align-items: flex-start;
            z-index: 6;
        }

        .role-button-container {
            display: flex;
            align-items: center;
            margin-bottom: 0px;
        }

        .role-button-container .std-button {
            margin-right: 0px;
        }

        .role-state-buttons {
            display: none;
        }

        .role-state-buttons.active {
            display: flex;
        }

        .role-state-buttons .std-button {
            margin-left: 0px;
        }

        #active-role-trigger-list {
            position: absolute;
            top: 36px;
            right: 0px;
            width: auto;
            max-width: 150px;
            display: none;
            flex-direction: column;
            align-items: flex-end;
            background-color: #252525;
            border: 1px solid #555;
            border-radius: 0 0 5px 5px;
            z-index: 7;
            padding: 5px;
            gap: 5px;
        }

        .active-role-trigger-button {
            background-color: #3a3a3a;
            color: #e0c2a3;
            border: 1px solid #777;
            border-radius: 3px;
            padding: 5px 8px;
            text-align: center;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9em;
            line-height: 1.2;
            height: auto;
            min-height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #settings-panel,
        .setting-page-template,
        #image-viewer-page {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: inherit;
            z-index: 10;
            overflow-y: auto;
        }



        .setting-page-template.active,
        #settings-panel.active,
        #image-viewer-page.active {
            display: flex;
        }


        .settings-header {
            text-align: center;
            color: #e0c2a3;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
            position: relative;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-button {
            position: absolute;
            top: 0;
            right: 0;
        }

        .settings-section {
            box-sizing: border-box;
            width: 100%;
            flex-grow: 1;
            overflow-y: auto;
            padding-bottom: 40px;
        }

        .settings-group {
            margin-bottom: 20px;
            padding: 0 10px;
        }

        .settings-label {
            display: block;
            margin-bottom: 5px;
            color: #ddd;
            font-weight: bold;
        }

        .settings-input,
        .settings-textarea,
        .settings-select,
        .settings-menu-item {
            width: 100%;
            margin-bottom: 10px;
            border: 1px solid #555;
            background-color: #252525;
            color: #f0f0f0;
            box-sizing: border-box;
            padding: 8px 10px;
            cursor: pointer;
            text-align: left;
            border-radius: 5px;
            display: block;
            font-size: 1em;
            font-family: inherit;
        }


        .settings-menu-item:hover {
            background-color: #3a3a3a;
        }

        .settings-textarea {
            height: 100px;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            resize: vertical;
        }

        #error-log-display {
            height: 200px;
            font-size: 0.8em;
        }
        #world-info-display {
             height: 150px;
             font-size: 0.8em;
             white-space: pre;
        }
        #novelai-last-prompt-display {
             height: 150px;
             font-size: 0.8em;
             white-space: pre-wrap;
             background-color: #303030;
        }
        #roleplay-rules-textarea {
            height: 150px;
        }
        #public-info-textarea {
            height: 150px;
        }
         #system-instruction-preset-settings,
         #shared-database-instruction-settings,
         #chatroom-main-prompt-settings,
         #drawing-master-main-prompt-settings,
         #drawing-master-novel-content-settings,
         #game-host-main-prompt-settings,
         #writing-master-main-prompt-settings,
         #character-update-master-main-prompt-settings,
         #private-assistant-main-prompt-settings,

         #chatroom-override-general-shared-database-instruction,
         #chatroom-override-general-main-prompt,
         #chatroom-override-drawingMaster-tool-database-instruction,
         #chatroom-override-drawingMaster-main-prompt,
         #chatroom-override-drawingMaster-novel-content,
         #chatroom-override-gameHost-tool-database-instruction,
         #chatroom-override-gameHost-main-prompt,
         #chatroom-override-writingMaster-tool-database-instruction,
         #chatroom-override-writingMaster-main-prompt,
         #chatroom-override-characterUpdateMaster-tool-database-instruction,
         #chatroom-override-characterUpdateMaster-main-prompt,
         #chatroom-override-privateAssistant-tool-database-instruction,
         #chatroom-override-privateAssistant-main-prompt,
         #response-schema-json-settings,
         #response-schema-parser-js-settings,
         #drawing-master-response-schema-json-settings,
         #drawing-master-response-schema-parser-js-settings,
         #game-host-response-schema-json-settings,
         #game-host-response-schema-parser-js-settings,
         #writing-master-response-schema-json-settings,
         #writing-master-response-schema-parser-js-settings,
         #character-update-master-response-schema-json-settings,
         #character-update-master-response-schema-parser-js-settings,
         #private-assistant-response-schema-json-settings,
         #private-assistant-response-schema-parser-js-settings,
         #chatroom-override-general-response-schema-json,
         #chatroom-override-general-response-schema-parser-js,
         #chatroom-override-drawingMaster-response-schema-json,
         #chatroom-override-drawingMaster-response-schema-parser-js,
         #chatroom-override-gameHost-response-schema-json,
         #chatroom-override-gameHost-response-schema-parser-js,
         #chatroom-override-writingMaster-response-schema-json,
         #chatroom-override-writingMaster-response-schema-parser-js,
         #chatroom-override-characterUpdateMaster-response-schema-json,
         #chatroom-override-characterUpdateMaster-response-schema-parser-js,
         #chatroom-override-privateAssistant-response-schema-json,
         #chatroom-override-privateAssistant-response-schema-parser-js {
             height: 150px;
         }

        .setting-page-template .settings-group input[type="checkbox"] + label {
            margin-left: 8px;
            cursor: pointer;
            flex-grow: 1;
            vertical-align: middle;
            display: inline;
        }

        .setting-page-template .settings-group input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #777;
            border-radius: 3px;
            background-color: #252525;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            vertical-align: middle;
            margin-left: 5px;
        }

        .setting-page-template .settings-group input[type="checkbox"]:checked {
            border-color: #e0c2a3;
        }

        .setting-page-template .settings-group input[type="checkbox"]:checked::after {
            content: '✔';
            display: block;
            position: absolute;
            top: -1px;
            left: 0px;
            width: 100%;
            height: 100%;
            font-size: 14px;
            line-height: 16px;
            text-align: center;
            color: #e0c2a3;
        }

        #role-list-container,
        #chatroom-list-container,
        #novel-list-container {
            margin-top: 10px;
        }


        .role-item,
        .chatroom-item,
        .novel-item,

        .prompt-preset-item {
            padding: 8px;
            background-color: #252525;
            color: #f0f0f0;
            margin-bottom: 5px;
            border-radius: 5px;

            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .role-item span,
        .chatroom-item label,
        .novel-item .novel-name,

        .prompt-preset-item .preset-role-label
         {
            margin-left: 8px;
            cursor: pointer;
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }


        .role-item span { margin-left: 0; }
        .novel-item .novel-name { margin-left: 0; cursor: default; }

        .prompt-preset-item .preset-role-label { margin-left: 0; cursor: default; width: 20px; flex-grow: 0; flex-shrink: 0; text-align: center; font-weight:bold; }
        .prompt-preset-item .preset-instruction-textarea {
            flex-grow: 1;
            height: 60px;
            margin: 0 5px 0 0;
            font-size: 0.9em;
            line-height: 1.3;
            resize: vertical;
            font-family: monospace;
            white-space: pre-wrap;
            border: 1px solid #555;
            background-color: #303030;
            color: #f0f0f0;
            border-radius: 5px;
            padding: 5px;
        }


        .item-actions {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }
         .prompt-preset-item .item-actions {
             flex-direction: column;
             gap: 3px;
         }
         .prompt-preset-item .item-actions .std-button {
             width: 24px;
             height: 24px;
             font-size: 0.8em;
         }

        .chatroom-item input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #777;
            border-radius: 50%;
            background-color: #252525;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            margin-right: 5px;
        }

        .chatroom-item input[type="radio"]:checked {
            border-color: #e0c2a3;
        }

        .chatroom-item input[type="radio"]:checked::after {
            content: '';
            display: block;
            position: absolute;
            top: 3px;
            left: 3px;
            width: 8px;
            height: 8px;
            background-color: #e0c2a3;
            border-radius: 50%;
        }


        #chat-area {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            scrollbar-width: none;
            scrollbar-color: auto;
            height: 100%;
            background-color: transparent;
            box-sizing: border-box;
            padding-top: 36px;
            padding-bottom: 60vh;
        }
        #chat-area::-webkit-scrollbar {
             display: none;
        }

        .message-container {
            display: flex;
            flex-direction: column;
            margin: 8px 10px;
            max-width: 95%;
            position: relative;
            order: 1;
        }


        .message-container[data-source-type="user"] {
            align-items: flex-end;
        }
        .message-container:not([data-source-type="user"]) {
            align-items: flex-start;
        }


        .role-name-button-above-bubble {
            margin-bottom: -8px;
            margin-left: 10px;
            z-index: 1;
            align-self: flex-start;
        }

        .message-container[data-source-type="user"] .role-name-button-above-bubble {
            align-self: flex-end;
            margin-right: 10px;
            margin-left: 0px;
        }


        .user-message, .ai-response {
            word-wrap: break-word;
            overflow-wrap: break-word;
            border-radius: 15px;
            padding: 10px;
            z-index: 1;
            position: relative;
            margin-top: 8px;
            white-space: pre-wrap;
            background-color: #FFF2E2;
            color: #000;
            text-align: left;
            max-width: 100%;
            box-sizing: border-box;
        }

        .ai-response img {
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 5px;
        }


        #image-viewer-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 101;
            display: none;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            overflow: hidden;
        }
        #image-viewer-page.active {
             display: flex;
        }

        #image-viewer-content {
            display: block;
            height: 100%;
            width: auto;
            max-width: none;
            object-fit: contain;
            margin: auto;
        }


        .message-actions-container {
            display: none;
            position: absolute;
            top: 0;
            align-items: center;
            z-index: 2;
            left: 46px;
            gap: 0;
        }

        .message-container[data-source-type="user"] .message-actions-container {
            right: 46px;
            left: auto;
        }


        .message-actions-container.active {
            display: flex;
        }


        .tool-setting-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .tool-setting-item label {
            margin-left: 8px;
            cursor: pointer;
            flex-grow: 1;
        }


        #drawing-master-enabled-settings,
        #game-host-enabled-settings,
        #writing-master-enabled-settings,
        #character-update-master-enabled-settings,
        #private-assistant-enabled-settings,

        #novel-bookshelf-page .novel-activation-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #777;
            border-radius: 3px;
            background-color: #252525;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            vertical-align: middle;
            margin-left: 5px;
        }

        #drawing-master-enabled-settings:checked,
        #game-host-enabled-settings:checked,
        #writing-master-enabled-settings:checked,
        #character-update-master-enabled-settings:checked,
        #private-assistant-enabled-settings:checked,

        #novel-bookshelf-page .novel-activation-checkbox:checked {
            border-color: #e0c2a3;
        }

        #drawing-master-enabled-settings:checked::after,
        #game-host-enabled-settings:checked::after,
        #writing-master-enabled-settings:checked::after,
        #character-update-master-enabled-settings:checked::after,
        #private-assistant-enabled-settings:checked::after,

        #novel-bookshelf-page .novel-activation-checkbox:checked::after {
            content: '✔';
            display: block;
            position: absolute;
            top: -1px;
            left: 0px;
            width: 100%;
            height: 100%;
            font-size: 14px;
            line-height: 16px;
            text-align: center;
            color: #e0c2a3;
        }


        #novel-interface {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #FFF2E2;
            color: #000;
            z-index: 8;
            overflow: hidden;

            flex-direction: column;
        }
        #novel-interface.active {
            display: flex;
        }

        #novel-interface-toolbar {
            position: absolute;
            top: 0;
            right: 0;
            height: 36px;
            display: flex;
            align-items: center;
            padding-right: 108px;
            z-index: 9;
        }

        #novel-bookshelf-button,
        #novel-toc-button {
             background-color: transparent;
             color: #3a3a3a;
             border-color: #3a3a3a;
             margin-left: 0px;
        }


        #novel-bookshelf-button {
            position: absolute;
            top: 0;
            right: 111px;
        }
        #novel-toc-button {
            position: absolute;
            top: 0;
            right: 147px;
        }

        #novel-content-area {
            flex-grow: 1;
            height: calc(100% - 36px);
            overflow-y: auto;
            padding: 46px 10px 10px 10px;
            box-sizing: border-box;
            font-size: 1em;
            line-height: 1.3;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            margin-top: 36px;
        }

        #novel-content-area .novel-chapter-marker {
            display: block;
            font-weight: bold;
            margin-top: 0.5em;
            margin-bottom: 0.2em;
        }



        #novel-bookshelf-page,
        #novel-toc-page {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: inherit;
            color: inherit;
            z-index: 10;
            overflow-y: auto;
            flex-direction: column;
        }
        #novel-bookshelf-page.active,
        #novel-toc-page.active {
            display: flex;
        }


        .novel-page-header {
             text-align: center;
             color: #3a3a3a;
             margin-bottom: 8px;
             padding-bottom: 5px;
             border-bottom: 1px solid #ccc;
             position: relative;
             height: 36px;
             display: flex;
             align-items: center;
             justify-content: center;
             flex-shrink: 0;
        }


        .novel-close-button {
             position: absolute;
             top: 0;
             right: 0;
             background-color: transparent;
             color: #3a3a3a;
             border-color: #3a3a3a;
        }

        .novel-page-section {
            box-sizing: border-box;
            padding-top: 10px;
            flex-grow: 1;
            overflow-y: auto;
        }

        .novel-page-group {
            margin-bottom: 20px;
            padding: 0 10px;
        }


        #novel-bookshelf-list-container .novel-bookshelf-item,
        #novel-toc-list-container .novel-toc-item {
            padding: 8px;
            background-color: #f0e6d8;
            color: #000;
            margin-bottom: 5px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        #novel-bookshelf-list-container .novel-bookshelf-item label {
            flex-grow: 1;
            margin-left: 5px;
            margin-right: 5px;
        }
        #novel-bookshelf-list-container .novel-bookshelf-item input[type="radio"] {
             appearance: none;
             -webkit-appearance: none;
             -moz-appearance: none;
             width: 16px;
             height: 16px;
             border: 2px solid #777;
             border-radius: 50%;
             background-color: #FFF2E2;
             cursor: pointer;
             position: relative;
             flex-shrink: 0;
        }
         #novel-bookshelf-list-container .novel-bookshelf-item input[type="radio"]:checked {
             border-color: #8B4513;
         }
         #novel-bookshelf-list-container .novel-bookshelf-item input[type="radio"]:checked::after {
            content: '';
            display: block;
            position: absolute;
            top: 3px;
            left: 3px;
            width: 8px;
            height: 8px;
            background-color: #8B4513;
            border-radius: 50%;
         }

         #novel-toc-list-container .novel-toc-item {
             cursor: pointer;
             text-align: left;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
         }
         #novel-toc-list-container .novel-toc-item.current-chapter {
             font-weight: bold;
         }

         .ai-response .game-host-controls {
             display: flex;
             margin-bottom: 5px;
             gap: 5px;
         }

         .ai-response .game-host-view-button {
             display: inline-block;
             background: none;
             border: none;
             padding: 0;
             margin: 0;
             font-size: 1.2em;
             cursor: pointer;
             color: #3a3a3a;
             vertical-align: middle;
             width: auto;
             height: auto;
             line-height: normal;
             border-radius: 0;
         }

         .ai-response .game-host-view-button.active {
             opacity: 0.5;
             background: none;
             color: #3a3a3a;
             border: none;
         }

         .ai-response .game-host-content {
             font-size: 0.9em;
             line-height: 1.6;
             margin-top: 5px;
             padding: 0;
             color: #3a3a3a;
             white-space: normal;
         }
         .ai-response .game-host-content .value-block {
             display: inline-block;
             background-color: #e8d8c2;
             color: #3a3a3a;
             padding: 1px 5px;
             border-radius: 3px;
             margin-right: 5px;
             margin-bottom: 3px;
             white-space: pre-wrap;
             vertical-align: baseline;
         }
         .ai-response .game-host-content .icon {
             margin-right: 5px;
             vertical-align: baseline;
         }
         .ai-response .game-host-content > div {
             margin-bottom: 2px;
         }

         #api-key-failure-counts-display {
            font-size: 0.8em;
            color: #aaa;
            max-height: 100px;
            overflow-y: auto;
            background-color: #1c1c1c;
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #444;
        }
        #api-key-failure-counts-display div {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 3px;
        }
        #api-key-failure-counts-display .key-prefix {
            color: #bbb;
            margin-right: 5px;
        }
        #api-key-failure-counts-display .fail-count {
            font-weight: bold;
            color: #d99;
            margin-left: 5px;
        }
         #prompt-preset-list-container {
            margin-top: 10px;
         }
         .prompt-preset-actions {
             display: flex;
             gap: 10px;
             margin-bottom: 10px;
         }
         .prompt-preset-actions .settings-menu-item {
             margin-bottom: 0;
             width: auto;
             flex-grow: 1;
             text-align: center;
         }

         .chatroom-management-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
         }
         .chatroom-management-grid .settings-menu-item {
             margin-bottom: 0;
         }

        #pending-action-button-container {
            margin: 0;
            position: absolute;
            top: 36px;
            right: 0px;
            z-index: 5;
            display: flex;
            justify-content: flex-end;
        }

        #pending-action-button-container .std-button {
            background-color: transparent;
        }

        .button-group-horizontal {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        .button-group-horizontal > .settings-menu-item {
            flex-grow: 1;
            margin-bottom: 0;
        }
        .button-group-horizontal > input[type="file"] {
             display: none;
        }

    </style>
</head>
<body>

    <div id="chat-container">
        <div id="settings-icon" class="std-button">⚙</div>
        <div id="novel-button" class="std-button">📖</div>

        <div id="top-toolbar">
            <div id="role-button" class="std-button">👤</div>
            <div id="rule-button" class="std-button">📜</div>
            <div id="loading-spinner"></div>
             <div style="margin-left: auto; display: flex; flex-direction: column; align-items: flex-end;">
                <div style="display: flex; align-items: center;">
                    <div id="add-admin-button" class="std-button">📏</div>
                    <div id="run-pause-button" class="std-button">▶</div>
                </div>
                <div id="pending-action-button-container" style="margin: 0;"></div>
             </div>
        </div>

        <div id="role-buttons-wrapper">
           <div id="role-buttons-list-container">
           </div>
        </div>

        <div id="active-role-trigger-list">
        </div>


        <div id="settings-panel">

             <div id="settings-main-page" class="setting-page-template active" style="flex-direction: column;">
                 <div class="settings-header">
                     设置

                 </div>
                 <div id="settings-menu" class="settings-section">
                     <div class="settings-menu-item" data-target="api-settings-page">API 设置</div>
                     <div class="settings-menu-item" data-target="prompt-preset-page">提示词预设</div>
                     <div class="settings-menu-item" data-target="novelai-settings-page">绘图设置</div>
                     <div class="settings-menu-item" data-target="error-log-page">报错日志</div>

                     <div class="settings-menu-item" data-target="chat-room-settings-page">聊天室设置</div>
                     <div class="settings-menu-item" data-target="tool-list-page">工具列表</div>

                 </div>
             </div>

             <div id="api-settings-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     API 设置
                     <div class="close-button std-button">✕</div>
                 </div>
                  <div class="settings-section">
                    <div class="settings-group api-settings">
                        <label for="api-key-textarea-settings" class="settings-label">谷歌 API 密钥 (每行一个)</label>
                        <textarea id="api-key-textarea-settings" class="settings-textarea"></textarea>
                        <div id="api-key-failure-counts-display" class="settings-group" style="margin-top: 10px;"></div>
                        <div id="fetch-models-button" class="settings-menu-item">拉取模型列表</div>
                    </div>

                    <div class="settings-group sending-settings">
                        <label for="temperature-settings" class="settings-label">Temperature</label>
                        <input type="number" id="temperature-settings" class="settings-input" value="1.0" step="0.1">

                        <label for="top-p-settings" class="settings-label">Top P</label>
                        <input type="number" id="top-p-settings" class="settings-input" value="0.9" step="0.01">

                        <label for="top-k-settings" class="settings-label">Top K</label>
                        <input type="number" id="top-k-settings" class="settings-input" value="40" type="number">

                        <label for="max-output-tokens-settings" class="settings-label">Max Output Tokens</label>
                        <input type="number" id="max-output-tokens-settings" class="settings-input" value="2048">

                        <label for="response-mime-type-settings" class="settings-label">Response Mime Type</label>
                        <select id="response-mime-type-settings" class="settings-select">
                            <option value="text/plain">text/plain</option>
                            <option value="application/json" selected>application/json</option>
                            <option value="text/x.enum">text/x-enum</option>
                        </select>
                    </div>
                  </div>
             </div>

             <div id="prompt-preset-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     提示词预设
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <label for="system-instruction-preset-settings" class="settings-label">System Instruction (全局)</label>
                         <textarea id="system-instruction-preset-settings" class="settings-textarea"></textarea>
                     </div>
                     <div class="settings-group">
                         <label class="settings-label">对话轮次预设</label>
                         <div class="prompt-preset-actions">
                             <div id="add-prompt-user-turn-button" class="settings-menu-item">添加 U</div>
                             <div id="add-prompt-model-turn-button" class="settings-menu-item">添加 M</div>
                         </div>
                         <div id="prompt-preset-list-container">
                         </div>
                          <div class="prompt-preset-actions" style="margin-top: 15px;">
                             <div id="export-prompt-presets-button" class="settings-menu-item">导出预设</div>
                             <input type="file" id="import-prompt-presets-file" style="display: none;" accept=".json">
                             <div id="import-prompt-presets-button" class="settings-menu-item">导入预设</div>
                         </div>
                     </div>
                 </div>
             </div>


             <div id="novelai-settings-page" class="setting-page-template" style="flex-direction: column;">
                <div class="settings-header">
                    绘图设置
                    <div class="close-button std-button">✕</div>
                </div>
                <div class="settings-section">
                   <div class="settings-group novelai-api">
                       <label for="novelai-api-key-settings" class="settings-label">NovelAI API Key</label>
                       <input type="text" id="novelai-api-key-settings" class="settings-input">

                       <label for="novelai-model-settings" class="settings-label">模型 (Model)</label>
                       <select id="novelai-model-settings" class="settings-select">
                           <option value="nai-diffusion-3">nai-diffusion-3</option>
                           <option value="nai-diffusion-4-curated-preview">nai-diffusion-4-curated-preview</option>
                           <option value="nai-diffusion-4-full">nai-diffusion-4-full</option>
                       </select>
                   </div>
                   <div class="settings-group novelai-prompts">
                       <label for="novelai-artist-chain-settings" class="settings-label">艺术家链 (Artist Chain)</label>
                       <input type="text" id="novelai-artist-chain-settings" class="settings-input" autocomplete="off">

                       <label for="novelai-default-positive-prompt-settings" class="settings-label">默认正面提示词</label>
                       <textarea id="novelai-default-positive-prompt-settings" class="settings-textarea"></textarea>

                       <label for="novelai-default-negative-prompt-settings" class="settings-label">默认负面提示词</label>
                       <textarea id="novelai-default-negative-prompt-settings" class="settings-textarea"></textarea>

                       <label for="novelai-last-prompt-display" class="settings-label">上次发送的主要绘图提示词</label>
                       <textarea id="novelai-last-prompt-display" class="settings-textarea" readonly></textarea>
                   </div>
                   <div class="settings-group novelai-params">
                       <label for="novelai-width-settings" class="settings-label">宽度 (Width)</label>
                       <input type="number" id="novelai-width-settings" class="settings-input" value="1024" step="64">

                       <label for="novelai-height-settings" class="settings-label">高度 (Height)</label>
                       <input type="number" id="novelai-height-settings" class="settings-input" value="1024" step="64">

                       <label for="novelai-steps-settings" class="settings-label">步数 (Steps)</label>
                       <input type="number" id="novelai-steps-settings" class="settings-input" value="28" min="1" max="50">

                       <label for="novelai-scale-settings" class="settings-label">引导系数 (Scale)</label>
                       <input type="number" id="novelai-scale-settings" class="settings-input" value="5" step="0.1">

                       <label for="novelai-cfg-rescale-settings" class="settings-label">CFG 重调 (CFG Rescale)</label>
                       <input type="number" id="novelai-cfg-rescale-settings" class="settings-input" value="0" step="0.01">

                       <label for="novelai-sampler-settings" class="settings-label">采样器 (Sampler)</label>
                       <select id="novelai-sampler-settings" class="settings-select">
                           <option value="k_euler">k_euler</option>
                           <option value="k_euler_ancestral">k_euler_ancestral</option>
                           <option value="k_dpmpp_2s_ancestral">k_dpmpp_2s_ancestral</option>
                           <option value="k_dpmpp_2m">k_dpmpp_2m</option>
                           <option value="k_dpm_2">k_dpm_2</option>
                           <option value="ddim_v3">ddim_v3</option>
                       </select>

                       <label for="novelai-noise-schedule-settings" class="settings-label">噪点调度 (Noise Schedule)</label>
                       <select id="novelai-noise-schedule-settings" class="settings-select">
                            <option value="native">native</option>
                            <option value="karras">karras</option>
                            <option value="exponential">exponential</option>
                            <option value="polyexponential">polyexponential</option>
                       </select>

                       <label for="novelai-seed-settings" class="settings-label">种子 (Seed) (0 = 随机)</label>
                       <input type="number" id="novelai-seed-settings" class="settings-input" value="0" min="0">
                   </div>
                </div>
             </div>


             <div id="error-log-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     报错日志
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group error-log-settings">
                        <label for="error-log-display" class="settings-label">错误信息 (仅运行时)</label>
                        <textarea id="error-log-display" class="settings-textarea" readonly></textarea>
                        <div id="copy-error-log-button" class="settings-menu-item">复制错误信息</div>
                        <div id="clear-all-config-button" class="settings-menu-item" style="color: red; border-color: red;">清空全部配置 (危险)</div>
                        <div id="export-config-button" class="settings-menu-item">导出完整配置 (ZIP)</div>
                        <input type="file" id="import-config-file" style="display: none;" accept=".zip">
                        <div id="import-config-button" class="settings-menu-item">导入完整配置 (ZIP)</div>
                    </div>
                 </div>
             </div>


             <div id="role-list-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     聊天室角色
                     <div class="close-button std-button">✕</div>
                 </div>
                  <div class="settings-section">
                    <div class="settings-group role-list">
                        <div class="button-group-horizontal">
                           <div id="add-chatroom-role-button" class="settings-menu-item">十 添加角色</div>
                           <input type="file" id="import-role-file" style="display: none;" accept=".json">
                           <div id="import-role-button" class="settings-menu-item">导入角色</div>
                        </div>
                        <div id="role-list-container">
                        </div>
                    </div>
                 </div>
             </div>

             <div id="role-detail-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     <span id="role-detail-header-title">角色详情</span>
                     <div class="close-button std-button">✕</div>
                 </div>
                  <div class="settings-section">
                    <div class="settings-group role-detail">
                        <label for="role-instruction-textarea" class="settings-label">角色设定</label>
                        <textarea id="role-instruction-textarea" class="settings-textarea"></textarea>

                        <label for="role-memory-textarea" class="settings-label">角色记忆</label>
                        <textarea id="role-memory-textarea" class="settings-textarea"></textarea>

                        <label for="role-state-textarea" class="settings-label">角色状态</label>
                        <textarea id="role-state-textarea" class="settings-textarea" readonly></textarea>

                        <label for="role-drawing-template-settings" class="settings-label">Drawing Template</label>
                        <input type="text" id="role-drawing-template-settings" class="settings-input" autocomplete="off">

                        <div id="export-role-button" class="settings-menu-item" style="margin-top: 15px;">导出此角色</div>
                    </div>
                 </div>
             </div>


             <div id="tool-list-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     工具列表
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div id="tool-list-container" class="settings-section">
                     <div id="tool-list-menu" class="settings-section">
                         <div class="settings-menu-item tool-item" data-target="drawing-master-page">绘图大师</div>
                         <div class="settings-menu-item tool-item" data-target="game-host-page">游戏主持人</div>
                         <div class="settings-menu-item tool-item" data-target="writing-master-page">写作大师</div>
                         <div class="settings-menu-item tool-item" data-target="character-update-master-page">角色更新大师</div>
                         <div class="settings-menu-item tool-item" data-target="private-assistant-page">私人助理</div>
                     </div>
                 </div>
             </div>

             <div id="chat-room-settings-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     聊天室设置
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div id="chat-room-settings-menu" class="settings-section">
                     <div class="settings-menu-item" data-target="general-config-page">通用配置</div>
                     <div class="settings-menu-item" data-target="chat-room-directory-page">聊天室目录</div>
                 </div>
             </div>

             <div id="general-config-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     通用配置
                     <div class="close-button std-button">✕</div>
                 </div>
                  <div class="settings-section">
                    <div class="settings-group general-config">
                         <label for="original-novel-length-settings" class="settings-label">原著小说字符数</label>
                         <input type="number" id="original-novel-length-settings" class="settings-input" value="40000" step="1000">

                         <label for="chatroom-model-select-settings" class="settings-label">模型 (角色/临时角色)</label>
                         <select id="chatroom-model-select-settings" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>

                         <label for="response-schema-json-settings" class="settings-label">Response Schema (JSON) (角色/临时角色)</label>
                         <textarea id="response-schema-json-settings" class="settings-textarea"></textarea>

                         <label for="response-schema-parser-js-settings" class="settings-label">Response Schema Parser (JS) (角色/临时角色)</label>
                         <textarea id="response-schema-parser-js-settings" class="settings-textarea"></textarea>

                         <label for="shared-database-instruction-settings" class="settings-label">共享数据库 (角色/临时角色)</label>
                         <textarea id="shared-database-instruction-settings" class="settings-textarea"></textarea>

                         <label for="chatroom-main-prompt-settings" class="settings-label">主提示词 (角色/临时角色)</label>
                         <textarea id="chatroom-main-prompt-settings" class="settings-textarea"></textarea>
                    </div>
                 </div>
             </div>

             <div id="chat-room-directory-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     聊天室目录
                     <div class="close-button std-button">✕</div>
                 </div>
                  <div class="settings-section">
                    <div class="settings-group chat-room-directory">
                        <div class="button-group-horizontal">
                           <div id="add-chatroom-button" class="settings-menu-item">十 添加聊天室</div>
                           <input type="file" id="import-chatroom-file" style="display: none;" accept=".zip">
                           <div id="import-chatroom-button" class="settings-menu-item">导入 (ZIP)</div>
                        </div>
                        <div id="chatroom-list-container">
                        </div>
                    </div>
                 </div>
             </div>

             <div id="chat-room-detail-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     <span id="chatroom-detail-header-title">聊天室详情 - 1</span>
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div id="chatroom-settings-menu" class="settings-section">
                     <div class="settings-menu-item" data-target="current-chatroom-settings-page">当前聊天室设置</div>
                     <div class="settings-menu-item" data-target="role-list-page">聊天室角色</div>
                     <div class="settings-menu-item" data-target="story-mode-page">聊天室小说</div>
                     <div class="settings-menu-item" data-target="chatroom-override-config-menu-page">聊天室覆盖配置</div>
                 </div>

             </div>

             <div id="current-chatroom-settings-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     当前聊天室设置
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group current-chatroom-settings">
                        <label for="chatroom-history-display" class="settings-label">消息记录</label>
                        <textarea id="chatroom-history-display" class="settings-textarea" readonly></textarea>
                        <div id="clear-chatroom-history-button" class="settings-menu-item">清空消息记录</div>

                        <label for="world-info-display" class="settings-label">最新世界信息</label>
                        <textarea id="world-info-display" class="settings-textarea" readonly></textarea>

                        <label for="roleplay-rules-textarea" class="settings-label">扮演规则 (当前聊天室)</label>
                        <textarea id="roleplay-rules-textarea" class="settings-textarea"></textarea>

                        <label for="public-info-textarea" class="settings-label">公共信息 (当前聊天室)</label>
                        <textarea id="public-info-textarea" class="settings-textarea"></textarea>

                        <label for="chatroom-user-setting" class="settings-label">User (当前聊天室)</label>
                        <input type="text" id="chatroom-user-setting" class="settings-input">

                         <div class="chatroom-management-grid">
                            <div id="rename-chatroom-button" class="settings-menu-item">重命名</div>
                            <div id="delete-chatroom-button" class="settings-menu-item" style="color: red; border-color: red;">删除</div>
                            <div id="export-chatroom-button" class="settings-menu-item">导出 (ZIP)</div>
                        </div>
                    </div>
                 </div>
             </div>


             <div id="story-mode-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     聊天室小说
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group story-mode-list">

                        <div id="novel-list-container">
                        </div>
                    </div>
                 </div>
             </div>


             <div id="drawing-master-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     绘图大师
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group god-settings">
                        <div class="tool-setting-item">
                            <input type="checkbox" id="drawing-master-enabled-settings">
                            <label for="drawing-master-enabled-settings">启用</label>
                        </div>

                        <label for="drawing-master-model-settings" class="settings-label">模型</label>
                        <select id="drawing-master-model-settings" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                        </select>

                        <label for="drawing-master-response-schema-json-settings" class="settings-label">Response Schema (JSON)</label>
                        <textarea id="drawing-master-response-schema-json-settings" class="settings-textarea"></textarea>

                        <label for="drawing-master-response-schema-parser-js-settings" class="settings-label">Response Schema Parser (JS)</label>
                        <textarea id="drawing-master-response-schema-parser-js-settings" class="settings-textarea"></textarea>

                        <label for="drawing-master-tool-database-instruction-settings" class="settings-label">数据库</label>
                        <textarea id="drawing-master-tool-database-instruction-settings" class="settings-textarea"></textarea>

                        <label for="drawing-master-main-prompt-settings" class="settings-label">主提示词</label>
                        <textarea id="drawing-master-main-prompt-settings" class="settings-textarea"></textarea>

                        <label for="drawing-master-novel-content-settings" class="settings-label">原著小说 (绘图大师)</label>
                        <textarea id="drawing-master-novel-content-settings" class="settings-textarea"></textarea>
                    </div>
                 </div>
             </div>

             <div id="game-host-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     游戏主持人
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group god-settings">
                        <div class="tool-setting-item">
                            <input type="checkbox" id="game-host-enabled-settings">
                            <label for="game-host-enabled-settings">启用</label>
                        </div>

                        <label for="game-host-model-settings" class="settings-label">模型</label>
                        <select id="game-host-model-settings" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                        </select>

                        <label for="game-host-response-schema-json-settings" class="settings-label">Response Schema (JSON)</label>
                        <textarea id="game-host-response-schema-json-settings" class="settings-textarea"></textarea>

                        <label for="game-host-response-schema-parser-js-settings" class="settings-label">Response Schema Parser (JS)</label>
                        <textarea id="game-host-response-schema-parser-js-settings" class="settings-textarea"></textarea>

                        <label for="game-host-tool-database-instruction-settings" class="settings-label">数据库</label>
                        <textarea id="game-host-tool-database-instruction-settings" class="settings-textarea"></textarea>

                        <label for="game-host-main-prompt-settings" class="settings-label">主提示词</label>
                        <textarea id="game-host-main-prompt-settings" class="settings-textarea"></textarea>
                    </div>
                 </div>
             </div>

             <div id="writing-master-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     写作大师
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group god-settings">
                        <div class="tool-setting-item">
                             <input type="checkbox" id="writing-master-enabled-settings">
                            <label for="writing-master-enabled-settings">启用</label>
                        </div>

                        <label for="writing-master-model-settings" class="settings-label">模型</label>
                        <select id="writing-master-model-settings" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                        </select>

                        <label for="writing-master-response-schema-json-settings" class="settings-label">Response Schema (JSON)</label>
                        <textarea id="writing-master-response-schema-json-settings" class="settings-textarea"></textarea>

                        <label for="writing-master-response-schema-parser-js-settings" class="settings-label">Response Schema Parser (JS)</label>
                        <textarea id="writing-master-response-schema-parser-js-settings" class="settings-textarea"></textarea>

                        <label for="writing-master-tool-database-instruction-settings" class="settings-label">数据库</label>
                        <textarea id="writing-master-tool-database-instruction-settings" class="settings-textarea"></textarea>

                        <label for="writing-master-main-prompt-settings" class="settings-label">主提示词</label>
                        <textarea id="writing-master-main-prompt-settings" class="settings-textarea"></textarea>
                    </div>
                 </div>
             </div>

             <div id="character-update-master-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     角色更新大师
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group god-settings">
                        <div class="tool-setting-item">
                             <input type="checkbox" id="character-update-master-enabled-settings">
                            <label for="character-update-master-enabled-settings">启用</label>
                        </div>

                         <label for="character-update-master-model-settings" class="settings-label">模型</label>
                         <select id="character-update-master-model-settings" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>

                        <label for="character-update-master-response-schema-json-settings" class="settings-label">Response Schema (JSON)</label>
                        <textarea id="character-update-master-response-schema-json-settings" class="settings-textarea"></textarea>

                        <label for="character-update-master-response-schema-parser-js-settings" class="settings-label">Response Schema Parser (JS)</label>
                        <textarea id="character-update-master-response-schema-parser-js-settings" class="settings-textarea"></textarea>

                        <label for="character-update-master-tool-database-instruction-settings" class="settings-label">数据库</label>
                        <textarea id="character-update-master-tool-database-instruction-settings" class="settings-textarea"></textarea>

                        <label for="character-update-master-main-prompt-settings" class="settings-label">主提示词</label>
                        <textarea id="character-update-master-main-prompt-settings" class="settings-textarea"></textarea>
                    </div>
                 </div>
             </div>

             <div id="private-assistant-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     私人助理
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                    <div class="settings-group god-settings">
                        <div class="tool-setting-item">
                             <input type="checkbox" id="private-assistant-enabled-settings">
                            <label for="private-assistant-enabled-settings">启用</label>
                        </div>

                         <label for="private-assistant-model-settings" class="settings-label">模型</label>
                         <select id="private-assistant-model-settings" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>

                        <label for="private-assistant-response-schema-json-settings" class="settings-label">Response Schema (JSON)</label>
                        <textarea id="private-assistant-response-schema-json-settings" class="settings-textarea"></textarea>

                        <label for="private-assistant-response-schema-parser-js-settings" class="settings-label">Response Schema Parser (JS)</label>
                        <textarea id="private-assistant-response-schema-parser-js-settings" class="settings-textarea"></textarea>

                        <label for="private-assistant-tool-database-instruction-settings" class="settings-label">数据库</label>
                        <textarea id="private-assistant-tool-database-instruction-settings" class="settings-textarea"></textarea>

                        <label for="private-assistant-main-prompt-settings" class="settings-label">主提示词</label>
                        <textarea id="private-assistant-main-prompt-settings" class="settings-textarea"></textarea>
                    </div>
                 </div>
             </div>


             <div id="chatroom-override-config-menu-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     聊天室覆盖配置
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div id="chatroom-override-config-menu" class="settings-section">
                     <div class="settings-menu-item" data-target="chatroom-override-general-page">通用配置覆盖</div>
                     <div class="settings-menu-item" data-target="chatroom-override-drawingMaster-page">绘图大师覆盖</div>
                     <div class="settings-menu-item" data-target="chatroom-override-gameHost-page">游戏主持人覆盖</div>
                     <div class="settings-menu-item" data-target="chatroom-override-writingMaster-page">写作大师覆盖</div>
                     <div class="settings-menu-item" data-target="chatroom-override-characterUpdateMaster-page">角色更新大师覆盖</div>
                     <div class="settings-menu-item" data-target="chatroom-override-privateAssistant-page">私人助理覆盖</div>
                 </div>
             </div>


             <div id="chatroom-override-general-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     通用配置覆盖
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <input type="checkbox" id="chatroom-override-general-enabled">
                         <label for="chatroom-override-general-enabled">启用通用配置覆盖</label>

                         <label for="chatroom-override-general-model-select" class="settings-label" style="margin-top:15px;">模型 (角色/临时角色)</label>
                         <select id="chatroom-override-general-model-select" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>

                         <label for="chatroom-override-general-response-schema-json" class="settings-label">Response Schema (JSON) (角色/临时角色)</label>
                         <textarea id="chatroom-override-general-response-schema-json" class="settings-textarea"></textarea>

                         <label for="chatroom-override-general-response-schema-parser-js" class="settings-label">Response Schema Parser (JS) (角色/临时角色)</label>
                         <textarea id="chatroom-override-general-response-schema-parser-js" class="settings-textarea"></textarea>

                         <label for="chatroom-override-general-shared-database-instruction" class="settings-label">共享数据库 (角色/临时角色)</label>
                         <textarea id="chatroom-override-general-shared-database-instruction" class="settings-textarea"></textarea>

                         <label for="chatroom-override-general-main-prompt" class="settings-label">主提示词 (角色/临时角色)</label>
                         <textarea id="chatroom-override-general-main-prompt" class="settings-textarea"></textarea>
                     </div>
                 </div>
             </div>


             <div id="chatroom-override-drawingMaster-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     绘图大师覆盖
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <input type="checkbox" id="chatroom-override-drawingMaster-enabled">
                         <label for="chatroom-override-drawingMaster-enabled">启用绘图大师覆盖</label>

                         <label for="chatroom-override-drawingMaster-model-select" class="settings-label" style="margin-top:15px;">模型</label>
                         <select id="chatroom-override-drawingMaster-model-select" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>
                         <label for="chatroom-override-drawingMaster-response-schema-json" class="settings-label">Response Schema (JSON)</label>
                         <textarea id="chatroom-override-drawingMaster-response-schema-json" class="settings-textarea"></textarea>
                         <label for="chatroom-override-drawingMaster-response-schema-parser-js" class="settings-label">Response Schema Parser (JS)</label>
                         <textarea id="chatroom-override-drawingMaster-response-schema-parser-js" class="settings-textarea"></textarea>
                         <label for="chatroom-override-drawingMaster-tool-database-instruction" class="settings-label">数据库</label>
                         <textarea id="chatroom-override-drawingMaster-tool-database-instruction" class="settings-textarea"></textarea>
                         <label for="chatroom-override-drawingMaster-main-prompt" class="settings-label">主提示词</label>
                         <textarea id="chatroom-override-drawingMaster-main-prompt" class="settings-textarea"></textarea>
                         <label for="chatroom-override-drawingMaster-novel-content" class="settings-label">原著小说 (绘图大师)</label>
                         <textarea id="chatroom-override-drawingMaster-novel-content" class="settings-textarea"></textarea>
                     </div>
                 </div>
             </div>


              <div id="chatroom-override-gameHost-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     游戏主持人覆盖
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <input type="checkbox" id="chatroom-override-gameHost-enabled">
                         <label for="chatroom-override-gameHost-enabled">启用游戏主持人覆盖</label>

                         <label for="chatroom-override-gameHost-model-select" class="settings-label" style="margin-top:15px;">模型</label>
                         <select id="chatroom-override-gameHost-model-select" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>
                         <label for="chatroom-override-gameHost-response-schema-json" class="settings-label">Response Schema (JSON)</label>
                         <textarea id="chatroom-override-gameHost-response-schema-json" class="settings-textarea"></textarea>
                         <label for="chatroom-override-gameHost-response-schema-parser-js" class="settings-label">Response Schema Parser (JS)</label>
                         <textarea id="chatroom-override-gameHost-response-schema-parser-js" class="settings-textarea"></textarea>
                         <label for="chatroom-override-gameHost-tool-database-instruction" class="settings-label">数据库</label>
                         <textarea id="chatroom-override-gameHost-tool-database-instruction" class="settings-textarea"></textarea>
                         <label for="chatroom-override-gameHost-main-prompt" class="settings-label">主提示词</label>
                         <textarea id="chatroom-override-gameHost-main-prompt" class="settings-textarea"></textarea>
                     </div>
                 </div>
             </div>


             <div id="chatroom-override-writingMaster-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     写作大师覆盖
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <input type="checkbox" id="chatroom-override-writingMaster-enabled">
                         <label for="chatroom-override-writingMaster-enabled">启用写作大师覆盖</label>

                         <label for="chatroom-override-writingMaster-model-select" class="settings-label" style="margin-top:15px;">模型</label>
                         <select id="chatroom-override-writingMaster-model-select" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>
                         <label for="chatroom-override-writingMaster-response-schema-json" class="settings-label">Response Schema (JSON)</label>
                         <textarea id="chatroom-override-writingMaster-response-schema-json" class="settings-textarea"></textarea>
                         <label for="chatroom-override-writingMaster-response-schema-parser-js" class="settings-label">Response Schema Parser (JS)</label>
                         <textarea id="chatroom-override-writingMaster-response-schema-parser-js" class="settings-textarea"></textarea>
                         <label for="chatroom-override-writingMaster-tool-database-instruction" class="settings-label">数据库</label>
                         <textarea id="chatroom-override-writingMaster-tool-database-instruction" class="settings-textarea"></textarea>
                         <label for="chatroom-override-writingMaster-main-prompt" class="settings-label">主提示词</label>
                         <textarea id="chatroom-override-writingMaster-main-prompt" class="settings-textarea"></textarea>
                     </div>
                 </div>
             </div>


             <div id="chatroom-override-characterUpdateMaster-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     角色更新大师覆盖
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <input type="checkbox" id="chatroom-override-characterUpdateMaster-enabled">
                         <label for="chatroom-override-characterUpdateMaster-enabled">启用角色更新大师覆盖</label>

                         <label for="chatroom-override-characterUpdateMaster-model-select" class="settings-label" style="margin-top:15px;">模型</label>
                         <select id="chatroom-override-characterUpdateMaster-model-select" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>
                         <label for="chatroom-override-characterUpdateMaster-response-schema-json" class="settings-label">Response Schema (JSON)</label>
                         <textarea id="chatroom-override-characterUpdateMaster-response-schema-json" class="settings-textarea"></textarea>
                         <label for="chatroom-override-characterUpdateMaster-response-schema-parser-js" class="settings-label">Response Schema Parser (JS)</label>
                         <textarea id="chatroom-override-characterUpdateMaster-response-schema-parser-js" class="settings-textarea"></textarea>
                         <label for="chatroom-override-characterUpdateMaster-tool-database-instruction" class="settings-label">数据库</label>
                         <textarea id="chatroom-override-characterUpdateMaster-tool-database-instruction" class="settings-textarea"></textarea>
                         <label for="chatroom-override-characterUpdateMaster-main-prompt" class="settings-label">主提示词</label>
                         <textarea id="chatroom-override-characterUpdateMaster-main-prompt" class="settings-textarea"></textarea>
                     </div>
                 </div>
             </div>


             <div id="chatroom-override-privateAssistant-page" class="setting-page-template" style="flex-direction: column;">
                 <div class="settings-header">
                     私人助理覆盖
                     <div class="close-button std-button">✕</div>
                 </div>
                 <div class="settings-section">
                     <div class="settings-group">
                         <input type="checkbox" id="chatroom-override-privateAssistant-enabled">
                         <label for="chatroom-override-privateAssistant-enabled">启用私人助理覆盖</label>

                         <label for="chatroom-override-privateAssistant-model-select" class="settings-label" style="margin-top:15px;">模型</label>
                         <select id="chatroom-override-privateAssistant-model-select" class="settings-select" style="width: 100%;">
                             <option value="" disabled selected>请在 API 设置中拉取</option>
                         </select>
                         <label for="chatroom-override-privateAssistant-response-schema-json" class="settings-label">Response Schema (JSON)</label>
                         <textarea id="chatroom-override-privateAssistant-response-schema-json" class="settings-textarea"></textarea>
                         <label for="chatroom-override-privateAssistant-response-schema-parser-js" class="settings-label">Response Schema Parser (JS)</label>
                         <textarea id="chatroom-override-privateAssistant-response-schema-parser-js" class="settings-textarea"></textarea>
                         <label for="chatroom-override-privateAssistant-tool-database-instruction" class="settings-label">数据库</label>
                         <textarea id="chatroom-override-privateAssistant-tool-database-instruction" class="settings-textarea"></textarea>
                         <label for="chatroom-override-privateAssistant-main-prompt" class="settings-label">主提示词</label>
                         <textarea id="chatroom-override-privateAssistant-main-prompt" class="settings-textarea"></textarea>
                     </div>
                 </div>
             </div>


        </div>


        <div id="novel-interface">
            <div id="novel-interface-toolbar">
                 <div id="novel-toc-button" class="std-button">☰</div>
                 <div id="novel-bookshelf-button" class="std-button">📚</div>
            </div>


            <div id="novel-content-area">

            </div>


            <div id="novel-bookshelf-page">
                 <div class="novel-page-header">
                     书目
                     <div class="novel-close-button std-button">✕</div>
                 </div>
                 <div class="novel-page-section">
                    <div class="novel-page-group">
                        <div id="novel-bookshelf-list-container">

                        </div>
                    </div>
                 </div>
            </div>


            <div id="novel-toc-page">
                 <div class="novel-page-header">
                     目录
                     <div class="novel-close-button std-button">✕</div>
                 </div>
                 <div class="novel-page-section">
                    <div class="novel-page-group">
                        <div id="novel-toc-list-container">

                        </div>
                    </div>
                 </div>
            </div>
        </div>



        <div id="chat-area">

        </div>

        <div id="image-viewer-page">
             <img id="image-viewer-content" src="" alt="Image Viewer">
        </div>
    </div>


    <script src="core.js"></script>
    <script src="ui_elements.js"></script>
    <script src="ui_settings.js"></script>
    <script src="ui_chat.js"></script>
    <script src="main.js"></script>
</body>
</html>
```
--- END OF FILE gemini_chat.html ---


--- START OF FILE core.js ---
```javascript
const defaultConfig = {
    temperature: '1.0',
    topP: '0.9',
    topK: '40',
    maxOutputTokens: '2048',
    responseMimeType: 'application/json',
    promptPresetTurns: [],
    model: "",
    responseSchemaJson: "",
    responseSchemaParserJs: "",
    sharedDatabaseInstruction: "",
    mainPrompt: "",
    toolSettings: {
        drawingMaster: { responseSchemaJson: '', responseSchemaParserJs: '', toolDatabaseInstruction: '', enabled: false, model: '', mainPrompt: '', novelContent: '' },
        gameHost: { responseSchemaJson: '', responseSchemaParserJs: '', toolDatabaseInstruction: '', enabled: false, model: '', mainPrompt: '' },
        writingMaster: { responseSchemaJson: '', responseSchemaParserJs: '', toolDatabaseInstruction: '', enabled: false, model: '', mainPrompt: '' },
        characterUpdateMaster: { responseSchemaJson: '', responseSchemaParserJs: '', toolDatabaseInstruction: '', enabled: false, model: '', mainPrompt: '' },
        privateAssistant: { responseSchemaJson: '', responseSchemaParserJs: '', toolDatabaseInstruction: '', enabled: false, model: '', mainPrompt: '' },
    },
    activeChatRoomName: null,
    chatRoomOrder: [],
    isRunPaused: true,
    isRoleListVisible: false,
    lastViewedNovelId: null,
    originalNovelLength: 10000,
    novelaiModel: "nai-diffusion-3",
    novelaiArtistChain: "",
    novelaiDefaultPositivePrompt: "",
    novelaiDefaultNegativePrompt: "",
    novelaiWidth: 1024,
    novelaiHeight: 1024,
    novelaiSteps: 28,
    novelaiScale: 5.0,
    novelaiCfgRescale: 0.0,
    novelaiSampler: "k_euler",
    novelaiNoiseSchedule: "native",
    novelaiSeed: 0,
    systemInstruction: ""
};

const defaultChatroomOverrideSettings = {
    general: {
        enabled: false,
        model: "",
        responseSchemaJson: "",
        responseSchemaParserJs: "",
        sharedDatabaseInstruction: "",
        mainPrompt: ""
    },
    drawingMaster: {
        enabled: false,
        model: "",
        responseSchemaJson: "",
        responseSchemaParserJs: "",
        toolDatabaseInstruction: "",
        mainPrompt: "",
        novelContent: ""
    },
    gameHost: {
        enabled: false,
        model: "",
        responseSchemaJson: "",
        responseSchemaParserJs: "",
        toolDatabaseInstruction: "",
        mainPrompt: ""
    },
    writingMaster: {
        enabled: false,
        model: "",
        responseSchemaJson: "",
        responseSchemaParserJs: "",
        toolDatabaseInstruction: "",
        mainPrompt: ""
    },
    characterUpdateMaster: {
        enabled: false,
        model: "",
        responseSchemaJson: "",
        responseSchemaParserJs: "",
        toolDatabaseInstruction: "",
        mainPrompt: ""
    },
    privateAssistant: {
        enabled: false,
        model: "",
        responseSchemaJson: "",
        responseSchemaParserJs: "",
        toolDatabaseInstruction: "",
        mainPrompt: ""
    }
};

const stateModule = {
    config: JSON.parse(JSON.stringify(defaultConfig)),
    currentChatroomDetails: null,
    activeSettingPage: null,
    pageStack: [],
    activeMessageActions: null,
    editingMessageContainer: null,
    currentRole: null,
    activeRoleStateButtons: null,
    availableModels: [],
    chatContextCache: null,
    currentChatHistoryData: [],
    isNovelInterfaceVisible: false,
    activeNovelPage: null,
    novelPageStack: [],
    currentNovelId: null,
    currentTocIndexByNovel: {},
    isNovelLoading: false,
    scrollUpdateTimer: null,
    naiRequestQueue: [],
    isNaiProcessing: false,
    tempImageUrls: {},
    displayedImageCount: 0,
    displayedImageOrder: [],
    lastNaiPrompt: "",
    historySaveDebounceTimer: null,
    historySaveDebounceDelay: 2500,
    chatroomConfigSaveTimers: {},
    chatroomConfigSaveDelay: 1500,
    activeProxyRequestsCount: 0,
    isCooldownActive: false,
    cooldownTimer: null,
};
const API_KEYS_STORAGE_KEY = 'geminiChatApiKeys';
const NAI_API_KEY_STORAGE_KEY = 'geminiChatNaiApiKey';
const API_KEY_FAILURES_STORAGE_KEY = 'geminiChatApiKeyFailures';
const MAX_RETRIES = 5;
const REQUEST_TIMEOUT_MS = 60000;

const apiKeyManager = {
    _allKeys: [],
    _activeKeys: [],
    _silentKeys: [],
    _silentCapacity: 0,

    _getLocalStorageItem: (key) => {
        try {
            return localStorage.getItem(key);
        } catch (e) {
            _logAndDisplayError(`Failed to read from localStorage (key: ${key}): ${e.message}`, 'apiKeyManager');
            return null;
        }
    },
    _setLocalStorageItem: (key, value) => {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            _logAndDisplayError(`Failed to write to localStorage (key: ${key}): ${e.message}`, 'apiKeyManager');
        }
    },
    getApiKeys: () => {
        return [...apiKeyManager._allKeys];
    },
    setApiKeys: (keys) => {
        if (!Array.isArray(keys)) return;
        apiKeyManager._allKeys = [...keys];
        apiKeyManager._activeKeys = [...keys];
        apiKeyManager._silentKeys = [];
        apiKeyManager._silentCapacity = Math.floor(keys.length / 2);
        apiKeyManager._setLocalStorageItem(API_KEYS_STORAGE_KEY, JSON.stringify(keys));

        const currentFailures = apiKeyManager._getApiKeyFailures();
        const newFailures = {};
        keys.forEach(key => {
            newFailures[key] = currentFailures[key] || 0;
        });
        apiKeyManager._setApiKeyFailures(newFailures);
    },
    loadApiKeysFromStorage: () => {
        const keysJson = apiKeyManager._getLocalStorageItem(API_KEYS_STORAGE_KEY);
        let keys = [];
        try {
            keys = keysJson ? JSON.parse(keysJson) : [];
            if (!Array.isArray(keys)) keys = [];
        } catch (e) {
            keys = [];
        }
        apiKeyManager.setApiKeys(keys);
    },
    getNaiApiKey: () => {
        return apiKeyManager._getLocalStorageItem(NAI_API_KEY_STORAGE_KEY) || '';
    },
    setNaiApiKey: (key) => {
        apiKeyManager._setLocalStorageItem(NAI_API_KEY_STORAGE_KEY, key || '');
    },
    selectApiKey: () => {
        if (apiKeyManager._activeKeys.length === 0) {
            if (apiKeyManager._silentKeys.length === 0) {
                throw new Error("No API keys available in active or silent pool.");
            }
            apiKeyManager._activeKeys = apiKeyManager._silentKeys.map(item => item.key);
            apiKeyManager._silentKeys = [];
        }

        const failures = apiKeyManager._getApiKeyFailures();
        let minFailures = Infinity;
        let candidates = [];

        apiKeyManager._activeKeys.forEach(key => {
            const failCount = failures[key] || 0;
            if (failCount < minFailures) {
                minFailures = failCount;
                candidates = [key];
            } else if (failCount === minFailures) {
                candidates.push(key);
            }
        });

        if (candidates.length === 0) {
             if (apiKeyManager._activeKeys.length > 0) {
                 candidates = [...apiKeyManager._activeKeys];
             } else {
                 throw new Error("Could not select a candidate API key.");
             }
        }

        const randomIndex = Math.floor(Math.random() * candidates.length);
        return candidates[randomIndex];
    },
    markApiKeyUsed: (usedKey) => {
        const activeIndex = apiKeyManager._activeKeys.indexOf(usedKey);
        if (activeIndex !== -1) {
            apiKeyManager._activeKeys.splice(activeIndex, 1);
        }

        apiKeyManager._silentKeys = apiKeyManager._silentKeys.filter(item => item.key !== usedKey);
        apiKeyManager._silentKeys.push({ key: usedKey, timestamp: Date.now() });

        while (apiKeyManager._silentKeys.length > apiKeyManager._silentCapacity) {
            const oldestEntry = apiKeyManager._silentKeys.shift();
            if (oldestEntry) {
                 apiKeyManager._activeKeys.push(oldestEntry.key);
            }
        }
    },
    _getApiKeyFailures: () => {
        const failuresJson = apiKeyManager._getLocalStorageItem(API_KEY_FAILURES_STORAGE_KEY);
        try {
            const failures = failuresJson ? JSON.parse(failuresJson) : {};
            return typeof failures === 'object' && failures !== null ? failures : {};
        } catch (e) {
            return {};
        }
    },
    _setApiKeyFailures: (failures) => {
        if (typeof failures === 'object' && failures !== null) {
            apiKeyManager._setLocalStorageItem(API_KEY_FAILURES_STORAGE_KEY, JSON.stringify(failures));
        }
    },
    incrementApiKeyFailure: (apiKey) => {
        if (!apiKey) return;
        const failures = apiKeyManager._getApiKeyFailures();
        failures[apiKey] = (failures[apiKey] || 0) + 1;
        apiKeyManager._setApiKeyFailures(failures);
        if (typeof uiSettingsModule !== 'undefined' && uiSettingsModule.updateApiKeyFailureCountsDisplay) {
            uiSettingsModule.updateApiKeyFailureCountsDisplay();
        }
    },
    getApiKeyFailureCounts: () => {
        return apiKeyManager._getApiKeyFailures();
    }
};
const _logAndDisplayError = (message, source = 'UnknownSource', lineno = 'N/A', colno = 'N/A', errorObj = null) => {
    const timestamp = new Date().toLocaleString();
    let fullMessage = `[${source} @ ${timestamp}] ${message}`;
    if (lineno !== 'N/A') fullMessage += ` (Line: ${lineno}, Col: ${colno})`;
    console.error(fullMessage, errorObj);

    if (typeof elementsModule !== 'undefined' && elementsModule.errorLogDisplay) {
        const currentLog = elementsModule.errorLogDisplay.value;
        const separator = currentLog ? '\n------------------------------\n' : '';
        elementsModule.errorLogDisplay.value += separator + fullMessage;
        elementsModule.errorLogDisplay.scrollTop = elementsModule.errorLogDisplay.scrollHeight;
    }
};

window.onerror = (message, source, lineno, colno, error) => {
    _logAndDisplayError(message, source, lineno, colno, error);
    return true;
};
window.addEventListener('unhandledrejection', function(event) {
    const reason = event.reason;
    let message = 'Unhandled Promise Rejection';
    let source = 'Promise';
    let errorObj = reason;
    if (reason instanceof Error) {
        message = reason.message;
        source = reason.stack ? reason.stack.split('\n')[1] || source : source;
    } else if (typeof reason === 'string') {
        message = reason;
    } else {
        try { message = JSON.stringify(reason); } catch { message = 'Non-serializable reason'; }
    }
    _logAndDisplayError(message, source, 'N/A', 'N/A', errorObj);
});

const configModule = {
    autoSaveConfig: () => {
        const configToSave = { ...stateModule.config };
        delete configToSave.isRunPaused;
        delete configToSave.errorLogs;
        delete configToSave.availableChatrooms;
        delete configToSave.currentChatroomDetails;

        fetch('/autosave-config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(configToSave)
        }).then(response => {
             if (!response.ok) {
                 throw new Error(`HTTP error! status: ${response.status} for autosave`);
             }
         }).catch(error => {
             _logAndDisplayError(`Auto-save failed: ${error.message}`, 'autoSaveConfig');
         });
    },
    loadConfig: async () => {
        let loadedConfig;
        try {
            const response = await fetch('/load-config');
            if (response.ok) {
                 loadedConfig = await response.json();
                 if (!loadedConfig || typeof loadedConfig !== 'object') {
                     throw new Error("Loaded config is not a valid object.");
                 }
            } else {
                 throw new Error(`Failed to load config: ${response.status}. Using default.`);
            }
        } catch (error) {
             _logAndDisplayError(error.message, 'loadConfig');
             loadedConfig = JSON.parse(JSON.stringify(defaultConfig));
        }

        Object.keys(defaultConfig).forEach(key => {
             if (!(key in loadedConfig)) {
                 loadedConfig[key] = JSON.parse(JSON.stringify(defaultConfig[key]));
             } else if (key === 'toolSettings') {
                 Object.keys(defaultConfig.toolSettings).forEach(toolKey => {
                      if (!(toolKey in loadedConfig.toolSettings)) {
                          loadedConfig.toolSettings[toolKey] = JSON.parse(JSON.stringify(defaultConfig.toolSettings[toolKey]));
                      } else {
                          Object.keys(defaultConfig.toolSettings[toolKey]).forEach(subKey => {
                               if (!(subKey in loadedConfig.toolSettings[toolKey])) {
                                   loadedConfig.toolSettings[toolKey][subKey] = JSON.parse(JSON.stringify(defaultConfig.toolSettings[toolKey][subKey]));
                               }
                          });
                      }
                 });
             }
        });

        Object.assign(stateModule.config, loadedConfig);
        apiKeyManager.loadApiKeysFromStorage();
        stateModule.config.isRunPaused = true;
        stateModule.currentChatroomDetails = null;
        if (stateModule.config.activeChatRoomName) {
             await apiModule.fetchChatroomDetails(stateModule.config.activeChatRoomName);
        } else {
             updateChatContextCache();
        }
    }
};

const toolNameMap = {
    drawingMaster: "绘图大师",
    gameHost: "游戏主持人",
    writingMaster: "写作大师",
    characterUpdateMaster: "角色更新大师",
    privateAssistant: "私人助理"
};
function _formatObjectToCustomString(obj, indentLevel = 0) {
    let result = '';
    const indent = '  '.repeat(indentLevel);
    if (obj === null || obj === undefined) return 'null';
    if (typeof obj !== 'object') return String(obj);
    if (Array.isArray(obj)) {
        return '[Internal Error: Array passed directly]';
    }
    const keys = Object.keys(obj);
    keys.forEach((key) => {
        const value = obj[key];
        if (result !== '') result += '\n';
        result += `${indent}${key}`;
        if (Array.isArray(value)) {
            if (value.length > 0) {
                if (value.every(item => typeof item !== 'object' || item === null)) {
                    value.forEach(item => {
                        result += `\n${indent}  - ${item}`;
                    });
                } else {
                    value.forEach(item => {
                        if (typeof item === 'object' && item !== null) {
                            const nestedObjectString = _formatObjectToCustomString(item, indentLevel + 1);
                            result += `\n${nestedObjectString}`;
                        } else {
                            result += `\n${indent}  - ${item}`;
                        }
                    });
                }
            }
        } else if (typeof value === 'object' && value !== null) {
            const nestedString = _formatObjectToCustomString(value, indentLevel + 1);
            result += `\n${nestedString}`;
        } else {
            result += `: ${value}`;
        }
    });
    return result;
}

function getOriginalNovelTextForPayload() {
    const chatroomDetails = stateModule.currentChatroomDetails;
    if (!chatroomDetails || !chatroomDetails.config) return "[无激活聊天室数据]";
    const activeNovelIds = chatroomDetails.config.activeNovelIds || [];
    const novelDefs = chatroomDetails.novels || [];
    const novelCurrentSegmentIds = chatroomDetails.config.novelCurrentSegmentIds || {};
    if (activeNovelIds.length === 0) return "[当前聊天室无激活小说]";
    const totalTargetChars = stateModule.config.originalNovelLength || defaultConfig.originalNovelLength;
    const perNovelChars = activeNovelIds.length > 0 ? Math.floor(totalTargetChars / activeNovelIds.length) : 0;
    if (perNovelChars <= 0) return "[字符分配不足]";
    const textSnippets = [];
    let missingContentNovels = [];
    for (const novelId of activeNovelIds) {
        const novelData = novelDefs.find(n => n.id === novelId);
        const novelName = novelData?.name || `小说 ${novelId.substring(0, 4)}`;
        if (!novelData || !novelData.segments || novelData.segments.length === 0) {
            missingContentNovels.push(novelName);
            continue;
        }
        const segments = novelData.segments;
        const numSegments = segments.length;
        let currentSegmentId = parseInt(novelCurrentSegmentIds[novelId], 10);
        if (isNaN(currentSegmentId) || currentSegmentId < 0 || currentSegmentId >= numSegments) {
            currentSegmentId = 0;
        }
        let charsCollected = 0;
        let currentSnippetSegments = [];
        const avgSegmentLength = segments.reduce((sum, seg) => sum + (seg.content ? seg.content.length : 0), 0) / numSegments || 200;
        const targetSegmentCount = Math.max(1, Math.ceil(perNovelChars / avgSegmentLength));
        const segmentsBefore = Math.floor(targetSegmentCount / 5);
        const segmentsAfter = targetSegmentCount - segmentsBefore -1;
        let startIdx = Math.max(0, currentSegmentId - segmentsBefore);
        let endIdx = Math.min(numSegments - 1, currentSegmentId + segmentsAfter);
        for (let i = startIdx; i <= endIdx; i++) {
             const segment = segments[i];
             if (segment && segment.content) {
                 currentSnippetSegments.push(segment.content);
                 charsCollected += segment.content.length;
             }
        }
        while (charsCollected < perNovelChars && (startIdx > 0 || endIdx < numSegments - 1)) {
             let added = false;
             if (startIdx > 0) {
                 startIdx--;
                 const segment = segments[startIdx];
                 if (segment && segment.content) {
                     currentSnippetSegments.unshift(segment.content);
                     charsCollected += segment.content.length;
                     added = true;
                 }
             }
             if (charsCollected < perNovelChars && endIdx < numSegments - 1) {
                 endIdx++;
                 const segment = segments[endIdx];
                  if (segment && segment.content) {
                     currentSnippetSegments.push(segment.content);
                     charsCollected += segment.content.length;
                     added = true;
                 }
             }
             if (!added) break;
        }
        let snippetText = currentSnippetSegments.join('\n');
        if (snippetText) {
             textSnippets.push(`--- ${novelName} (片段开始) ---\n${snippetText}\n--- ${novelName} (片段结束) ---`);
        }
    }
    if (missingContentNovels.length > 0) {
        const missingWarning = `\n\n[警告：以下激活小说内容未加载，无法包含：${missingContentNovels.join(', ')}]`;
        return textSnippets.join('\n\n') + missingWarning;
    } else if (textSnippets.length === 0) {
         return "[无法生成小说原著小说，请检查激活状态和内容加载情况]";
    }
    return textSnippets.join('\n\n');
}
const placeholderModule = {
    _replacePlaceholdersInString: (text, context, excludePlaceholders = []) => {
        if (typeof text !== 'string') return text;

        const localExcludePlaceholders = [...excludePlaceholders];

        function wrapWithTag(tagName, content) {
            const safeContent = content || '';
            return `<${tagName}>\n${tagName}:\n${safeContent}\n</${tagName}>`;
        }
        function wrapWithDynamicTag(tagName, roleName, content) {
            const safeContent = content || '';
            const dynamicTagName = `${roleName}_${tagName}`;
            return `<${dynamicTagName}>\n${dynamicTagName}:\n${safeContent}\n</${dynamicTagName}>`;
        }

        const cachedContext = context?.cachedContext;
        if (!cachedContext) return text;

        let novelOriginalNovel = "[原著小说未生成]";
        if (!localExcludePlaceholders.includes('{{原著小说}}') && text.includes('{{原著小说}}')) {
            if (context?.currentRoleNameForPayload === 'drawingMaster') {
                const details = stateModule.currentChatroomDetails;
                const globalConfig = stateModule.config.toolSettings.drawingMaster;
                let overrideEnabled = false;
                let overrideContent = '';
                if (details && details.config && details.config.overrideSettings && details.config.overrideSettings.drawingMaster) {
                    const overrideSettings = details.config.overrideSettings.drawingMaster;
                    if (overrideSettings.enabled) {
                        overrideEnabled = true;
                        overrideContent = overrideSettings.novelContent || '';
                    }
                }
                if (overrideEnabled) {
                    novelOriginalNovel = overrideContent || '[绘图大师原著小说(覆盖)为空]';
                } else {
                    novelOriginalNovel = globalConfig?.novelContent || '[绘图大师原著小说(全局)为空]';
                }
            } else {
                novelOriginalNovel = getOriginalNovelTextForPayload();
            }
        }

        let rawMainPromptText = context.mainPrompt || '[主提示词为空]';
        let processedMainPromptText = rawMainPromptText;
        if (!localExcludePlaceholders.includes('{{主提示词}}') && text.includes('{{主提示词}}')) {
            processedMainPromptText = placeholderModule._replacePlaceholdersInString(
                rawMainPromptText,
                context,
                [...localExcludePlaceholders, '{{数据库}}', '{{主提示词}}']
            );
        }

        let roleplayRuleText = stateModule.currentChatroomDetails?.config?.roleplayRules || '[扮演规则为空]';
        let publicInfoText = stateModule.currentChatroomDetails?.config?.publicInfo || '[公共信息为空]';
        let userValue = stateModule.currentChatroomDetails?.config?.user || '[user未设置]';
        let latestMessageContentText = cachedContext?.latestMessageContent || '[无最新消息]';
        let roleSettingValue = '[未设定]';
        let roleMemoryValue = '[未设定]';
        let currentRoleDetailedStateValue = '[无详细状态]';
        let roleNameValue = context.currentRoleNameForPayload || '[未知角色]';
        const isCharacterUpdater = context.roleType === 'tool' && context.currentRoleNameForPayload === 'characterUpdateMaster';
        const targetRoleNameValue = context.targetRoleNameForTool || '[无目标角色]';
        const targetRoleData = context.targetRoleData;
        const currentRoleData = context.roleData;
        if (isCharacterUpdater) {
            roleNameValue = toolNameMap['characterUpdateMaster'];
            if (targetRoleNameValue !== '[无目标角色]' && targetRoleData) {
                roleSettingValue = targetRoleData.setting || `[${targetRoleNameValue} 设定未获取]`;
                roleMemoryValue = targetRoleData.memory || `[${targetRoleNameValue} 记忆未获取]`;
                currentRoleDetailedStateValue = cachedContext?.roleDetailedStates?.[targetRoleNameValue] || `[${targetRoleNameValue} 无详细状态]`;
            } else {
                roleSettingValue = '[无目标角色设定]';
                roleMemoryValue = '[无目标角色记忆]';
                currentRoleDetailedStateValue = '[无目标角色详细状态]';
            }
        } else if (context.roleType === 'tool') {
            roleNameValue = toolNameMap[context.currentRoleNameForPayload] || context.currentRoleNameForPayload;
            roleSettingValue = '[工具无设定]';
            roleMemoryValue = '[工具无记忆]';
            currentRoleDetailedStateValue = cachedContext?.roleDetailedStates?.[context.currentRoleNameForPayload] || '[工具无详细状态]';
        } else {
            if (currentRoleData) {
                 roleSettingValue = currentRoleData.setting || '[设定未获取]';
                 roleMemoryValue = currentRoleData.memory || '[记忆未获取]';
                 currentRoleDetailedStateValue = cachedContext?.roleDetailedStates?.[context.currentRoleNameForPayload] || `[${context.currentRoleNameForPayload} 无详细状态]`;
                 roleNameValue = context.currentRoleNameForPayload;
            } else {
                 currentRoleDetailedStateValue = cachedContext?.roleDetailedStates?.[context.currentRoleNameForPayload] || `[${context.currentRoleNameForPayload} 无详细状态]`;
                 roleNameValue = context.currentRoleNameForPayload;
                 roleSettingValue = '[临时角色无设定]';
                 roleMemoryValue = '[临时角色无记忆]';
            }
        }
        let rawFormattedHistory = cachedContext?.formattedHistory || '';
        const rawNonSilentRoleSettingsValue = cachedContext?.nonSilentRoleSettingsValue;
        const rawNonSilentRoleDetailedStatesValue = cachedContext?.nonSilentRoleDetailedStatesValue;
        const wrappedOriginalNovel = wrapWithTag('OriginalNovel', novelOriginalNovel);
        const wrappedRoleplayRule = wrapWithTag('RoleplayRules', roleplayRuleText);
        const wrappedPublicInfo = wrapWithTag('PublicInfo', publicInfoText);
        const wrappedMainPrompt = wrapWithTag('MainPrompt', processedMainPromptText);
        const wrappedLatestMessage = wrapWithTag('LatestMessage', latestMessageContentText);
        const wrappedHistory = wrapWithTag('History', rawFormattedHistory);
        const wrappedSettingsCollection = wrapWithTag('CharacterSettingsCollection', rawNonSilentRoleSettingsValue);
        const wrappedStatesCollection = wrapWithTag('CharacterStatesCollection', rawNonSilentRoleDetailedStatesValue);
        const wrappedWorldInfo = wrapWithTag('WorldInfo', cachedContext?.worldInfo || '[世界信息未获取]');
        const triggeringCharacterNameValue = context?.triggeringCharacterName || '[触发绘图的角色未知]';

        const replacements = {
            '{{角色名称}}': roleNameValue,
            '{{目标角色名称}}': targetRoleNameValue,
            '{{角色名称集}}': cachedContext?.nonSilentRolesValue || '[无激活角色]',
            '{{最新角色}}': cachedContext?.lastActor || '[最近行动者未知]',
            '{{角色设定}}': wrapWithDynamicTag('Setting', roleNameValue, roleSettingValue),
            '{{角色记忆}}': wrapWithDynamicTag('Memory', roleNameValue, roleMemoryValue),
            '{{角色状态}}': wrapWithDynamicTag('State', roleNameValue, currentRoleDetailedStateValue),
            '{{消息记录}}': wrappedHistory,
            '{{最新消息}}': wrappedLatestMessage,
            '{{角色设定集}}': wrappedSettingsCollection,
            '{{角色状态集}}': wrappedStatesCollection,
            '{{世界信息}}': wrappedWorldInfo,
            '{{原著小说}}': wrappedOriginalNovel,
            '{{扮演规则}}': wrappedRoleplayRule,
            '{{公共信息}}': wrappedPublicInfo,
            '{{主提示词}}': wrappedMainPrompt,
            '{{绘图角色}}': triggeringCharacterNameValue,
            '{{user}}': userValue,
        };

        let replacedString = text;
        for (const placeholder in replacements) {
             if (localExcludePlaceholders.includes(placeholder)) continue;
             if (placeholder === '{{数据库}}') continue;
            const replacementValue = replacements[placeholder];
             const regex = new RegExp(placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
            replacedString = replacedString.replace(regex, replacementValue);
        }
        return replacedString;
    },

    replacePlaceholders: async (payload, context) => {
        if (!context || !context.cachedContext) {
            _logAndDisplayError("Placeholder replacement error: Context or cachedContext is missing.", "replacePlaceholders");
            return payload;
        }
        const databaseInstruction = context.databaseInstruction || "";

        const resolvedDatabaseContent = placeholderModule._replacePlaceholdersInString(
            databaseInstruction,
            context,
            ['{{数据库}}', '{{主提示词}}']
        );

        let finalDatabaseReplacement = "";
        if (resolvedDatabaseContent && resolvedDatabaseContent.trim() !== "") {
            finalDatabaseReplacement = `<Database>\n${resolvedDatabaseContent}\n</Database>`;
        }

        function recursiveReplace(obj) {
            if (typeof obj === 'string') {
                let replacedString = obj;
                if (replacedString.includes('{{数据库}}')) {
                     const dbRegex = new RegExp('{{数据库}}'.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
                     replacedString = replacedString.replace(dbRegex, finalDatabaseReplacement);
                }

                replacedString = placeholderModule._replacePlaceholdersInString(
                    replacedString,
                    context,
                    ['{{数据库}}']
                );
                return replacedString;
            } else if (typeof obj === 'object' && obj !== null) {
                if (Array.isArray(obj)) {
                    return obj.map(item => recursiveReplace(item));
                } else {
                    const newObj = {};
                    for (const key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            newObj[key] = recursiveReplace(obj[key]);
                        }
                    }
                    return newObj;
                }
            }
            return obj;
        }
        const finalPayload = recursiveReplace(payload);
        return finalPayload;
    }
};

async function updateChatContextCache() {
    const newCache = {
        roleStates: {},
        roleDetailedStates: {},
        worldInfo: '[世界信息未获取]',
        lastActor: '[最近行动者未知]',
        nonSilentRolesValue: '[无激活角色]',
        nonSilentRoleSettingsValue: '[无激活角色设定]',
        nonSilentRoleDetailedStatesValue: '[无激活角色详细状态]',
        formattedHistory: '',
        latestMessageContent: '[无消息记录]',
    };
    const chatroomDetails = stateModule.currentChatroomDetails;
    if (!chatroomDetails || !chatroomDetails.config || !chatroomDetails.roles) {
        stateModule.chatContextCache = newCache;
        if (typeof uiSettingsModule !== 'undefined') uiSettingsModule.updateWorldInfoDisplay();
        return;
    }
    const roomConfig = chatroomDetails.config;
    const allRolesInRoom = chatroomDetails.roles;
    const roleStatesConfig = roomConfig.roleStates || {};
    const roleDetailedStatesConfig = roomConfig.roleDetailedStates || {};
    for (const roleName in roleStatesConfig) {
        newCache.roleStates[roleName] = roleStatesConfig[roleName] || uiChatModule.ROLE_STATE_DEFAULT;
    }
    for (const roleName in roleDetailedStatesConfig) {
        newCache.roleDetailedStates[roleName] = roleDetailedStatesConfig[roleName] || "";
    }
    const currentHistory = stateModule.currentChatHistoryData;
    if (!currentHistory || currentHistory.length === 0) {
        stateModule.chatContextCache = newCache;
        if (typeof uiSettingsModule !== 'undefined') uiSettingsModule.updateWorldInfoDisplay();
        return;
    }
    const historyLines = [];
    let latestGameHostMessageData = null;
    let lastActorFound = false;
    let lastMessageProcessedForCache = false;
    for (let i = currentHistory.length - 1; i >= 0; i--) {
        const messageObject = currentHistory[i];
        const { id, roleName, roleType, sourceType, speechActionText, rawJson, parsedResult } = messageObject;
        let displayContent = speechActionText || '';
        if (roleName === 'characterUpdateMaster' && parsedResult?.formattedUpdate) {
             displayContent = parsedResult.formattedUpdate;
        } else if (roleName === 'privateAssistant' && parsedResult?.responseContent) {
             displayContent = `私人助理：\n${parsedResult.responseContent}`;
        } else if ((roleType === 'role' || roleType === 'temporary_role') && parsedResult?.formattedText) {
             displayContent = parsedResult.formattedText;
        }
        if (!lastMessageProcessedForCache && displayContent && displayContent.trim() !== '' && displayContent !== "[Generating Image]" && displayContent !== "[图片绘制]") {
            newCache.latestMessageContent = displayContent;
            lastMessageProcessedForCache = true;
        }
        if (!lastActorFound && (roleType === 'role' || roleType === 'temporary_role')) {
            newCache.lastActor = roleName;
            lastActorFound = true;
        }
        if (roleType === 'role' || roleType === 'temporary_role') {
             const trimmedText = (displayContent || '').trim();
            if (trimmedText && trimmedText !== "[Generating Image]" && trimmedText !== "[图片绘制]") {
                historyLines.unshift(`${roleName}：\n${trimmedText}`);
            }
        } else if (roleType === 'tool' && roleName === 'privateAssistant' && parsedResult?.responseContent) {
             const trimmedText = (displayContent || '').trim();
             if (trimmedText) {
                  historyLines.unshift(trimmedText);
             }
        }
        if (roleName === 'gameHost' && sourceType === 'ai') {
            if (parsedResult && !messageObject.parserError && parsedResult.processedSceneContext && parsedResult.processedCharacterInfo) {
                if (!latestGameHostMessageData) {
                     latestGameHostMessageData = parsedResult;
                     let sceneText = '';
                     const sceneContext = parsedResult.processedSceneContext;
                     if (sceneContext.timeItems && sceneContext.timeItems.length > 0) {
                         sceneText += `Time: ${sceneContext.timeItems.join(', ')}\n`;
                     } else {
                         sceneText += `Time: [Not specified]\n`;
                     }
                     if (sceneContext.locationItems && sceneContext.locationItems.length > 0) {
                         sceneText += `Location: ${sceneContext.locationItems.join(', ')}\n`;
                     } else {
                         sceneText += `Location: [Not specified]\n`;
                     }
                     if (sceneContext.characterPositionItems && sceneContext.characterPositionItems.length > 0) {
                         sceneText += `Positions:\n  ${sceneContext.characterPositionItems.join('\n  ')}\n`;
                     }
                     if (sceneContext.otherSceneInfoItems && sceneContext.otherSceneInfoItems.length > 0) {
                         sceneText += `Other: ${sceneContext.otherSceneInfoItems.join(', ')}`;
                     }
                     newCache.worldInfo = sceneText.trim();
                 }
                 const charName = parsedResult.processedCharacterInfo.characterName;
                 if (charName) {
                      let charDetailText = '';
                      const charInfo = parsedResult.processedCharacterInfo;

                      const formatItemsToText = (items) => Array.isArray(items) ? items.join(', ') : (items || '无');
                      charDetailText += `Demeanor: ${formatItemsToText(charInfo.demeanorItems)}\n`;
                      charDetailText += `Outerwear: ${formatItemsToText(charInfo.outerwearItems)}\n`;
                      charDetailText += `Underwear: ${formatItemsToText(charInfo.underwearItems)}\n`;
                      charDetailText += `Accessories: ${formatItemsToText(charInfo.accessories)}\n`;
                      charDetailText += `Short Status: ${formatItemsToText(charInfo.shortTermStatusItems)}\n`;
                      charDetailText += `Long Status: ${formatItemsToText(charInfo.longTermStatusItems)}\n`;
                      charDetailText += `Pose: ${formatItemsToText(charInfo.actionPoseItems)}\n`;
                      charDetailText += `Action: ${formatItemsToText(charInfo.currentActionItems)}\n`;
                      charDetailText += `Other Status: ${formatItemsToText(charInfo.otherCharacterStatusItems)}`;

                      newCache.roleDetailedStates[charName] = charDetailText.trim();
                      if (!(charName in newCache.roleStates)) {
                           newCache.roleStates[charName] = uiChatModule.ROLE_STATE_DEFAULT;
                      }
                 }
            } else if (messageObject.parserError && !latestGameHostMessageData) {
                newCache.worldInfo = `[游戏主持人响应解析错误: ${messageObject.parserError}]`;
            } else if (!latestGameHostMessageData) {
                 newCache.worldInfo = `[游戏主持人响应 ${id} 的解析结果无效]`;
            }
        } else if (roleName === 'characterUpdateMaster' && sourceType === 'ai' && parsedResult?.formattedUpdate && !messageObject.parserError) {
             const targetRoleName = messageObject.targetRoleName;
             const characterNameMatch = parsedResult.formattedUpdate.match(/--- 更新后记忆 \((.*?)\) ---/);
             const characterName = characterNameMatch ? characterNameMatch[1] : null;
             if (targetRoleName && characterName && targetRoleName === characterName) {
                  newCache.roleDetailedStates[targetRoleName] = parsedResult.formattedUpdate;
             } else if (characterName) {
                  newCache.roleDetailedStates[characterName] = parsedResult.formattedUpdate;
             }
        }
    }

    newCache.formattedHistory = historyLines.join('\n---\n');

    const nonSilentRoleNames = Object.entries(newCache.roleStates)
        .filter(([name, state]) => [uiChatModule.ROLE_STATE_ACTIVE, uiChatModule.ROLE_STATE_USER_CONTROL].includes(state || uiChatModule.ROLE_STATE_DEFAULT))
        .map(([name, state]) => name);
    newCache.nonSilentRolesValue = nonSilentRoleNames.join(',') || '[无激活角色]';
    newCache.nonSilentRoleSettingsValue = nonSilentRoleNames.map(rName => {
        const roleData = allRolesInRoom.find(r => r.name === rName);
        const settingContent = roleData?.setting || `[${rName} 设定未获取或为临时角色]`;
        const tagName = `${rName}_Setting`;
        return `<${tagName}>\n${tagName}:\n${settingContent}\n</${tagName}>`;
    }).join('\n---\n') || '[无激活角色设定]';
    newCache.nonSilentRoleDetailedStatesValue = nonSilentRoleNames.map(rName => {
        const stateContent = newCache.roleDetailedStates[rName] || `[${rName} 无详细状态]`;
        const tagName = `${rName}_State`;
        return `<${tagName}>\n${tagName}:\n${stateContent}\n</${tagName}>`;
    }).join('\n---\n') || '[无激活角色详细状态]';

    stateModule.chatContextCache = newCache;
    if (typeof uiSettingsModule !== 'undefined') uiSettingsModule.updateWorldInfoDisplay();
}

const _prepareRoleOrToolContext = async (roleName, roleType, targetRoleNameForTool = null, triggeringCharacterName = null) => {
    const chatroomDetails = stateModule.currentChatroomDetails;
    let modelToUse = '';
    let specificResponseSchema = null;
    let specificResponseSchemaParserJs = '';
    let databaseInstruction = '';
    let mainPrompt = '';
    let roleData = null;
    let targetRoleData = null;

    if (!stateModule.chatContextCache) {
        await updateChatContextCache();
        if (!stateModule.chatContextCache) {
             _logAndDisplayError("无法准备 API 请求：上下文缓存为空。", '_prepareRoleOrToolContext');
             return null;
        }
    }

    const overrideSettings = chatroomDetails?.config?.overrideSettings;
    let useOverride = false;
    let overrideSection = null;
    let sectionType = null;

    if (roleType === 'role' || roleType === 'temporary_role') {
        sectionType = 'general';
        if (overrideSettings && overrideSettings.general && overrideSettings.general.enabled) {
            useOverride = true;
            overrideSection = overrideSettings.general;
        }
        modelToUse = stateModule.config.model;
        databaseInstruction = stateModule.config.sharedDatabaseInstruction || '';
        specificResponseSchema = stateModule.config.responseSchemaJson || null;
        specificResponseSchemaParserJs = stateModule.config.responseSchemaParserJs || '';
        mainPrompt = stateModule.config.mainPrompt || '';

        if (chatroomDetails) {
            roleData = chatroomDetails.roles.find(r => r.name === roleName);
        }
    } else if (roleType === 'tool') {
        sectionType = roleName;
        const toolSettings = stateModule.config.toolSettings[roleName];
        if (!toolSettings || !toolSettings.enabled) {
            return null;
        }

        if (overrideSettings && overrideSettings[roleName] && overrideSettings[roleName].enabled) {
            useOverride = true;
            overrideSection = overrideSettings[roleName];
        }

        modelToUse = toolSettings.model;
        databaseInstruction = toolSettings.toolDatabaseInstruction || '';
        specificResponseSchema = toolSettings.responseSchemaJson || null;
        specificResponseSchemaParserJs = toolSettings.responseSchemaParserJs || '';
        mainPrompt = toolSettings.mainPrompt || '';

        if (targetRoleNameForTool) {
             if (!chatroomDetails) {
                 _logAndDisplayError(`无法准备工具目标角色 ${targetRoleNameForTool} 的数据：无激活聊天室数据。`, '_prepareRoleOrToolContext');
                 return null;
             }
             targetRoleData = chatroomDetails.roles.find(r => r.name === targetRoleNameForTool);
             if (!targetRoleData) {
                 _logAndDisplayError(`无法找到工具 ${roleName} 的目标角色 ${targetRoleNameForTool} 的定义数据。`, '_prepareRoleOrToolContext');
             }
        }
    } else {
        throw new Error(`未知的 roleType: ${roleType} for ${roleName}`);
    }

    if (useOverride && overrideSection) {
        modelToUse = overrideSection.model || modelToUse;
        specificResponseSchema = overrideSection.responseSchemaJson || specificResponseSchema;
        specificResponseSchemaParserJs = overrideSection.responseSchemaParserJs || specificResponseSchemaParserJs;
        databaseInstruction = overrideSection.toolDatabaseInstruction || overrideSection.sharedDatabaseInstruction || databaseInstruction;
        mainPrompt = overrideSection.mainPrompt || mainPrompt;
    }

    if (!modelToUse) {
         const sourceMsg = useOverride ? `聊天室覆盖配置 (${sectionType})` : (roleType === 'tool' ? `工具 ${toolNameMap[roleName]}` : '通用配置');
         throw new Error(`请在 ${sourceMsg} 中选择一个模型。`);
    }

    const context = {
        modelName: modelToUse,
        systemInstruction: stateModule.config.systemInstruction || '',
        responseSchema: specificResponseSchema,
        responseSchemaParserJs: specificResponseSchemaParserJs,
        responseMimeType: stateModule.config.responseMimeType,
        temperature: stateModule.config.temperature,
        topP: stateModule.config.topP,
        topK: stateModule.config.topK,
        maxOutputTokens: stateModule.config.maxOutputTokens,
        currentRoleNameForPayload: roleName,
        targetRoleNameForTool: targetRoleNameForTool,
        promptPresetTurns: JSON.parse(JSON.stringify(stateModule.config.promptPresetTurns || [])),
        roleType: roleType,
        databaseInstruction: databaseInstruction,
        mainPrompt: mainPrompt,
        roleData: roleData,
        targetRoleData: targetRoleData,
        cachedContext: stateModule.chatContextCache
    };
    if (triggeringCharacterName) {
        context.triggeringCharacterName = triggeringCharacterName;
    }
    return context;
};

const _buildApiPayload = async (context) => {
    const basePayload = {
        model: context.modelName,
        generationConfig: {
            temperature: parseFloat(context.temperature) || 1.0,
            topP: parseFloat(context.topP) || 0.9,
            topK: parseInt(context.topK) || 40,
            maxOutputTokens: parseInt(context.maxOutputTokens) || 2048,
            responseMimeType: context.responseMimeType || 'application/json',
        },
        safetySettings: [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "OFF"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "OFF"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "OFF"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "OFF"},
        ]
    };

    const systemInstructionText = context.systemInstruction || '';
    basePayload.systemInstruction = systemInstructionText;

    if (context.responseSchema) {
        let schemaObj = context.responseSchema;
        if (typeof schemaObj === 'string' && schemaObj.trim().startsWith('{')) {
             try { schemaObj = JSON.parse(schemaObj); } catch(e) { schemaObj = null; _logAndDisplayError(`Invalid JSON in responseSchema for ${context.currentRoleNameForPayload}: ${e.message}`, '_buildApiPayload'); }
        }
        if (typeof schemaObj === 'object' && schemaObj !== null) {
            basePayload.generationConfig.responseSchema = schemaObj;
        }
    }

    basePayload.contents = (context.promptPresetTurns || []).map(turn => ({
         role: turn.role,
         parts: [{ text: turn.instruction || "" }]
    }));
    if (context.targetRoleNameForTool) {
        basePayload.targetRoleNameForTool = context.targetRoleNameForTool;
    }
    if (context.triggeringCharacterName) {
         basePayload.triggeringCharacterName = context.triggeringCharacterName;
    }

    const finalPayload = await placeholderModule.replacePlaceholders(
        basePayload,
        context
    );

    if (finalPayload.systemInstruction && typeof finalPayload.systemInstruction === 'string') {
         finalPayload.systemInstruction = {"parts": [{"text": finalPayload.systemInstruction}]};
    } else if (!finalPayload.systemInstruction) {
         delete finalPayload.systemInstruction;
    }

    if (!finalPayload.contents || finalPayload.contents.length === 0) {
         finalPayload.contents = [{ role: "user", parts: [{ text: "Continue" }] }];
    }
    return finalPayload;
};

const _performApiCall = async (apiKey, payload, roleName, targetRoleNameForTool = null, timeoutMs = REQUEST_TIMEOUT_MS) => {
    const requestPayload = { ...payload, apiKey: apiKey };
    const abortController = new AbortController();
    const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);
    let result = null;
    stateModule.activeProxyRequestsCount++;
    if (stateModule.activeProxyRequestsCount === 1 && typeof uiChatModule !== 'undefined') {
        uiChatModule.showLoadingSpinner();
    }
    try {
        const response = await fetch('/ai-proxy', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestPayload),
            signal: abortController.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
            const errorText = await response.text();
            let detail = errorText;
             try {
                 const errorJson = JSON.parse(errorText);
                 detail = errorJson?.error?.message || errorText;
             } catch(e){}
             result = { success: false, errorType: 'apiError', detail: `API Error! Status: ${response.status}, Details: ${detail}` };
        } else {
            const data = await response.json();
            result = { success: true, data: data };
        }
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            result = { success: false, errorType: 'timeout', detail: 'Request timed out' };
        } else {
            result = { success: false, errorType: 'fetchError', detail: `Network request failed: ${error.message}` };
        }
    } finally {
        stateModule.activeProxyRequestsCount--;
        if (stateModule.activeProxyRequestsCount === 0 && typeof uiChatModule !== 'undefined') {
            uiChatModule.hideLoadingSpinner();
        }
    }
    return result;
};
const apiModule = {
    _sendGeminiRequestWithRetry: async (roleName, roleType, targetRoleNameForTool = null, triggeringCharacterName = null) => {
        let lastError = null;
        let context = null;
        let finalPayload = null;
        let apiKeyUsed = null;

        try {
            context = await _prepareRoleOrToolContext(roleName, roleType, targetRoleNameForTool, triggeringCharacterName);
            if (!context) {
                if (roleType === 'tool' && !stateModule.config.toolSettings[roleName]?.enabled) {
                     return;
                }
                throw new Error(`Could not prepare context for ${roleName} (maybe disabled or misconfigured)`);
            }
            finalPayload = await _buildApiPayload(context);
            if (!finalPayload) {
                throw new Error("Failed to build final API Payload.");
            }
        } catch (e) {
            _logAndDisplayError(`Error preparing context or payload for ${roleName}: ${e.message}`, '_sendGeminiRequestWithRetry');
            return;
        }

        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            if (stateModule.config.isRunPaused && (context.roleType === 'role' || context.roleType === 'temporary_role')) {
                lastError = new Error(`Request aborted for role '${roleName}' (Attempt ${attempt}/${MAX_RETRIES}) due to pause state`);
                _logAndDisplayError(`Retry aborted for role '${roleName}' (Attempt ${attempt}/${MAX_RETRIES}) because run is paused.`, '_sendGeminiRequestWithRetry');
                break;
            }

            try {
                apiKeyUsed = apiKeyManager.selectApiKey();
            } catch(e) {
                lastError = e;
                break;
            }

            if (!apiKeyUsed) {
                 lastError = new Error("Failed to select an API key.");
                 break;
            }

            const result = await _performApiCall(apiKeyUsed, finalPayload, roleName, targetRoleNameForTool);
            apiKeyManager.markApiKeyUsed(apiKeyUsed);

            if (!result.success) {
                lastError = new Error(`${result.errorType}: ${result.detail}`);
                apiKeyManager.incrementApiKeyFailure(apiKeyUsed);
                if (typeof uiChatModule !== 'undefined' && uiChatModule.showRetryIndicator) {
                     uiChatModule.showRetryIndicator();
                }
                if (attempt === MAX_RETRIES) break; else continue;
            }

            if (!result.data || typeof result.data.text_content !== 'string') {
                lastError = new Error('API response missing text_content');
                apiKeyManager.incrementApiKeyFailure(apiKeyUsed);
                if (typeof uiChatModule !== 'undefined' && uiChatModule.showRetryIndicator) {
                     uiChatModule.showRetryIndicator();
                }
                 if (attempt === MAX_RETRIES) break; else continue;
            }

            const { parsedResult, parserError } = uiChatModule._parseAIResponse(result.data.text_content, roleName, roleType, context.responseSchemaParserJs);
             if (parserError && (roleName === 'privateAssistant' || roleName === 'characterUpdateMaster')) {
                 lastError = new Error(`Parsing error (Attempt ${attempt}/${MAX_RETRIES}): ${parserError}`);
                 apiKeyManager.incrementApiKeyFailure(apiKeyUsed);
                 if (typeof uiChatModule !== 'undefined' && uiChatModule.showRetryIndicator) {
                      uiChatModule.showRetryIndicator();
                 }
                 if (attempt === MAX_RETRIES) break; else continue;
             } else if (parserError) {
                 lastError = new Error(`Parsing error (Attempt ${attempt}/${MAX_RETRIES}): ${parserError}`);
             }

            if (!parserError || (roleName !== 'privateAssistant' && roleName !== 'characterUpdateMaster')) {
                 if (typeof uiChatModule !== 'undefined' && uiChatModule.displayAIResponse) {
                 uiChatModule.displayAIResponse(result.data, roleName, targetRoleNameForTool);
                 } else {
                 }
                 return;
            }
        }

        _logAndDisplayError(`Gemini request ultimately failed (Role: ${roleName}): ${lastError?.message || 'Unknown error'}`, '_sendGeminiRequestWithRetry');
    },
    _prepareNovelAiPayload: async (parsedDrawingMasterData, rawJsonText) => {
         if (!parsedDrawingMasterData || typeof parsedDrawingMasterData !== 'object' || !parsedDrawingMasterData.generalTagsString || !parsedDrawingMasterData.characterTags) {
             throw new Error("Invalid Drawing Master data (new format), cannot prepare NAI Payload.");
         }
         const naiApiKey = apiKeyManager.getNaiApiKey();
         if (!naiApiKey) {
             throw new Error("NovelAI API Key is not set.");
         }
         const generalTagsString = parsedDrawingMasterData.generalTagsString || "";
         const characterTagSets = parsedDrawingMasterData.characterTags || [];
         const numCharacters = characterTagSets.length;
         let promptParts = [];
         let generalPromptPart = [];
         if (stateModule.config.novelaiDefaultPositivePrompt) generalPromptPart.push(stateModule.config.novelaiDefaultPositivePrompt);
         if (numCharacters > 0) generalPromptPart.push(`${numCharacters}character${numCharacters > 1 ? 's' : ''}`);
         if (stateModule.config.novelaiArtistChain) generalPromptPart.push(stateModule.config.novelaiArtistChain);
         if (generalTagsString) generalPromptPart.push(generalTagsString);
         promptParts.push(generalPromptPart.filter(p=>p).join(', ').trim());
         let mainDrawingPromptContentForDisplay = "";
         const chatroomDetails = stateModule.currentChatroomDetails;
         if (!chatroomDetails) { throw new Error("Cannot get current chatroom details."); }
         const characterPromises = characterTagSets.map(async charSet => {
             let charPromptPart = [];
             const charName = charSet.characterName;
             const roleData = chatroomDetails.roles.find(r => r.name === charName);
             const drawingTemplate = roleData?.drawingTemplate || '';
             if (drawingTemplate) charPromptPart.push(drawingTemplate);
             if (charSet.tagsString) charPromptPart.push(charSet.tagsString);
             const characterPromptString = charPromptPart.filter(p=>p).join(', ').trim();
             return { name: charName, prompt: characterPromptString };
         });
         const characterResults = await Promise.all(characterPromises);
         characterResults.forEach(result => {
             if(result.prompt) promptParts.push(result.prompt);
             if (mainDrawingPromptContentForDisplay) mainDrawingPromptContentForDisplay += " | ";
             mainDrawingPromptContentForDisplay += `${result.name}: ${result.prompt || '[No Tags]'}`;
         });
         let finalPrompt = promptParts.map(p => p.replace(/,\s*,/g, ',').replace(/^,\s*|\s*,$/g, '')).filter(p => p).join(' | ');
         let cleanedPrompt = finalPrompt;
         cleanedPrompt = cleanedPrompt.replace(/,\s*0\s*,/g, ',');
         cleanedPrompt = cleanedPrompt.replace(/^0\s*,/g, '');
         cleanedPrompt = cleanedPrompt.replace(/,\s*0\s*$/g, '');
         cleanedPrompt = cleanedPrompt.replace(/^\s*0\s*$/g, '');
         cleanedPrompt = cleanedPrompt.replace(/,\s*,/g, ',');
         cleanedPrompt = cleanedPrompt.replace(/^,\s*/, '').replace(/,\s*$/, '');
         finalPrompt = cleanedPrompt.trim();
         const finalNegativePrompt = stateModule.config.novelaiDefaultNegativePrompt || "";
         let seed = parseInt(stateModule.config.novelaiSeed) || 0;
         if (seed === 0) {
             seed = Math.floor(Math.random() * 10000000000);
         }
         const model = stateModule.config.novelaiModel;
         const isV4 = model.startsWith("nai-diffusion-4");
         const finalParameters = {
             params_version: 3,
             width: parseInt(stateModule.config.novelaiWidth) || 1024,
             height: parseInt(stateModule.config.novelaiHeight) || 1024,
             scale: parseFloat(stateModule.config.novelaiScale) || 5.0,
             sampler: stateModule.config.novelaiSampler || "k_euler",
             steps: parseInt(stateModule.config.novelaiSteps) || 28,
             seed: seed,
             n_samples: 1,
             ucPreset: 3,
             qualityToggle: true,
             dynamic_thresholding: false,
             controlnet_strength: 1,
             legacy: false,
             add_original_image: false,
             cfg_rescale: parseFloat(stateModule.config.novelaiCfgRescale) || 0.0,
             noise_schedule: stateModule.config.novelaiNoiseSchedule || "native",
             skip_cfg_above_sigma: null,
             legacy_v3_extend: false,
         };
         let finalRequestBody = {
             model: model,
             action: "generate",
             parameters: finalParameters
         };
         if (isV4) {
             finalParameters.v4_prompt = {
                 caption: { base_caption: finalPrompt, char_captions: [] },
                 use_coords: false,
                 use_order: true
             };
             finalParameters.v4_negative_prompt = {
                 caption: { base_caption: finalNegativePrompt, char_captions: [] }
             };
         } else {
             finalRequestBody.input = finalPrompt;
             finalParameters.negative_prompt = finalNegativePrompt;
         }
         stateModule.lastNaiPrompt = finalPrompt;
         if (typeof uiSettingsModule !== 'undefined' && uiSettingsModule.updateLastNaiPromptDisplay) {
             uiSettingsModule.updateLastNaiPromptDisplay(stateModule.lastNaiPrompt);
         }
         return {
             nai_api_key: naiApiKey,
             parameters: finalRequestBody,
             originalDrawingMasterData: parsedDrawingMasterData,
             rawJsonText: rawJsonText
         };
    },
    addNaiRequestToQueue: (requestData, targetMessageId = null) => {
        const queueItem = { ...requestData, targetMessageId };
        if (stateModule.naiRequestQueue.length >= 3) {
             stateModule.naiRequestQueue.shift();
        }
        stateModule.naiRequestQueue.push(queueItem);
        if (!stateModule.isNaiProcessing) {
            apiModule.processNaiQueue();
        }
    },
    processNaiQueue: async () => {
        if (stateModule.isNaiProcessing || stateModule.naiRequestQueue.length === 0) {
            return;
        }
        stateModule.isNaiProcessing = true;
        const requestData = stateModule.naiRequestQueue.shift();
        const { nai_api_key, parameters, originalDrawingMasterData, rawJsonText, targetMessageId } = requestData;
        let lastError = null;
        let success = false;
        const abortController = new AbortController();
        const timeoutId = setTimeout(() => abortController.abort(), REQUEST_TIMEOUT_MS);
        let responseData = null;
        try {
            const response = await fetch('/novelai-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ nai_api_key, parameters }),
                signal: abortController.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`NAI Proxy Error! Status: ${response.status}, Detail: ${errorText}`);
            }
            responseData = await response.json();
            if (responseData && responseData.imageDataUrl) {
                if (typeof uiChatModule !== 'undefined' && uiChatModule.handleNovelAiResponse) {
                    uiChatModule.handleNovelAiResponse(responseData, originalDrawingMasterData, rawJsonText, targetMessageId);
                } else {
                }
                success = true;
            } else {
                lastError = new Error('NAI response missing valid imageDataUrl');
            }
        } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                lastError = new Error(`NAI request timed out`);
            } else {
                lastError = new Error(`NAI request failed: ${error.message}`);
            }
        }

        if (!success && lastError) {
             _logAndDisplayError(`NAI request failed: ${lastError.message}`, 'processNaiQueue', 'N/A', 'N/A', lastError);
             if (typeof uiChatModule !== 'undefined' && uiChatModule.handleNovelAiResponse) {
                  uiChatModule.handleNovelAiResponse({ error: lastError.message }, originalDrawingMasterData, rawJsonText, targetMessageId);
             }
        }
        stateModule.isNaiProcessing = false;
        if(stateModule.naiRequestQueue.length > 0) {
             setTimeout(() => apiModule.processNaiQueue(), 1000);
        }
    },
    fetchModels: async () => {
        const setAllOptions = (message, isError = false) => {
            const allSelects = document.querySelectorAll('.settings-select[id*="-model-"]');
            allSelects.forEach(selectElement => {
                 if (selectElement.id !== 'novelai-model-settings') {
                     selectElement.innerHTML = `<option value="" disabled selected>${message}</option>`;
                     selectElement.style.borderColor = isError ? 'red' : '';
                 }
            });
        };

        setAllOptions('正在拉取...');

        let allKeys = apiKeyManager.getApiKeys();
        if (allKeys.length === 0) {
            _logAndDisplayError("No API keys configured, cannot load model list.", 'fetchModels');
            setAllOptions('无API密钥', true);
            alert('请先在API设置中输入至少一个谷歌API密钥！');
            return;
        }

        let success = false;
        let lastError = null;
        let loadedModels = [];
        const maxAttempts = allKeys.length;
        let attemptedKeys = 0;

        while(attemptedKeys < maxAttempts && !success) {
             let apiKey;
             try {
                  apiKey = apiKeyManager.selectApiKey();
             } catch (e) {
                 lastError = e;
                 _logAndDisplayError(`Error selecting API key (attempt ${attemptedKeys + 1}): ${e.message}`, 'fetchModels');
                 attemptedKeys++;
                 continue;
             }

             if (!apiKey) {
                  lastError = new Error("Got an empty API key.");
                  _logAndDisplayError(`Attempt ${attemptedKeys + 1}/${maxAttempts}: Got an empty API key.`, 'fetchModels');
                  attemptedKeys++;
                  continue;
             }

             try {
                const response = await fetch(`/models?key=${apiKey}`);
                apiKeyManager.markApiKeyUsed(apiKey);

                if (!response.ok) {
                    const errorText = await response.text();
                    lastError = new Error(`Model list load failed (Key ${apiKey.substring(0, 4)}..., Attempt ${attemptedKeys + 1}/${maxAttempts}): ${response.status} ${errorText}`);
                    _logAndDisplayError(lastError.message, 'fetchModels');
                    apiKeyManager.incrementApiKeyFailure(apiKey);
                    attemptedKeys++;
                    continue;
                }

                const data = await response.json();
                if (data.models && Array.isArray(data.models)) {
                    loadedModels = [];
                    data.models.forEach(model => {
                       if (model.name && model.supportedGenerationMethods?.includes('generateContent')) {
                           const modelId = model.name.startsWith('models/') ? model.name.substring(7) : model.name;
                           loadedModels.push({ id: modelId, name: model.displayName || modelId });
                       }
                    });
                    loadedModels.sort((a, b) => a.name.localeCompare(b.name));
                    stateModule.availableModels = loadedModels;
                    success = true;
                } else {
                     lastError = new Error("Invalid model list response format (no models array)");
                     _logAndDisplayError(lastError.message, 'fetchModels');
                     apiKeyManager.incrementApiKeyFailure(apiKey);
                     attemptedKeys++;
                     continue;
                }
            } catch (error) {
                apiKeyManager.markApiKeyUsed(apiKey);
                lastError = error;
                _logAndDisplayError(`Network or processing error fetching models (Key ${apiKey.substring(0, 4)}..., Attempt ${attemptedKeys + 1}/${maxAttempts}): ${error.message}`, 'fetchModels');
                apiKeyManager.incrementApiKeyFailure(apiKey);
                attemptedKeys++;
                continue;
            }
        }

        if (success) {
            const allSelects = document.querySelectorAll('.settings-select[id*="-model-"]');
            allSelects.forEach(selectElement => {
                 if (selectElement.id !== 'novelai-model-settings') {
                    const previouslySelectedValue = selectElement.value;
                    const previouslySelectedText = selectElement.options[selectElement.selectedIndex]?.text || "";

                    selectElement.innerHTML = '';
                    selectElement.style.borderColor = '';

                    let valueToSelect = previouslySelectedValue;
                    let valueFoundInNewList = false;

                    stateModule.availableModels.forEach(model => {
                         const option = new Option(model.name, model.id);
                         selectElement.add(option);
                         if (model.id === valueToSelect) {
                             valueFoundInNewList = true;
                         }
                    });

                    if (!valueFoundInNewList && previouslySelectedValue) {
                         const oldOption = new Option(previouslySelectedText || `(旧) ${previouslySelectedValue}`, previouslySelectedValue);
                         selectElement.add(oldOption, 0);
                         valueToSelect = previouslySelectedValue;
                    } else if (!valueFoundInNewList && !previouslySelectedValue && selectElement.options.length > 0) {
                         valueToSelect = selectElement.options[0].value;
                    }

                    if (selectElement.options.length === 0) {
                         selectElement.innerHTML = '<option value="" disabled selected>无可用模型</option>';
                    } else {
                         selectElement.value = valueToSelect;
                    }
                 }
            });
            alert('模型列表拉取成功！');
        } else {
            _logAndDisplayError(`All API key attempts failed to load model list. Last error: ${lastError?.message || 'Unknown error'}`, 'fetchModels');
            setAllOptions('拉取失败', true);
            alert(`拉取模型列表失败！\n${lastError?.message || '未知错误'}`);
        }
    },
    sendSingleMessageForRoleImpl: async (roleName, roleType, targetRoleNameForTool = null, triggeringCharacterName = null) => {
        await apiModule._sendGeminiRequestWithRetry(roleName, roleType, targetRoleNameForTool, triggeringCharacterName);
    },
    triggerRoleResponse: (roleName, triggeringCharacterName = null) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !chatroomDetails.config) return;
        let roleType = 'unknown';
        let roleConfig = chatroomDetails.config.roleStates ? chatroomDetails.config.roleStates[roleName] : undefined;
        let toolConfig = null;
        if (toolNameMap.hasOwnProperty(roleName)) {
             roleType = 'tool';
             toolConfig = stateModule.config.toolSettings[roleName];
             if (!toolConfig || !toolConfig.enabled) return;
        } else {
             const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
             if (roleConfig !== undefined) {
                 roleType = isPermanent ? 'role' : 'temporary_role';
                 if (![uiChatModule.ROLE_STATE_ACTIVE, uiChatModule.ROLE_STATE_USER_CONTROL].includes(roleConfig || uiChatModule.ROLE_STATE_DEFAULT)) {
                     return;
                 }
             } else {
                  return;
             }
        }
        if (stateModule.config.isRunPaused && (roleType === 'role' || roleType === 'temporary_role')) {
            return;
        }

        if (!stateModule.chatContextCache) {
             updateChatContextCache().then(() => {
                if (!stateModule.chatContextCache) {
                    _logAndDisplayError("无法触发响应：上下文缓存为空。", 'triggerRoleResponse');
                    return;
                }
                apiModule._triggerRoleResponseInternal(roleName, roleType, triggeringCharacterName);
             });
        } else {
             apiModule._triggerRoleResponseInternal(roleName, roleType, triggeringCharacterName);
        }
    },
    _triggerRoleResponseInternal: (roleName, roleType, triggeringCharacterName = null) => {
        apiModule.sendSingleMessageForRoleImpl(roleName, roleType, null, triggeringCharacterName);
    },
    triggerCharacterUpdateForRole: (targetRoleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !chatroomDetails.config?.roleStates || !(targetRoleName in chatroomDetails.config.roleStates)) {
             _logAndDisplayError(`无法更新角色 ${targetRoleName}：不在当前聊天室中。`, 'triggerCharacterUpdateForRole');
            return;
        }
        const toolName = 'characterUpdateMaster';
        if (!stateModule.config.toolSettings[toolName]?.enabled) {
             return;
        }
        apiModule.sendSingleMessageForRoleImpl(toolName, 'tool', targetRoleName);
    },
    addChatroom: async (name) => {
        if (!name || name.trim() === "") {
             _logAndDisplayError("Chatroom name cannot be empty.", "addChatroom");
             return null;
        }
        try {
            const response = await fetch('/create-chatroom', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chatroom_name: name })
            });
            const result = await response.json();
            if (!response.ok) {
                 throw new Error(result.error || `HTTP error! Status: ${response.status}`);
            }
            stateModule.config.chatRoomOrder.push(name);
            if (typeof mainModule !== 'undefined') mainModule.triggerDebouncedSave();
            return name;
        } catch (error) {
            _logAndDisplayError(`Failed to create chatroom '${name}': ${error.message}`, 'addChatroom');
            return null;
        }
    },
    renameChatroom: async (oldName, newName) => {
         if (!oldName || !newName || oldName === newName || newName.trim() === "") {
             _logAndDisplayError("Invalid names for rename.", 'renameChatroom');
             return false;
         }
         try {
             const response = await fetch(`/rename-chatroom/${encodeURIComponent(oldName)}`, {
                 method: 'PUT',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify({ new_name: newName })
             });
             const result = await response.json();
             if (!response.ok) {
                 throw new Error(result.error || `HTTP error! Status: ${response.status}`);
             }
             const index = stateModule.config.chatRoomOrder.indexOf(oldName);
             if (index > -1) {
                 stateModule.config.chatRoomOrder[index] = newName;
             } else {
                  stateModule.config.chatRoomOrder.push(newName);
             }
             if (stateModule.config.activeChatRoomName === oldName) {
                 stateModule.config.activeChatRoomName = newName;
             }
             if (typeof mainModule !== 'undefined') mainModule.triggerDebouncedSave();
             return true;
         } catch (error) {
             _logAndDisplayError(`Failed to rename chatroom '${oldName}' to '${newName}': ${error.message}`, 'renameChatroom');
             return false;
         }
    },
    deleteChatroom: async (name) => {
        if (!name) return false;
        try {
             const response = await fetch(`/delete-chatroom/${encodeURIComponent(name)}`, {
                 method: 'DELETE'
             });
             const result = await response.json();
             if (!response.ok) {
                 throw new Error(result.error || `HTTP error! Status: ${response.status}`);
             }
             stateModule.config.chatRoomOrder = stateModule.config.chatRoomOrder.filter(n => n !== name);
             if (stateModule.config.activeChatRoomName === name) {
                 stateModule.config.activeChatRoomName = stateModule.config.chatRoomOrder.length > 0 ? stateModule.config.chatRoomOrder[0] : null;
                 stateModule.currentChatroomDetails = null;
             }
             if (typeof mainModule !== 'undefined') mainModule.triggerDebouncedSave();
             return true;
        } catch (error) {
             _logAndDisplayError(`Failed to delete chatroom '${name}': ${error.message}`, 'deleteChatroom');
             return false;
        }
    },
    fetchChatroomDetails: async (roomName) => {
         if (!roomName) {
             stateModule.currentChatroomDetails = null;
             updateChatContextCache();
             return;
         }
         try {
             const response = await fetch(`/chatroom-details/${encodeURIComponent(roomName)}`);
             if (!response.ok) {
                 const errorData = await response.json().catch(() => ({ error: `HTTP error! status: ${response.status}` }));
                 throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
             }
             const details = await response.json();
             if (details.config && !details.config.roleDetailedStates) {
                 details.config.roleDetailedStates = {};
             }
             if (details.config && !details.config.overrideSettings) {
                details.config.overrideSettings = JSON.parse(JSON.stringify(defaultChatroomOverrideSettings));
                _logAndDisplayError(`Chatroom ${roomName} config missing overrideSettings, added default. Consider re-exporting/importing if this persists.`, 'fetchChatroomDetails');
             } else if (details.config && details.config.overrideSettings) {

                 let updated = false;
                 const currentOverrides = details.config.overrideSettings;
                 const defaultKeys = Object.keys(defaultChatroomOverrideSettings);
                 const currentKeys = Object.keys(currentOverrides);

                 defaultKeys.forEach(key => {
                     if (!currentOverrides[key]) {
                         currentOverrides[key] = JSON.parse(JSON.stringify(defaultChatroomOverrideSettings[key]));
                         updated = true;
                     } else {
                          const defaultSectionKeys = Object.keys(defaultChatroomOverrideSettings[key]);
                          const currentSectionKeys = Object.keys(currentOverrides[key]);
                          defaultSectionKeys.forEach(subKey => {
                              if (!(subKey in currentOverrides[key])) {
                                 currentOverrides[key][subKey] = defaultChatroomOverrideSettings[key][subKey];
                                 updated = true;
                              }
                          });
                     }
                 });
                 if(updated) {
                      _logAndDisplayError(`Chatroom ${roomName} overrideSettings structure updated.`, 'fetchChatroomDetails');

                 }
             }


             stateModule.currentChatroomDetails = details;
             updateChatContextCache();
         } catch (error) {
              _logAndDisplayError(`Failed to fetch details for chatroom '${roomName}': ${error.message}`, 'fetchChatroomDetails');
              stateModule.currentChatroomDetails = null;
              updateChatContextCache();
              if (stateModule.config.activeChatRoomName === roomName) {
                  stateModule.config.activeChatRoomName = stateModule.config.chatRoomOrder.length > 0 ? stateModule.config.chatRoomOrder[0] : null;
                  if (typeof mainModule !== 'undefined') mainModule.triggerDebouncedSave();
              }
         }
    },
    updateChatroomConfig: async (roomName, configData) => {
         if (!roomName || !configData) return false;
         try {
             const response = await fetch(`/update-chatroom-config/${encodeURIComponent(roomName)}`, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(configData)
             });
             const result = await response.json();
             if (!response.ok) {
                  throw new Error(result.error || `HTTP error! Status: ${response.status}`);
             }
             return true;
         } catch (error) {
              _logAndDisplayError(`Failed to update config for chatroom '${roomName}': ${error.message}`, 'updateChatroomConfig');
              return false;
         }
    },
    triggerDebouncedChatroomConfigSave: (roomName) => {
         if (!roomName || !stateModule.currentChatroomDetails || stateModule.currentChatroomDetails.config.name !== roomName) return;
         clearTimeout(stateModule.chatroomConfigSaveTimers[roomName]);
         stateModule.chatroomConfigSaveTimers[roomName] = setTimeout(async () => {
             const configToSave = { ...stateModule.currentChatroomDetails.config };
             delete configToSave.name;
             await apiModule.updateChatroomConfig(roomName, configToSave);
         }, stateModule.chatroomConfigSaveDelay);
    },
     createRole: async (roomName, roleData) => {
         if (!roomName || !roleData || !roleData.name) return false;
         try {
             const response = await fetch(`/roles/${encodeURIComponent(roomName)}`, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(roleData)
             });
             const result = await response.json();
             if (!response.ok) {
                 throw new Error(result.error || `HTTP error! Status: ${response.status}`);
             }
             return true;
         } catch (error) {
             _logAndDisplayError(`Failed to create role '${roleData.name}' in '${roomName}': ${error.message}`, 'createRole');
             return false;
         }
     },
     updateRole: async (roomName, roleName, roleData) => {
          if (!roomName || !roleName || !roleData) return false;
          try {
              const response = await fetch(`/roles/${encodeURIComponent(roomName)}/${encodeURIComponent(roleName)}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(roleData)
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! Status: ${response.status}`);
              }
              return true;
          } catch (error) {
              _logAndDisplayError(`Failed to update role '${roleName}' in '${roomName}': ${error.message}`, 'updateRole');
              return false;
          }
     },
     deleteRole: async (roomName, roleName) => {
          if (!roomName || !roleName) return false;
          try {
              const response = await fetch(`/roles/${encodeURIComponent(roomName)}/${encodeURIComponent(roleName)}`, {
                  method: 'DELETE'
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! Status: ${response.status}`);
              }
              return true;
          } catch (error) {
              _logAndDisplayError(`Failed to delete role '${roleName}' from '${roomName}': ${error.message}`, 'deleteRole');
              return false;
          }
     },
     createNovel: async (roomName, novelData) => {
          if (!roomName || !novelData || !novelData.id) return false;
          try {
              const response = await fetch(`/novels/${encodeURIComponent(roomName)}`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(novelData)
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! Status: ${response.status}`);
              }
              return true;
          } catch (error) {
              _logAndDisplayError(`Failed to create novel '${novelData.name}' in '${roomName}': ${error.message}`, 'createNovel');
              return false;
          }
     },
     updateNovel: async (roomName, novelId, novelData) => {
          if (!roomName || !novelId || !novelData) return false;
          try {
              const response = await fetch(`/novels/${encodeURIComponent(roomName)}/${encodeURIComponent(novelId)}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(novelData)
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! Status: ${response.status}`);
              }
              return true;
          } catch (error) {
              _logAndDisplayError(`Failed to update novel '${novelId}' in '${roomName}': ${error.message}`, 'updateNovel');
              return false;
          }
     },
     deleteNovel: async (roomName, novelId) => {
          if (!roomName || !novelId) return false;
          try {
              const response = await fetch(`/novels/${encodeURIComponent(roomName)}/${encodeURIComponent(novelId)}`, {
                  method: 'DELETE'
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! Status: ${response.status}`);
              }
              return true;
          } catch (error) {
              _logAndDisplayError(`Failed to delete novel '${novelId}' from '${roomName}': ${error.message}`, 'deleteNovel');
              return false;
          }
     },

    setBackgroundImage: async (roomName, imageDataUrl) => {
         if (!roomName || !imageDataUrl) {
             _logAndDisplayError("Missing roomName or imageDataUrl for setBackgroundImage", "setBackgroundImage");
             return;
         }
         try {
              const response = await fetch(`/background/${encodeURIComponent(roomName)}`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ imageDataUrl: imageDataUrl })
              });
              if (!response.ok) {
                   const errorData = await response.json().catch(() => ({}));
                   throw new Error(`Failed to set background: ${response.status} ${errorData.error || ''}`);
              }
              const result = await response.json();
              if (stateModule.currentChatroomDetails && stateModule.currentChatroomDetails.config.name === roomName) {
                   stateModule.currentChatroomDetails.config.backgroundImageFilename = result.path.split('/').pop();
                   if (elementsModule.chatContainer) {
                       elementsModule.chatContainer.style.backgroundImage = `url(${result.path}?t=${Date.now()})`;
                   }
              }
         } catch (error) {
              _logAndDisplayError(error.message, "setBackgroundImage");
         }
    },
    removeBackgroundImage: async (roomName) => {
         if (!roomName) return;
         try {
              const response = await fetch(`/background/${encodeURIComponent(roomName)}`, { method: 'DELETE' });
              if (!response.ok && response.status !== 404) {
                  const errorData = await response.json().catch(() => ({}));
                  throw new Error(`Failed to delete background: ${response.status} ${errorData.error || ''}`);
              }
              if (stateModule.currentChatroomDetails && stateModule.currentChatroomDetails.config.name === roomName) {
                  stateModule.currentChatroomDetails.config.backgroundImageFilename = null;
                   if (elementsModule.chatContainer) {
                       elementsModule.chatContainer.style.backgroundImage = '';
                   }
              }
         } catch (error) {
              _logAndDisplayError(error.message, "removeBackgroundImage");
         }
    },
    exportPromptPresets: () => {
        const dataToExport = {
            version: 2,
            globalSettings: {
                systemInstruction: stateModule.config.systemInstruction || '',
                promptPresetTurns: stateModule.config.promptPresetTurns || []
            },
            sharedChatroomSettings: {
                model: stateModule.config.model || '',
                responseSchemaJson: stateModule.config.responseSchemaJson || '',
                responseSchemaParserJs: stateModule.config.responseSchemaParserJs || '',
                sharedDatabaseInstruction: stateModule.config.sharedDatabaseInstruction || '',
                mainPrompt: stateModule.config.mainPrompt || '',
            },
            toolSettings: {}
        };
        Object.keys(stateModule.config.toolSettings).forEach(toolName => {
            const toolConfig = stateModule.config.toolSettings[toolName];
            if (toolConfig) {
                 dataToExport.toolSettings[toolName] = {
                     model: toolConfig.model || '',
                     responseSchemaJson: toolConfig.responseSchemaJson || '',
                     responseSchemaParserJs: toolConfig.responseSchemaParserJs || '',
                     toolDatabaseInstruction: toolConfig.toolDatabaseInstruction || '',
                     mainPrompt: toolConfig.mainPrompt || ''
                 };
                 if (toolName === 'drawingMaster') {
                     dataToExport.toolSettings[toolName].novelContent = toolConfig.novelContent || '';
                 }
            }
        });
        const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'prompt_presets_extended.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },
    importPromptPresets: (file) => {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                if (!importedData || typeof importedData !== 'object') {
                    throw new Error("Invalid file format: Not an object.");
                }

                if (importedData.version === 2) {
                    if (importedData.globalSettings) {
                        stateModule.config.systemInstruction = importedData.globalSettings.systemInstruction || '';
                        stateModule.config.promptPresetTurns = Array.isArray(importedData.globalSettings.promptPresetTurns) ? importedData.globalSettings.promptPresetTurns : [];
                    } else {
                         stateModule.config.systemInstruction = '';
                         stateModule.config.promptPresetTurns = [];
                    }
                    if (importedData.sharedChatroomSettings) {
                         stateModule.config.model = importedData.sharedChatroomSettings.model || '';
                         stateModule.config.responseSchemaJson = importedData.sharedChatroomSettings.responseSchemaJson || '';
                         stateModule.config.responseSchemaParserJs = importedData.sharedChatroomSettings.responseSchemaParserJs || '';
                         stateModule.config.sharedDatabaseInstruction = importedData.sharedChatroomSettings.sharedDatabaseInstruction || '';
                         stateModule.config.mainPrompt = importedData.sharedChatroomSettings.mainPrompt || '';
                    } else {
                         stateModule.config.model = '';
                         stateModule.config.responseSchemaJson = '';
                         stateModule.config.responseSchemaParserJs = '';
                         stateModule.config.sharedDatabaseInstruction = '';
                         stateModule.config.mainPrompt = '';
                    }
                    if (importedData.toolSettings && typeof importedData.toolSettings === 'object') {
                        Object.keys(importedData.toolSettings).forEach(toolName => {
                             if (stateModule.config.toolSettings[toolName]) {
                                 const importedTool = importedData.toolSettings[toolName];
                                 if (importedTool && typeof importedTool === 'object') {
                                     stateModule.config.toolSettings[toolName].model = importedTool.model || '';
                                     stateModule.config.toolSettings[toolName].responseSchemaJson = importedTool.responseSchemaJson || '';
                                     stateModule.config.toolSettings[toolName].responseSchemaParserJs = importedTool.responseSchemaParserJs || '';
                                     stateModule.config.toolSettings[toolName].toolDatabaseInstruction = importedTool.toolDatabaseInstruction || '';
                                     stateModule.config.toolSettings[toolName].mainPrompt = importedTool.mainPrompt || '';
                                      if (toolName === 'drawingMaster' && importedTool.novelContent) {
                                          stateModule.config.toolSettings.drawingMaster.novelContent = importedTool.novelContent;
                                      }
                                 }
                             }
                        });
                    }
                } else {
                     stateModule.config.systemInstruction = importedData.systemInstruction || '';
                     stateModule.config.promptPresetTurns = Array.isArray(importedData.promptPresetTurns) ? importedData.promptPresetTurns : [];
                     _logAndDisplayError("Imported data is V1 format. Only systemInstruction and promptPresetTurns were imported.", 'importPromptPresets');
                }
                if (typeof uiSettingsModule !== 'undefined') {
                    uiSettingsModule.loadPromptPresetSettings();
                    uiSettingsModule.renderPromptPresetsList();
                    uiSettingsModule.loadChatroomModelSetting();
                    uiSettingsModule.loadSettingValue('responseSchemaJson');
                    uiSettingsModule.loadSettingValue('responseSchemaParserJs');
                    uiSettingsModule.loadSettingValue('sharedDatabaseInstruction');
                    uiSettingsModule.loadChatroomMainPromptSetting();
                    ['drawingMaster', 'gameHost', 'writingMaster', 'characterUpdateMaster', 'privateAssistant'].forEach(toolName => {
                        uiSettingsModule.loadGodSettings(toolName);
                    });
                }
                if (typeof mainModule !== 'undefined') {
                    mainModule.triggerDebouncedSave();
                }

            } catch (error) {
                _logAndDisplayError(`Failed to import prompt presets: ${error.message}`, 'importPromptPresets');

            }
        };
        reader.onerror = () => {
            _logAndDisplayError('Error reading file.', 'importPromptPresets');

        };
        reader.readAsText(file);
    },
};
```
--- END OF FILE core.js ---


--- START OF FILE ui_elements.js ---
```javascript
const elementsModule = {
    settingsIcon: null,
    settingsPanel: null,
    settingPages: null,
    settingsMainMenuPage: null,
    settingsMenuItems: null,

    chatRoomSettingsMenuItems: null,
    chatroomDetailSettingsMenuItems: null,
    closeButtons: null,

    apiKeyTextareaSettings: null,
    apiKeyFailureCountsDisplay: null,
    fetchModelsButton: null,

    chatArea: null,
    chatContainer: null,
    errorLogDisplay: null,
    copyErrorLogButton: null,
    clearAllConfigButton: null,
    exportConfigButton: null,
    importConfigFile: null,
    importConfigButton: null,

    temperatureSettings: null,
    topPSettings: null,
    topKSettings: null,
    maxOutputTokensSettings: null,
    systemInstructionPresetSettings: null,
    responseMimeTypeSettings: null,

    promptPresetPage: null,
    promptPresetListContainer: null,
    addPromptUserTurnButton: null,
    addPromptModelTurnButton: null,
    exportPromptPresetsButton: null,
    importPromptPresetsButton: null,
    importPromptPresetsFile: null,

    originalNovelLengthSettings: null,
    worldInfoDisplay: null,

    roleListContainer: null,
    addChatroomRoleButton: null,
    importRoleFile: null,
    importRoleButton: null,
    roleDetailHeaderTitle: null,
    roleDetailpage: null,
    roleInstructionTextarea: null,
    roleMemoryTextarea: null,
    roleStateTextarea: null,
    roleDrawingTemplateSettings: null,
    exportRoleButton: null,

    toolListMenuItems: null,
    toolListPage: null,

    drawingMasterPage: null,
    drawingMasterResponseSchemaJsonSettings: null,
    drawingMasterResponseSchemaParserJsSettings: null,
    drawingMasterToolDatabaseInstructionSettings: null,
    drawingMasterEnabledSettings: null,
    drawingMasterModelSettings: null,
    drawingMasterMainPromptSettings: null,
    drawingMasterNovelContentSettings: null,

    gameHostPage: null,
    gameHostResponseSchemaJsonSettings: null,
    gameHostResponseSchemaParserJsSettings: null,
    gameHostToolDatabaseInstructionSettings: null,
    gameHostEnabledSettings: null,
    gameHostModelSettings: null,
    gameHostMainPromptSettings: null,

    writingMasterPage: null,
    writingMasterResponseSchemaJsonSettings: null,
    writingMasterResponseSchemaParserJsSettings: null,
    writingMasterToolDatabaseInstructionSettings: null,
    writingMasterEnabledSettings: null,
    writingMasterModelSettings: null,
    writingMasterMainPromptSettings: null,

    characterUpdateMasterPage: null,
    characterUpdateMasterResponseSchemaJsonSettings: null,
    characterUpdateMasterResponseSchemaParserJsSettings: null,
    characterUpdateMasterToolDatabaseInstructionSettings: null,
    characterUpdateMasterEnabledSettings: null,
    characterUpdateMasterModelSettings: null,
    characterUpdateMasterMainPromptSettings: null,

    privateAssistantPage: null,
    privateAssistantResponseSchemaJsonSettings: null,
    privateAssistantResponseSchemaParserJsSettings: null,
    privateAssistantToolDatabaseInstructionSettings: null,
    privateAssistantEnabledSettings: null,
    privateAssistantModelSettings: null,
    privateAssistantMainPromptSettings: null,


    chatRoomSettingsPage: null,
    generalConfigPage: null,
    chatroomModelSelectSettings: null,
    responseSchemaJsonSettings: null,
    responseSchemaParserJsSettings: null,
    sharedDatabaseInstructionSettings: null,
    chatroomMainPromptSettings: null,

    chatRoomDirectoryPage: null,
    addChatroomButton: null,
    chatroomListContainer: null,
    importChatroomFile: null,
    importChatroomButton: null,

    chatRoomDetailPage: null,
    chatroomDetailHeaderTitle: null,

    currentChatroomSettingsPage: null,
    chatroomHistoryDisplay: null,
    clearChatroomHistoryButton: null,
    renameChatroomButton: null,
    deleteChatroomButton: null,
    exportChatroomButton: null,
    chatroomUserSetting: null,

    chatroomRolePage: null,
    chatroomNovelPage: null,

    chatroomOverrideConfigMenuPage: null,
    chatroomOverrideConfigMenuItems: null,
    chatroomOverrideGeneralPage: null,
    chatroomOverrideGeneralEnabled: null,
    chatroomOverrideGeneralModelSelect: null,
    chatroomOverrideGeneralResponseSchemaJson: null,
    chatroomOverrideGeneralResponseSchemaParserJs: null,
    chatroomOverrideGeneralSharedDatabaseInstruction: null,
    chatroomOverrideGeneralMainPrompt: null,

    chatroomOverrideDrawingMasterPage: null,
    chatroomOverrideDrawingMasterEnabled: null,
    chatroomOverrideDrawingMasterModelSelect: null,
    chatroomOverrideDrawingMasterResponseSchemaJson: null,
    chatroomOverrideDrawingMasterResponseSchemaParserJs: null,
    chatroomOverrideDrawingMasterToolDatabaseInstruction: null,
    chatroomOverrideDrawingMasterMainPrompt: null,
    chatroomOverrideDrawingMasterNovelContent: null,

    chatroomOverrideGameHostPage: null,
    chatroomOverrideGameHostEnabled: null,
    chatroomOverrideGameHostModelSelect: null,
    chatroomOverrideGameHostResponseSchemaJson: null,
    chatroomOverrideGameHostResponseSchemaParserJs: null,
    chatroomOverrideGameHostToolDatabaseInstruction: null,
    chatroomOverrideGameHostMainPrompt: null,

    chatroomOverrideWritingMasterPage: null,
    chatroomOverrideWritingMasterEnabled: null,
    chatroomOverrideWritingMasterModelSelect: null,
    chatroomOverrideWritingMasterResponseSchemaJson: null,
    chatroomOverrideWritingMasterResponseSchemaParserJs: null,
    chatroomOverrideWritingMasterToolDatabaseInstruction: null,
    chatroomOverrideWritingMasterMainPrompt: null,

    chatroomOverrideCharacterUpdateMasterPage: null,
    chatroomOverrideCharacterUpdateMasterEnabled: null,
    chatroomOverrideCharacterUpdateMasterModelSelect: null,
    chatroomOverrideCharacterUpdateMasterResponseSchemaJson: null,
    chatroomOverrideCharacterUpdateMasterResponseSchemaParserJs: null,
    chatroomOverrideCharacterUpdateMasterToolDatabaseInstruction: null,
    chatroomOverrideCharacterUpdateMasterMainPrompt: null,

    chatroomOverridePrivateAssistantPage: null,
    chatroomOverridePrivateAssistantEnabled: null,
    chatroomOverridePrivateAssistantModelSelect: null,
    chatroomOverridePrivateAssistantResponseSchemaJson: null,
    chatroomOverridePrivateAssistantResponseSchemaParserJs: null,
    chatroomOverridePrivateAssistantToolDatabaseInstruction: null,
    chatroomOverridePrivateAssistantMainPrompt: null,


    runPauseButton: null,
    roleButton: null,
    ruleButton: null,
    roleButtonsListContainer: null,

    topToolbar: null,
    loadingSpinner: null,
    addAdminButton: null,
    pendingActionButtonContainer: null,

    storyModePage: null,
    addNovelButton: null,
    novelListContainer: null,


    novelButton: null,
    novelInterface: null,
    novelBookshelfButton: null,
    novelTocButton: null,
    novelContentArea: null,
    novelContentDisplay: null,
    novelBookshelfPage: null,
    novelTocPage: null,
    novelBookshelfCloseButton: null,
    novelTocCloseButton: null,
    novelBookshelfListContainer: null,
    novelTocListContainer: null,

    imageViewerPage: null,
    imageViewerContent: null,

    novelaiApiKeySettings: null,
    novelaiModelSettings: null,
    novelaiArtistChainSettings: null,
    novelaiDefaultPositivePromptSettings: null,
    novelaiDefaultNegativePromptSettings: null,
    novelaiLastPromptDisplay: null,
    novelaiWidthSettings: null,
    novelaiHeightSettings: null,
    novelaiStepsSettings: null,
    novelaiScaleSettings: null,
    novelaiCfgRescaleSettings: null,
    novelaiSamplerSettings: null,
    novelaiNoiseScheduleSettings: null,
    novelaiSeedSettings: null,


    roleplayRulesTextarea: null,
    publicInfoTextarea: null,

    activeRoleTriggerList: null,

    init: function() {
        this.settingsIcon = document.getElementById('settings-icon');
        this.settingsPanel = document.getElementById('settings-panel');
        this.settingPages = document.querySelectorAll('.setting-page-template');
        this.settingsMainMenuPage = document.getElementById('settings-main-page');
        this.settingsMenuItems = document.querySelectorAll('#settings-menu .settings-menu-item');

        this.chatRoomSettingsMenuItems = document.querySelectorAll('#chat-room-settings-menu .settings-menu-item');
        this.chatroomDetailSettingsMenuItems = document.querySelectorAll('#chatroom-settings-menu .settings-menu-item');
        this.closeButtons = document.querySelectorAll('.close-button');

        this.apiKeyTextareaSettings = document.getElementById('api-key-textarea-settings');
        this.apiKeyFailureCountsDisplay = document.getElementById('api-key-failure-counts-display');
        this.fetchModelsButton = document.getElementById('fetch-models-button');

        this.chatArea = document.getElementById('chat-area');
        this.chatContainer = document.getElementById('chat-container');
        this.errorLogDisplay = document.getElementById('error-log-display');
        this.copyErrorLogButton = document.getElementById('copy-error-log-button');
        this.clearAllConfigButton = document.getElementById('clear-all-config-button');
        this.exportConfigButton = document.getElementById('export-config-button');
        this.importConfigFile = document.getElementById('import-config-file');
        this.importConfigButton = document.getElementById('import-config-button');

        this.temperatureSettings = document.getElementById('temperature-settings');
        this.topPSettings = document.getElementById('top-p-settings');
        this.topKSettings = document.getElementById('top-k-settings');
        this.maxOutputTokensSettings = document.getElementById('max-output-tokens-settings');
        this.systemInstructionPresetSettings = document.getElementById('system-instruction-preset-settings');
        this.responseMimeTypeSettings = document.getElementById('response-mime-type-settings');

        this.promptPresetPage = document.getElementById('prompt-preset-page');
        this.promptPresetListContainer = document.getElementById('prompt-preset-list-container');
        this.addPromptUserTurnButton = document.getElementById('add-prompt-user-turn-button');
        this.addPromptModelTurnButton = document.getElementById('add-prompt-model-turn-button');
        this.exportPromptPresetsButton = document.getElementById('export-prompt-presets-button');
        this.importPromptPresetsButton = document.getElementById('import-prompt-presets-button');
        this.importPromptPresetsFile = document.getElementById('import-prompt-presets-file');

        this.originalNovelLengthSettings = document.getElementById('original-novel-length-settings');
        this.worldInfoDisplay = document.getElementById('world-info-display');

        this.roleListContainer = document.getElementById('role-list-container');
        this.addChatroomRoleButton = document.getElementById('add-chatroom-role-button');
        this.importRoleFile = document.getElementById('import-role-file');
        this.importRoleButton = document.getElementById('import-role-button');
        this.roleDetailHeaderTitle = document.getElementById('role-detail-header-title');
        this.roleDetailpage = document.getElementById('role-detail-page');
        this.roleInstructionTextarea = document.getElementById('role-instruction-textarea');
        this.roleMemoryTextarea = document.getElementById('role-memory-textarea');
        this.roleStateTextarea = document.getElementById('role-state-textarea');
        this.roleDrawingTemplateSettings = document.getElementById('role-drawing-template-settings');
        this.exportRoleButton = document.getElementById('export-role-button');

        this.toolListMenuItems = document.querySelectorAll('#tool-list-container .tool-item');
        this.toolListPage = document.getElementById('tool-list-page');

        this.drawingMasterPage = document.getElementById('drawing-master-page');
        this.drawingMasterResponseSchemaJsonSettings = document.getElementById('drawing-master-response-schema-json-settings');
        this.drawingMasterResponseSchemaParserJsSettings = document.getElementById('drawing-master-response-schema-parser-js-settings');
        this.drawingMasterToolDatabaseInstructionSettings = document.getElementById('drawing-master-tool-database-instruction-settings');
        this.drawingMasterEnabledSettings = document.getElementById('drawing-master-enabled-settings');
        this.drawingMasterModelSettings = document.getElementById('drawing-master-model-settings');
        this.drawingMasterMainPromptSettings = document.getElementById('drawing-master-main-prompt-settings');
        this.drawingMasterNovelContentSettings = document.getElementById('drawing-master-novel-content-settings');

        this.gameHostPage = document.getElementById('game-host-page');
        this.gameHostResponseSchemaJsonSettings = document.getElementById('game-host-response-schema-json-settings');
        this.gameHostResponseSchemaParserJsSettings = document.getElementById('game-host-response-schema-parser-js-settings');
        this.gameHostToolDatabaseInstructionSettings = document.getElementById('game-host-tool-database-instruction-settings');
        this.gameHostEnabledSettings = document.getElementById('game-host-enabled-settings');
        this.gameHostModelSettings = document.getElementById('game-host-model-settings');
        this.gameHostMainPromptSettings = document.getElementById('game-host-main-prompt-settings');

        this.writingMasterPage = document.getElementById('writing-master-page');
        this.writingMasterResponseSchemaJsonSettings = document.getElementById('writing-master-response-schema-json-settings');
        this.writingMasterResponseSchemaParserJsSettings = document.getElementById('writing-master-response-schema-parser-js-settings');
        this.writingMasterToolDatabaseInstructionSettings = document.getElementById('writing-master-tool-database-instruction-settings');
        this.writingMasterEnabledSettings = document.getElementById('writing-master-enabled-settings');
        this.writingMasterModelSettings = document.getElementById('writing-master-model-settings');
        this.writingMasterMainPromptSettings = document.getElementById('writing-master-main-prompt-settings');

        this.characterUpdateMasterPage = document.getElementById('character-update-master-page');
        this.characterUpdateMasterResponseSchemaJsonSettings = document.getElementById('character-update-master-response-schema-json-settings');
        this.characterUpdateMasterResponseSchemaParserJsSettings = document.getElementById('character-update-master-response-schema-parser-js-settings');
        this.characterUpdateMasterToolDatabaseInstructionSettings = document.getElementById('character-update-master-tool-database-instruction-settings');
        this.characterUpdateMasterEnabledSettings = document.getElementById('character-update-master-enabled-settings');
        this.characterUpdateMasterModelSettings = document.getElementById('character-update-master-model-settings');
        this.characterUpdateMasterMainPromptSettings = document.getElementById('character-update-master-main-prompt-settings');

        this.privateAssistantPage = document.getElementById('private-assistant-page');
        this.privateAssistantResponseSchemaJsonSettings = document.getElementById('private-assistant-response-schema-json-settings');
        this.privateAssistantResponseSchemaParserJsSettings = document.getElementById('private-assistant-response-schema-parser-js-settings');
        this.privateAssistantToolDatabaseInstructionSettings = document.getElementById('private-assistant-tool-database-instruction-settings');
        this.privateAssistantEnabledSettings = document.getElementById('private-assistant-enabled-settings');
        this.privateAssistantModelSettings = document.getElementById('private-assistant-model-settings');
        this.privateAssistantMainPromptSettings = document.getElementById('private-assistant-main-prompt-settings');


        this.chatRoomSettingsPage = document.getElementById('chat-room-settings-page');
        this.generalConfigPage = document.getElementById('general-config-page');
        this.chatroomModelSelectSettings = document.getElementById('chatroom-model-select-settings');
        this.responseSchemaJsonSettings = document.getElementById('response-schema-json-settings');
        this.responseSchemaParserJsSettings = document.getElementById('response-schema-parser-js-settings');
        this.sharedDatabaseInstructionSettings = document.getElementById('shared-database-instruction-settings');
        this.chatroomMainPromptSettings = document.getElementById('chatroom-main-prompt-settings');

        this.chatRoomDirectoryPage = document.getElementById('chat-room-directory-page');
        this.addChatroomButton = document.getElementById('add-chatroom-button');
        this.chatroomListContainer = document.getElementById('chatroom-list-container');
        this.importChatroomFile = document.getElementById('import-chatroom-file');
        this.importChatroomButton = document.getElementById('import-chatroom-button');

        this.chatRoomDetailPage = document.getElementById('chat-room-detail-page');
        this.chatroomDetailHeaderTitle = document.getElementById('chatroom-detail-header-title');

        this.currentChatroomSettingsPage = document.getElementById('current-chatroom-settings-page');
        this.chatroomHistoryDisplay = document.getElementById('chatroom-history-display');
        this.clearChatroomHistoryButton = document.getElementById('clear-chatroom-history-button');
        this.renameChatroomButton = document.getElementById('rename-chatroom-button');
        this.deleteChatroomButton = document.getElementById('delete-chatroom-button');
        this.exportChatroomButton = document.getElementById('export-chatroom-button');
        this.chatroomUserSetting = document.getElementById('chatroom-user-setting');

        this.chatroomRolePage = document.getElementById('role-list-page');
        this.chatroomNovelPage = document.getElementById('story-mode-page');

        this.chatroomOverrideConfigMenuPage = document.getElementById('chatroom-override-config-menu-page');
        this.chatroomOverrideConfigMenuItems = document.querySelectorAll('#chatroom-override-config-menu .settings-menu-item');

        this.chatroomOverrideGeneralPage = document.getElementById('chatroom-override-general-page');
        this.chatroomOverrideGeneralEnabled = document.getElementById('chatroom-override-general-enabled');
        this.chatroomOverrideGeneralModelSelect = document.getElementById('chatroom-override-general-model-select');
        this.chatroomOverrideGeneralResponseSchemaJson = document.getElementById('chatroom-override-general-response-schema-json');
        this.chatroomOverrideGeneralResponseSchemaParserJs = document.getElementById('chatroom-override-general-response-schema-parser-js');
        this.chatroomOverrideGeneralSharedDatabaseInstruction = document.getElementById('chatroom-override-general-shared-database-instruction');
        this.chatroomOverrideGeneralMainPrompt = document.getElementById('chatroom-override-general-main-prompt');

        this.chatroomOverrideDrawingMasterPage = document.getElementById('chatroom-override-drawingMaster-page');
        this.chatroomOverrideDrawingMasterEnabled = document.getElementById('chatroom-override-drawingMaster-enabled');
        this.chatroomOverrideDrawingMasterModelSelect = document.getElementById('chatroom-override-drawingMaster-model-select');
        this.chatroomOverrideDrawingMasterResponseSchemaJson = document.getElementById('chatroom-override-drawingMaster-response-schema-json');
        this.chatroomOverrideDrawingMasterResponseSchemaParserJs = document.getElementById('chatroom-override-drawingMaster-response-schema-parser-js');
        this.chatroomOverrideDrawingMasterToolDatabaseInstruction = document.getElementById('chatroom-override-drawingMaster-tool-database-instruction');
        this.chatroomOverrideDrawingMasterMainPrompt = document.getElementById('chatroom-override-drawingMaster-main-prompt');
        this.chatroomOverrideDrawingMasterNovelContent = document.getElementById('chatroom-override-drawingMaster-novel-content');

        this.chatroomOverrideGameHostPage = document.getElementById('chatroom-override-gameHost-page');
        this.chatroomOverrideGameHostEnabled = document.getElementById('chatroom-override-gameHost-enabled');
        this.chatroomOverrideGameHostModelSelect = document.getElementById('chatroom-override-gameHost-model-select');
        this.chatroomOverrideGameHostResponseSchemaJson = document.getElementById('chatroom-override-gameHost-response-schema-json');
        this.chatroomOverrideGameHostResponseSchemaParserJs = document.getElementById('chatroom-override-gameHost-response-schema-parser-js');
        this.chatroomOverrideGameHostToolDatabaseInstruction = document.getElementById('chatroom-override-gameHost-tool-database-instruction');
        this.chatroomOverrideGameHostMainPrompt = document.getElementById('chatroom-override-gameHost-main-prompt');

        this.chatroomOverrideWritingMasterPage = document.getElementById('chatroom-override-writingMaster-page');
        this.chatroomOverrideWritingMasterEnabled = document.getElementById('chatroom-override-writingMaster-enabled');
        this.chatroomOverrideWritingMasterModelSelect = document.getElementById('chatroom-override-writingMaster-model-select');
        this.chatroomOverrideWritingMasterResponseSchemaJson = document.getElementById('chatroom-override-writingMaster-response-schema-json');
        this.chatroomOverrideWritingMasterResponseSchemaParserJs = document.getElementById('chatroom-override-writingMaster-response-schema-parser-js');
        this.chatroomOverrideWritingMasterToolDatabaseInstruction = document.getElementById('chatroom-override-writingMaster-tool-database-instruction');
        this.chatroomOverrideWritingMasterMainPrompt = document.getElementById('chatroom-override-writingMaster-main-prompt');

        this.chatroomOverrideCharacterUpdateMasterPage = document.getElementById('chatroom-override-characterUpdateMaster-page');
        this.chatroomOverrideCharacterUpdateMasterEnabled = document.getElementById('chatroom-override-characterUpdateMaster-enabled');
        this.chatroomOverrideCharacterUpdateMasterModelSelect = document.getElementById('chatroom-override-characterUpdateMaster-model-select');
        this.chatroomOverrideCharacterUpdateMasterResponseSchemaJson = document.getElementById('chatroom-override-characterUpdateMaster-response-schema-json');
        this.chatroomOverrideCharacterUpdateMasterResponseSchemaParserJs = document.getElementById('chatroom-override-characterUpdateMaster-response-schema-parser-js');
        this.chatroomOverrideCharacterUpdateMasterToolDatabaseInstruction = document.getElementById('chatroom-override-characterUpdateMaster-tool-database-instruction');
        this.chatroomOverrideCharacterUpdateMasterMainPrompt = document.getElementById('chatroom-override-characterUpdateMaster-main-prompt');

        this.chatroomOverridePrivateAssistantPage = document.getElementById('chatroom-override-privateAssistant-page');
        this.chatroomOverridePrivateAssistantEnabled = document.getElementById('chatroom-override-privateAssistant-enabled');
        this.chatroomOverridePrivateAssistantModelSelect = document.getElementById('chatroom-override-privateAssistant-model-select');
        this.chatroomOverridePrivateAssistantResponseSchemaJson = document.getElementById('chatroom-override-privateAssistant-response-schema-json');
        this.chatroomOverridePrivateAssistantResponseSchemaParserJs = document.getElementById('chatroom-override-privateAssistant-response-schema-parser-js');
        this.chatroomOverridePrivateAssistantToolDatabaseInstruction = document.getElementById('chatroom-override-privateAssistant-tool-database-instruction');
        this.chatroomOverridePrivateAssistantMainPrompt = document.getElementById('chatroom-override-privateAssistant-main-prompt');


        this.runPauseButton = document.getElementById('run-pause-button');
        this.roleButton = document.getElementById('role-button');
        this.ruleButton = document.getElementById('rule-button');
        this.roleButtonsListContainer = document.getElementById('role-buttons-list-container');

        this.topToolbar = document.getElementById('top-toolbar');
        this.loadingSpinner = document.getElementById('loading-spinner');
        this.addAdminButton = document.getElementById('add-admin-button');
        this.pendingActionButtonContainer = document.getElementById('pending-action-button-container');

        this.storyModePage = document.getElementById('story-mode-page');
        this.addNovelButton = document.getElementById('add-novel-button');
        this.novelListContainer = document.getElementById('novel-list-container');


        this.novelButton = document.getElementById('novel-button');
        this.novelInterface = document.getElementById('novel-interface');
        this.novelBookshelfButton = document.getElementById('novel-bookshelf-button');
        this.novelTocButton = document.getElementById('novel-toc-button');
        this.novelContentArea = document.getElementById('novel-content-area');
        this.novelContentDisplay = document.getElementById('novel-content-area');
        this.novelBookshelfPage = document.getElementById('novel-bookshelf-page');
        this.novelTocPage = document.getElementById('novel-toc-page');
        this.novelBookshelfCloseButton = document.querySelector('#novel-bookshelf-page .novel-close-button');
        this.novelTocCloseButton = document.querySelector('#novel-toc-page .novel-close-button');
        this.novelBookshelfListContainer = document.getElementById('novel-bookshelf-list-container');
        this.novelTocListContainer = document.getElementById('novel-toc-list-container');

        this.imageViewerPage = document.getElementById('image-viewer-page');
        this.imageViewerContent = document.getElementById('image-viewer-content');

        this.novelaiApiKeySettings = document.getElementById('novelai-api-key-settings');
        this.novelaiModelSettings = document.getElementById('novelai-model-settings');
        this.novelaiArtistChainSettings = document.getElementById('novelai-artist-chain-settings');
        this.novelaiDefaultPositivePromptSettings = document.getElementById('novelai-default-positive-prompt-settings');
        this.novelaiDefaultNegativePromptSettings = document.getElementById('novelai-default-negative-prompt-settings');
        this.novelaiLastPromptDisplay = document.getElementById('novelai-last-prompt-display');
        this.novelaiWidthSettings = document.getElementById('novelai-width-settings');
        this.novelaiHeightSettings = document.getElementById('novelai-height-settings');
        this.novelaiStepsSettings = document.getElementById('novelai-steps-settings');
        this.novelaiScaleSettings = document.getElementById('novelai-scale-settings');
        this.novelaiCfgRescaleSettings = document.getElementById('novelai-cfg-rescale-settings');
        this.novelaiSamplerSettings = document.getElementById('novelai-sampler-settings');
        this.novelaiNoiseScheduleSettings = document.getElementById('novelai-noise-schedule-settings');
        this.novelaiSeedSettings = document.getElementById('novelai-seed-settings');


        this.roleplayRulesTextarea = document.getElementById('roleplay-rules-textarea');
        this.publicInfoTextarea = document.getElementById('public-info-textarea');

        this.activeRoleTriggerList = document.getElementById('active-role-trigger-list');

    }
};
```
--- END OF FILE ui_elements.js ---


--- START OF FILE ui_settings.js ---
```javascript
const uiSettingsModule = {

    toggleSettings: () => {
        elementsModule.settingsPanel.classList.toggle('active');
        if (elementsModule.settingsPanel.classList.contains('active')) {
             uiSettingsModule.hideAllSettingPages();
             uiSettingsModule.showSection('settings-main-page');
             stateModule.pageStack = ['settings-main-page'];

             if (stateModule.isNovelInterfaceVisible) {
                 uiSettingsModule.novelUI_toggleNovelInterface();
             }
        } else {
            uiSettingsModule.hideAllSettingPages();
            stateModule.pageStack = [];
        }
    },

    showSection: async (sectionId) => {
        uiSettingsModule.hideAllSettingPages();
        const sectionElement = document.getElementById(sectionId);
        if (!sectionElement) {
            uiSettingsModule.showSection('settings-main-page');
            stateModule.pageStack = ['settings-main-page'];
            return;
        }


        let requiresChatroomData = [
            'role-list-page', 'story-mode-page', 'current-chatroom-settings-page', 'chat-room-detail-page',
            'chatroom-override-config-menu-page', 'chatroom-override-general-page', 'chatroom-override-drawingMaster-page',
            'chatroom-override-gameHost-page', 'chatroom-override-writingMaster-page', 'chatroom-override-characterUpdateMaster-page',
            'chatroom-override-privateAssistant-page'
        ].includes(sectionId);

        let needsRefresh = false;
        if (requiresChatroomData && !stateModule.currentChatroomDetails && stateModule.config.activeChatRoomName) {
             await apiModule.fetchChatroomDetails(stateModule.config.activeChatRoomName);
             needsRefresh = true;
        } else if (requiresChatroomData && stateModule.currentChatroomDetails && stateModule.config.activeChatRoomName !== stateModule.currentChatroomDetails.config.name) {
             await apiModule.fetchChatroomDetails(stateModule.config.activeChatRoomName);
             needsRefresh = true;
        }

        if (requiresChatroomData && !stateModule.currentChatroomDetails) {
             _logAndDisplayError("Cannot show chatroom-specific section: No active chatroom or details failed to load.", "showSection");

             uiSettingsModule.showSection('chat-room-directory-page');
             return;
        }


        sectionElement.classList.add('active');
        stateModule.activeSettingPage = sectionId;

        if (sectionId !== 'settings-main-page') {
            if (stateModule.pageStack[stateModule.pageStack.length - 1] !== sectionId) {
                stateModule.pageStack.push(sectionId);
            }
        } else {
            stateModule.pageStack = ['settings-main-page'];
        }


        if (sectionId === 'role-list-page') {
            uiSettingsModule.updateChatroomRolePage();
        } else if (sectionId === 'story-mode-page') {
            uiSettingsModule.updateChatroomNovelPage();
        } else if (sectionId === 'chat-room-directory-page') {
            uiSettingsModule.updateChatroomList();
        } else if (sectionId === 'current-chatroom-settings-page') {
            uiSettingsModule.updateWorldInfoDisplay();
            if (typeof uiChatModule !== 'undefined') {
                uiChatModule.updateChatroomHistoryDisplay();
            }
            uiSettingsModule.loadRoleplayRulesSetting();
            uiSettingsModule.loadPublicInfoSetting();
            uiSettingsModule.loadChatroomUserSetting();
        } else if (sectionId === 'general-config-page') {
            uiSettingsModule.loadOriginalNovelLengthSetting();
            uiSettingsModule.loadChatroomModelSetting();
            uiSettingsModule.loadSettingValue('responseSchemaJson');
            uiSettingsModule.loadSettingValue('responseSchemaParserJs');
            uiSettingsModule.loadSettingValue('sharedDatabaseInstruction');
            uiSettingsModule.loadChatroomMainPromptSetting();
        } else if (sectionId.endsWith('-master-page') && !sectionId.startsWith('chatroom-override-')) {
            const toolName = sectionId.replace('-page', '');
            const camelCaseToolName = toolName.replace(/-(\w)/g, (match, p1) => p1.toUpperCase());
            uiSettingsModule.loadGodSettings(camelCaseToolName);
        } else if (sectionId === 'novelai-settings-page') {
            uiSettingsModule.loadNovelAiSettings();
            uiSettingsModule.updateLastNaiPromptDisplay(stateModule.lastNaiPrompt);
        } else if (sectionId === 'api-settings-page') {
            uiSettingsModule.loadApiKeysSetting();
            uiSettingsModule.updateApiKeyFailureCountsDisplay();
        } else if (sectionId === 'prompt-preset-page') {
            uiSettingsModule.loadPromptPresetSettings();
            uiSettingsModule.renderPromptPresetsList();
        } else if (sectionId === 'chatroom-override-general-page') {
            uiSettingsModule.loadChatroomOverrideGeneralSettings();
        } else if (sectionId.startsWith('chatroom-override-') && sectionId.endsWith('-page')) {
            const match = sectionId.match(/^chatroom-override-(.+)-page$/);
            if (match && match[1]) {
                const toolName = match[1];
                uiSettingsModule.loadChatroomOverrideToolSettings(toolName);
            }
        }
    },

    hideAllSettingPages: () => {
        elementsModule.settingPages.forEach(page => page.classList.remove('active'));
        stateModule.activeSettingPage = null;
    },

    closeCurrentSection: (sectionId) => {
        const sectionElement = document.getElementById(sectionId);
        if (sectionElement) {
            sectionElement.classList.remove('active');

            if (stateModule.pageStack[stateModule.pageStack.length - 1] === sectionId) {
                stateModule.pageStack.pop();
            } else {
                 const index = stateModule.pageStack.indexOf(sectionId);
                 if (index > -1) {
                     stateModule.pageStack.splice(index, 1);
                 }
            }

            if (stateModule.pageStack.length > 0) {
                const previousPageId = stateModule.pageStack[stateModule.pageStack.length - 1];
                uiSettingsModule.showSection(previousPageId);
            } else {
                 if (elementsModule.settingsPanel.classList.contains('active')) {
                    uiSettingsModule.showSection('settings-main-page');
                    stateModule.pageStack = ['settings-main-page'];
                 } else {
                     stateModule.activeSettingPage = null;
                 }
            }
        }
    },

    loadApiKeysSetting: () => {
        elementsModule.apiKeyTextareaSettings.value = apiKeyManager.getApiKeys().join('\n');
    },

    saveApiKeysSetting: () => {
        const keys = elementsModule.apiKeyTextareaSettings.value.trim().split('\n').map(key => key.trim()).filter(key => key);
        apiKeyManager.setApiKeys(keys);
        uiSettingsModule.updateApiKeyFailureCountsDisplay();
    },

    updateApiKeyFailureCountsDisplay: () => {
        const displayElement = elementsModule.apiKeyFailureCountsDisplay;
        if (!displayElement) return;

        const failures = apiKeyManager.getApiKeyFailureCounts();
        const currentKeys = apiKeyManager.getApiKeys();
        displayElement.innerHTML = '';

        if (currentKeys.length === 0) {
            displayElement.innerHTML = '<div>No API Keys</div>';
            return;
        }

        currentKeys.forEach(key => {
            const count = failures[key] || 0;
            const keyDiv = document.createElement('div');
            const keyPrefixSpan = document.createElement('span');
            keyPrefixSpan.className = 'key-prefix';
            const displayKey = key.length > 10 ? `...${key.slice(-10)}:` : `${key}:`;
            keyPrefixSpan.textContent = displayKey;
            const countSpan = document.createElement('span');
            countSpan.className = 'fail-count';
            countSpan.textContent = `${count} fails`;

            keyDiv.appendChild(keyPrefixSpan);
            keyDiv.appendChild(countSpan);
            displayElement.appendChild(keyDiv);
        });
    },

    loadSettingValue: (settingKey) => {
        let elementIdSuffix = 'Settings';
        const element = elementsModule[`${settingKey}${elementIdSuffix}`];

        if (element) {
            if (settingKey === 'originalNovelLength') {
                 element.value = stateModule.config.originalNovelLength || defaultConfig.originalNovelLength;
             } else if (['responseSchemaJson', 'responseSchemaParserJs', 'sharedDatabaseInstruction', 'mainPrompt'].includes(settingKey)) {
                 element.value = stateModule.config[settingKey] || '';
             } else if (settingKey === 'novelaiApiKey') {
                 element.value = apiKeyManager.getNaiApiKey();
             } else if (stateModule.config.hasOwnProperty(settingKey)) {
                  element.value = stateModule.config[settingKey] || '';
             }
        }
    },

    _createChatroomRoleListItem: (roleName, roleState, isTemporary) => {
        const roleItem = document.createElement('div');
        roleItem.className = 'role-item';
        roleItem.dataset.roleName = roleName;

        const isPermanent = !isTemporary && roleName !== "管理员";
        if (isPermanent) {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'role-visibility-checkbox';
            checkbox.dataset.roleName = roleName;
            const chatroomDetails = stateModule.currentChatroomDetails;
            checkbox.checked = chatroomDetails?.config?.roleVisibility?.[roleName] ?? true;
            roleItem.appendChild(checkbox);
        }

        const nameSpan = document.createElement('span');
        nameSpan.textContent = roleName + (isTemporary ? " (临时)" : "");
        nameSpan.style.marginLeft = isPermanent ? '8px' : '0';
        nameSpan.addEventListener('click', () => {
            uiSettingsModule.showRoleDetailPage(roleName);
        });

        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'item-actions';

        if (!isTemporary && roleName !== '管理员') {
            const renameButton = document.createElement('div');
            renameButton.className = 'std-button item-rename';
            renameButton.textContent = '✎';
            renameButton.style.width = '28px';
            renameButton.style.height = '28px';

            const deleteButton = document.createElement('div');
            deleteButton.className = 'std-button item-delete';
            deleteButton.textContent = '✕';
            deleteButton.style.width = '28px';
            deleteButton.style.height = '28px';

            actionsDiv.appendChild(renameButton);
            actionsDiv.appendChild(deleteButton);
        }

        roleItem.appendChild(nameSpan);
        roleItem.appendChild(actionsDiv);

        return roleItem;
    },

    updateChatroomRolePage: () => {
        const container = elementsModule.roleListContainer;
        const chatroomDetails = stateModule.currentChatroomDetails;

        if (!container) return;
        if (!chatroomDetails || !chatroomDetails.config) {
            container.innerHTML = '<p style="text-align: center;">请先选择一个聊天室。</p>';
            return;
        }
        container.innerHTML = '';


        const roleStates = chatroomDetails.config.roleStates || {};
        const permanentRoles = new Set(chatroomDetails.roles.map(r => r.name));
        const allRoleNames = Object.keys(roleStates);

        const sortedRoleNames = allRoleNames.sort((a, b) => {
            const isTempA = !permanentRoles.has(a);
            const isTempB = !permanentRoles.has(b);
            if (isTempA && !isTempB) return -1;
            if (!isTempA && isTempB) return 1;
            if (a === "管理员") return -1;
            if (b === "管理员") return 1;
            return a.localeCompare(b);
        });

        if(sortedRoleNames.length === 0){
             const noRolesMsg = document.createElement('p');
             noRolesMsg.textContent = '暂无角色。';
             noRolesMsg.style.textAlign = 'center';
             container.appendChild(noRolesMsg);
        } else {
            const frag = document.createDocumentFragment();
            sortedRoleNames.forEach(roleName => {
                const isTemporary = !permanentRoles.has(roleName);
                frag.appendChild(uiSettingsModule._createChatroomRoleListItem(roleName, roleStates[roleName], isTemporary));
            });
            container.appendChild(frag);
        }
    },

    showRoleDetailPage: (roleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !chatroomDetails.config || !chatroomDetails.config.roleStates || !(roleName in chatroomDetails.config.roleStates)) {
             _logAndDisplayError(`无法显示角色详情：未找到角色 "${roleName}" 或聊天室数据。`, 'showRoleDetailPage');
             uiSettingsModule.showSection('role-list-page');
             return;
        }

        stateModule.currentRole = roleName;
        const roleData = chatroomDetails.roles.find(r => r.name === roleName);
        const isTemporary = !roleData;

        elementsModule.roleDetailHeaderTitle.textContent = `角色详情 - ${roleName}` + (isTemporary ? " (临时)" : "");
        uiSettingsModule.loadRoleSettings(roleName, roleData, isTemporary);
        uiSettingsModule.showSection('role-detail-page');
    },

    loadRoleSettings: (roleName, roleData, isTemporary) => {
        elementsModule.roleInstructionTextarea.value = roleData?.setting || (isTemporary ? '[临时角色无设定]' : '');
        elementsModule.roleMemoryTextarea.value = roleData?.memory || (isTemporary ? '[临时角色无记忆]' : '');
        elementsModule.roleDrawingTemplateSettings.value = roleData?.drawingTemplate || (isTemporary ? '[临时角色无模板]' : '');

        const detailedState = stateModule.currentChatroomDetails?.config?.roleDetailedStates?.[roleName] || '';
        elementsModule.roleStateTextarea.value = detailedState;
        elementsModule.roleStateTextarea.readOnly = true;

        const isReadOnly = isTemporary || roleName === "管理员";
        [elementsModule.roleInstructionTextarea, elementsModule.roleMemoryTextarea, elementsModule.roleDrawingTemplateSettings].forEach(el => {
            el.readOnly = isReadOnly;
            el.style.cursor = isReadOnly ? 'not-allowed' : 'auto';
            el.style.opacity = isReadOnly ? 0.7 : 1;
        });

        if (elementsModule.exportRoleButton) elementsModule.exportRoleButton.style.display = isReadOnly ? 'none' : 'block';

    },

    saveRoleSettings: async () => {
        const roleName = stateModule.currentRole;
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !roleName) return;

        const roleData = chatroomDetails.roles.find(r => r.name === roleName);
        const isTemporary = !roleData;

        if (isTemporary || roleName === "管理员") return;

        const updatedRoleData = {
            name: roleName,
            setting: elementsModule.roleInstructionTextarea.value,
            memory: elementsModule.roleMemoryTextarea.value,
            drawingTemplate: elementsModule.roleDrawingTemplateSettings.value,
        };

        const success = await apiModule.updateRole(chatroomDetails.config.name, roleName, updatedRoleData);
        if (success) {

            const roleIndex = chatroomDetails.roles.findIndex(r => r.name === roleName);
            if (roleIndex > -1) {
                 Object.assign(chatroomDetails.roles[roleIndex], updatedRoleData);
            } else {
                 await apiModule.fetchChatroomDetails(chatroomDetails.config.name);
            }
            updateChatContextCache();
        } else {
            _logAndDisplayError(`Failed to save settings for role ${roleName}`, 'saveRoleSettings');
            alert(`保存角色 ${roleName} 设置失败`);

             await apiModule.fetchChatroomDetails(chatroomDetails.config.name);
             uiSettingsModule.loadRoleSettings(roleName, chatroomDetails.roles.find(r => r.name === roleName), false);
        }
    },

    deleteChatroomRole: async (roleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || roleName === "管理员") return;

        const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
        let proceedToDelete = false;

        if (isPermanent) {

            proceedToDelete = true;
        } else {

            return;
        }

        if (proceedToDelete) {
            let success = false;
            if (isPermanent) {
                success = await apiModule.deleteRole(chatroomDetails.config.name, roleName);
            } else {

                delete chatroomDetails.config.roleStates[roleName];
                if (chatroomDetails.config.roleDetailedStates) {
                    delete chatroomDetails.config.roleDetailedStates[roleName];
                }
                success = await apiModule.updateChatroomConfig(chatroomDetails.config.name, {
                    roleStates: chatroomDetails.config.roleStates,
                    roleDetailedStates: chatroomDetails.config.roleDetailedStates || {}
                });
            }

            if (success) {
                await apiModule.fetchChatroomDetails(chatroomDetails.config.name);
                uiSettingsModule.updateChatroomRolePage();
                if (typeof uiChatModule !== 'undefined' && uiChatModule.updateRoleButtonsList) {
                    uiChatModule.updateRoleButtonsList();
                }
                if (stateModule.currentRole === roleName) {
                    stateModule.currentRole = null;
                    uiSettingsModule.closeCurrentSection('role-detail-page');
                }
                updateChatContextCache();
            } else {
                _logAndDisplayError(`Failed to delete role ${roleName}`, 'deleteChatroomRole');
                alert(`删除角色 ${roleName} 失败`);
            }
        }
    },


    renameChatroomRole: async (oldName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) return;
        const roleData = chatroomDetails.roles.find(r => r.name === oldName);
        const isTemporary = !roleData;

        if (isTemporary || oldName === "管理员") return;

        const newName = prompt(`输入角色 "${oldName}" 的新名称:`, oldName);
        if (!newName || newName.trim() === "" || newName === oldName) {
            return;
        }
        const trimmedNewName = newName.trim();
        const nameExists = Object.keys(chatroomDetails.config.roleStates || {}).includes(trimmedNewName);

        if (nameExists) {
            _logAndDisplayError(`名称 "${trimmedNewName}" 已在此聊天室存在。`, 'renameChatroomRole');
            return;
        }

        const updatedRoleData = { ...roleData, name: trimmedNewName };
        const success = await apiModule.updateRole(chatroomDetails.config.name, oldName, updatedRoleData);

        if (success) {

            await apiModule.fetchChatroomDetails(chatroomDetails.config.name);

            stateModule.currentChatHistoryData.forEach(msg => {
                if (msg.roleName === oldName) msg.roleName = trimmedNewName;
                if (msg.targetRoleName === oldName) msg.targetRoleName = trimmedNewName;
            });
            if (stateModule.config.activeChatRoomName) {
                 uiChatModule.saveChatHistoryToServer();
            }

            if (stateModule.currentRole === oldName) {
                stateModule.currentRole = trimmedNewName;
                if (document.getElementById('role-detail-page').classList.contains('active')) {
                    elementsModule.roleDetailHeaderTitle.textContent = `角色详情 - ${trimmedNewName}`;
                    uiSettingsModule.loadRoleSettings(trimmedNewName, updatedRoleData, false);
                }
            }

            uiSettingsModule.updateChatroomRolePage();
            if (typeof uiChatModule !== 'undefined') {
                 uiChatModule.updateRoleButtonsList();
                 if (stateModule.config.activeChatRoomName === chatroomDetails.config.name) {
                 }
            }
            updateChatContextCache();
        } else {
             _logAndDisplayError(`Failed to rename role ${oldName} to ${trimmedNewName}`, 'renameChatroomRole');
             alert(`重命名角色失败`);
        }
    },

    addChatroomRole: async () => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) return;

        const newRoleName = prompt("请输入新角色名称:");
        if (newRoleName && newRoleName.trim() !== "") {
            const trimmedName = newRoleName.trim();
            const nameExists = Object.keys(chatroomDetails.config.roleStates || {}).includes(trimmedName);
            if(nameExists) {
                 _logAndDisplayError(`角色名称 "${trimmedName}" 已存在于当前聊天室。`, 'addChatroomRole');
                 return;
            }

            const newRoleData = {
                name: trimmedName,
                setting: "",
                memory: "",
                drawingTemplate: ""
            };

            const success = await apiModule.createRole(chatroomDetails.config.name, newRoleData);
            if (success) {

                 await apiModule.fetchChatroomDetails(chatroomDetails.config.name);
                 uiSettingsModule.updateChatroomRolePage();
                 if (typeof uiChatModule !== 'undefined') {
                     uiChatModule.updateRoleButtonsList();
                 }
                 updateChatContextCache();
            } else {

                 alert(`添加角色失败`);
            }
        } else if (newRoleName) {
            _logAndDisplayError(`角色名称 "${newRoleName}" 无效。`, 'addChatroomRole');
        }
    },

    updateWorldInfoDisplay: () => {
        const worldInfo = stateModule.chatContextCache?.worldInfo || "[世界信息未获取]";
        if (elementsModule.worldInfoDisplay) {
            elementsModule.worldInfoDisplay.value = worldInfo;
            elementsModule.worldInfoDisplay.scrollTop = 0;
        }
    },

    loadOriginalNovelLengthSetting: () => {
        if (elementsModule.originalNovelLengthSettings) {
            elementsModule.originalNovelLengthSettings.value = stateModule.config.originalNovelLength || defaultConfig.originalNovelLength;
        }
    },

    saveOriginalNovelLengthSetting: () => {
        if (elementsModule.originalNovelLengthSettings) {
             const value = parseInt(elementsModule.originalNovelLengthSettings.value);
             if (!isNaN(value) && value > 0) {
                 stateModule.config.originalNovelLength = value;
                 if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                    mainModule.triggerDebouncedSave();
                 }
             } else {
                 stateModule.config.originalNovelLength = defaultConfig.originalNovelLength;
                 elementsModule.originalNovelLengthSettings.value = stateModule.config.originalNovelLength;
                 _logAndDisplayError("Please enter a valid positive integer for character count. Reset to default.", "saveOriginalNovelLengthSetting");
             }
        }
    },

    loadNovelAiSettings: () => {
        const keys = [
            "novelaiModel", "novelaiArtistChain",
            "novelaiDefaultPositivePrompt", "novelaiDefaultNegativePrompt",
            "novelaiWidth", "novelaiHeight", "novelaiSteps", "novelaiScale",
            "novelaiCfgRescale", "novelaiSampler", "novelaiNoiseSchedule", "novelaiSeed"
        ];
        if (elementsModule.novelaiApiKeySettings) {
            elementsModule.novelaiApiKeySettings.value = apiKeyManager.getNaiApiKey();
        }
        keys.forEach(key => {
            const elementKey = `${key}Settings`;
            const element = elementsModule[elementKey];
            if (element) {
                if (element.type === 'number') {
                    element.value = Number(stateModule.config[key] ?? defaultConfig[key]);
                } else {
                    element.value = stateModule.config[key] ?? defaultConfig[key];
                }
            }
        });
    },

    saveNovelAiSetting: (key) => {
         const elementKey = `${key}Settings`;
         const element = elementsModule[elementKey];
         if (element) {
             let value = element.value;
             if (key === 'novelaiApiKey') {
                 apiKeyManager.setNaiApiKey(value);
             } else {
                 if (element.type === 'number') {
                     value = Number(value);
                     const min = parseFloat(element.min);
                     const max = parseFloat(element.max);
                     if (!isNaN(min) && value < min) value = min;
                     if (!isNaN(max) && value > max) value = max;
                 }
                 stateModule.config[key] = value;
                 if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                    mainModule.triggerDebouncedSave();
                 }
             }
         }
    },

    updateLastNaiPromptDisplay: (promptText) => {
         if (elementsModule.novelaiLastPromptDisplay) {
             elementsModule.novelaiLastPromptDisplay.value = promptText || "";
             elementsModule.novelaiLastPromptDisplay.scrollTop = 0;
         }
    },

    _createChatroomListItem: (roomName) => {
        const item = document.createElement('div');
        item.className = 'chatroom-item';
        item.dataset.roomName = roomName;

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'activeChatroom';
        radio.value = roomName;
        radio.id = `chatroom-${roomName}`;
        if (roomName === stateModule.config.activeChatRoomName) radio.checked = true;
        radio.addEventListener('change', () => {
            if (radio.checked) {
                uiSettingsModule.switchActiveChatroom(roomName);
            }
        });

        const label = document.createElement('label');
        label.textContent = roomName;
        label.setAttribute('for', `chatroom-${roomName}`);
         label.addEventListener('click', (e) => {
             if (!radio.checked) {
                  radio.checked = true;
                  uiSettingsModule.switchActiveChatroom(roomName);
             }
             uiSettingsModule.showChatroomDetailPage(roomName);
         });

        item.appendChild(radio);
        item.appendChild(label);

        return item;
    },

    updateChatroomList: () => {
        const frag = document.createDocumentFragment();
        const rooms = stateModule.config.chatRoomOrder || [];
        rooms.forEach(roomName => {
            frag.appendChild(uiSettingsModule._createChatroomListItem(roomName));
        });
        elementsModule.chatroomListContainer.innerHTML = '';
        elementsModule.chatroomListContainer.appendChild(frag);
    },

    switchActiveChatroom: async (name) => {
        if (stateModule.config.activeChatRoomName === name && stateModule.currentChatroomDetails) {
            return;
        }

        if (typeof uiChatModule !== 'undefined' && uiChatModule.saveChatHistoryToServer) {
             if(stateModule.config.activeChatRoomName) {
                 await uiChatModule.saveChatHistoryToServer();
             }
        }

        stateModule.config.activeChatRoomName = name;
        stateModule.currentChatroomDetails = null;
        if (typeof mainModule !== 'undefined') mainModule.triggerDebouncedSave();


        if (elementsModule.chatArea) elementsModule.chatArea.innerHTML = '<p style="text-align: center;">Loading...</p>';
        if (elementsModule.roleButtonsListContainer) elementsModule.roleButtonsListContainer.innerHTML = '';
        if (elementsModule.chatContainer) elementsModule.chatContainer.style.backgroundImage = '';


        await apiModule.fetchChatroomDetails(name);


        if (stateModule.currentChatroomDetails) {
            if (typeof uiChatModule !== 'undefined') {
                uiChatModule.loadChatHistory(name);
                uiChatModule.updateRoleButtonsList();
                uiChatModule.updateChatroomHistoryDisplay();
            }
            const radio = document.getElementById(`chatroom-${name}`);
            if (radio && !radio.checked) radio.checked = true;

            if (document.getElementById('general-config-page').classList.contains('active')) {
                uiSettingsModule.loadChatroomModelSetting();
                uiSettingsModule.loadSettingValue('responseSchemaJson');
                uiSettingsModule.loadSettingValue('responseSchemaParserJs');
                uiSettingsModule.loadSettingValue('sharedDatabaseInstruction');
                uiSettingsModule.loadChatroomMainPromptSetting();
            }
            if (document.getElementById('role-list-page').classList.contains('active')) {
                uiSettingsModule.updateChatroomRolePage();
            }
            if (document.getElementById('story-mode-page').classList.contains('active')) {
                uiSettingsModule.updateChatroomNovelPage();
            }
            if (document.getElementById('current-chatroom-settings-page').classList.contains('active')) {
                 uiSettingsModule.loadRoleplayRulesSetting();
                 uiSettingsModule.loadPublicInfoSetting();
                 uiSettingsModule.loadChatroomUserSetting();
            }

            stateModule.currentNovelId = null;
            if (elementsModule.novelContentDisplay) {
                 elementsModule.novelContentDisplay.innerHTML = '<p style="text-align: center; padding-top: 20px;">请在书目(📚)中选择小说</p>';
                 elementsModule.novelContentDisplay.scrollTop = 0;
                 elementsModule.novelContentDisplay.removeAttribute('data-novel-id');
            }
            if(stateModule.isNovelInterfaceVisible) {
                if (stateModule.activeNovelPage === 'novel-bookshelf-page') {
                    uiSettingsModule.novelUI_updateBookshelfPage();
                }
                if (stateModule.activeNovelPage === 'novel-toc-page' && elementsModule.novelTocListContainer) {
                     elementsModule.novelTocListContainer.innerHTML = '';
                }
            }

             const backgroundFilename = stateModule.currentChatroomDetails.config.backgroundImageFilename;
             if (backgroundFilename && elementsModule.chatContainer) {
                 const bgUrl = `/chatrooms/${encodeURIComponent(name)}/${encodeURIComponent(backgroundFilename)}?t=${Date.now()}`;
                 elementsModule.chatContainer.style.backgroundImage = `url('${bgUrl}')`;
             }

        } else {

             if (typeof uiChatModule !== 'undefined') {
                 uiChatModule.clearChatArea();
                 uiChatModule.updateRoleButtonsList();
             }

        }
    },

    showChatroomDetailPage: async (name) => {
         if (!stateModule.currentChatroomDetails || stateModule.currentChatroomDetails.config.name !== name) {
             await apiModule.fetchChatroomDetails(name);
         }

         if (!stateModule.currentChatroomDetails) {
             uiSettingsModule.showSection('chat-room-directory-page');
             _logAndDisplayError(`Chatroom "${name}" details could not be loaded.`, 'showChatroomDetailPage');
             return;
         }
        stateModule.currentChatRoom = name;
        elementsModule.chatroomDetailHeaderTitle.textContent = `聊天室详情 - ${name}`;

        uiSettingsModule.showSection('chat-room-detail-page');
    },

    addChatroom: async () => {
        const name = prompt("请输入新聊天室名称:");
        if (!name || name.trim() === "") return;
        const trimmedName = name.trim();

        const newName = await apiModule.addChatroom(trimmedName);
        if (newName) {
            uiSettingsModule.updateChatroomList();
            uiSettingsModule.switchActiveChatroom(newName);

        } else {
             alert(`Failed to create chatroom '${trimmedName}'. Check console for errors.`);
        }
    },


    handleRenameChatroom: async () => {
        const oldName = stateModule.currentChatRoom;
        if (!oldName) return;
        const newName = prompt(`输入聊天室 "${oldName}" 的新名称:`, oldName);
        if (!newName || newName.trim() === "" || newName === oldName) return;
        const trimmedNewName = newName.trim();

        const success = await apiModule.renameChatroom(oldName, trimmedNewName);
        if (success) {
             uiSettingsModule.updateChatroomList();

             if (stateModule.config.activeChatRoomName === trimmedNewName) {
                await uiSettingsModule.switchActiveChatroom(trimmedNewName);
             }
              if (document.getElementById('chat-room-detail-page')?.classList.contains('active')) {
                   elementsModule.chatroomDetailHeaderTitle.textContent = `聊天室详情 - ${trimmedNewName}`;
              }

        } else {
             alert(`Failed to rename chatroom. Check console for errors.`);
        }
    },

    handleDeleteChatroom: async () => {
         const nameToDelete = stateModule.currentChatRoom;
         if (!nameToDelete) return;

         const success = await apiModule.deleteChatroom(nameToDelete);
         if (success) {
              uiSettingsModule.updateChatroomList();
              if (stateModule.config.activeChatRoomName === null) {

                 if (typeof uiChatModule !== 'undefined') {
                     uiChatModule.clearChatArea();
                     uiChatModule.updateRoleButtonsList();
                 }
                 stateModule.currentChatroomDetails = null;
                 updateChatContextCache();
                 if (elementsModule.chatContainer) elementsModule.chatContainer.style.backgroundImage = '';
              } else {
                 await uiSettingsModule.switchActiveChatroom(stateModule.config.activeChatRoomName);
              }
              uiSettingsModule.closeCurrentSection('chat-room-detail-page');

         } else {
              alert(`Failed to delete chatroom '${nameToDelete}'. Check console.`);
         }

    },

    clearCurrentChatroomHistory: async () => {
        const activeChatroomName = stateModule.config.activeChatRoomName;
        if (!activeChatroomName || !stateModule.currentChatroomDetails) {
             return;
        }

         if (typeof uiChatModule !== 'undefined') {
             uiChatModule.clearChatArea();
         }

         try {
             const response = await fetch(`/history/${encodeURIComponent(activeChatroomName)}`, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify([])
             });
             if (!response.ok) {
                 throw new Error(`Failed to clear history file: ${response.status}`);
             }
         } catch (error) {
             _logAndDisplayError(`清空历史记录文件失败: ${error.message}`, 'clearCurrentChatroomHistory');
         }

         let rolesUpdated = false;
         const currentStates = stateModule.currentChatroomDetails.config.roleStates || {};
         const permanentRoles = new Set(stateModule.currentChatroomDetails.roles.map(r => r.name));
         const newStates = {};
         const newDetailedStates = { ...(stateModule.currentChatroomDetails.config.roleDetailedStates || {}) };

         for (const roleName in currentStates) {
             if (roleName === "管理员" || permanentRoles.has(roleName)) {
                 newStates[roleName] = currentStates[roleName];
             } else {
                  rolesUpdated = true;
                  delete newDetailedStates[roleName];
             }
         }

         let detailedStatesCleared = false;
         for (const roleName in newStates) {
             if (roleName !== "管理员" && permanentRoles.has(roleName)) {
                 if (newDetailedStates[roleName] !== undefined && newDetailedStates[roleName] !== "") {
                     newDetailedStates[roleName] = "";
                     detailedStatesCleared = true;
                 }
             }
         }

         if (rolesUpdated || detailedStatesCleared ) {
              const updateSuccess = await apiModule.updateChatroomConfig(activeChatroomName, { roleStates: newStates, roleDetailedStates: newDetailedStates });
              if (updateSuccess) {
                 stateModule.currentChatroomDetails.config.roleStates = newStates;
                 stateModule.currentChatroomDetails.config.roleDetailedStates = newDetailedStates;
                 if (typeof uiChatModule !== 'undefined') uiChatModule.updateRoleButtonsList();
                 uiSettingsModule.updateChatroomRolePage();
                 if (stateModule.currentRole && permanentRoles.has(stateModule.currentRole) && stateModule.currentRole !== "管理员") {
                    if (document.getElementById('role-detail-page')?.classList.contains('active')) {
                         uiSettingsModule.loadRoleSettings(stateModule.currentRole, stateModule.currentChatroomDetails.roles.find(r=>r.name===stateModule.currentRole), false);
                    }
                 }
              } else {
                  _logAndDisplayError("Failed to save updated role states after clearing history.", 'clearCurrentChatroomHistory');
              }
         }

         if (typeof uiChatModule !== 'undefined') {
             uiChatModule.updateChatroomHistoryDisplay();
         }
          await updateChatContextCache();
          uiSettingsModule.updateWorldInfoDisplay();
    },

    loadGodSettings: (godName) => {
        const settings = ['responseSchemaJson', 'responseSchemaParserJs', 'toolDatabaseInstruction', 'enabled', 'model', 'mainPrompt'];
        if (godName === 'drawingMaster') {
            settings.push('novelContent');
        }
        const toolConfig = stateModule.config.toolSettings[godName];

        settings.forEach(type => {
            const camelCaseType = type.charAt(0).toUpperCase() + type.slice(1);
            let elementIdSuffix = 'Settings';
            let elId;
            if (type === 'toolDatabaseInstruction') {
                 elementIdSuffix = 'ToolDatabaseInstructionSettings';
                 elId = `${godName}${elementIdSuffix}`;
            } else if (type === 'model') {
                 elementIdSuffix = 'ModelSettings';
                 elId = `${godName}${elementIdSuffix}`;
            } else {
                 elementIdSuffix = `${camelCaseType}Settings`;
                 elId = `${godName}${elementIdSuffix}`;
            }
            const el = elementsModule[elId];

            if (el) {
                const val = toolConfig ? toolConfig[type] : undefined;
                if (el.type === 'checkbox') {
                    el.checked = val ?? false;
                } else if (el.tagName === 'SELECT') {
                    el.value = val || '';
                    if (!val && el.options.length > 0 && el.options[0].disabled) {

                    } else if (val && !el.querySelector(`option[value="${val}"]`)) {
                         const tempOption = new Option(`${val} (Saved)`, val, true, true);
                         el.add(tempOption, 0);
                    }
                } else {
                    el.value = val || '';
                }
            }
        });
    },


    saveGodSettings: (godName) => {
        if (!stateModule.config.toolSettings[godName]) {
            stateModule.config.toolSettings[godName] = {};
        }
        const settings = ['responseSchemaJson', 'responseSchemaParserJs', 'toolDatabaseInstruction', 'enabled', 'model', 'mainPrompt'];
        if (godName === 'drawingMaster') {
            settings.push('novelContent');
        }
        settings.forEach(type => {
            const camelCaseType = type.charAt(0).toUpperCase() + type.slice(1);
             let elementIdSuffix = 'Settings';
             if (type === 'toolDatabaseInstruction') {
                  elementIdSuffix = 'ToolDatabaseInstructionSettings';
             } else if (type === 'model') {
                  elementIdSuffix = 'ModelSettings';
             } else {
                  elementIdSuffix = `${camelCaseType}Settings`;
             }
            const elId = `${godName}${elementIdSuffix}`;
            const el = elementsModule[elId];
            if (el) {
                stateModule.config.toolSettings[godName][type] = (el.type === 'checkbox') ? el.checked : el.value;
            }
        });
        if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
            mainModule.triggerDebouncedSave();
        }
    },

    displayErrorLog: (errorMessages) => {

    },

    clearErrorLogDisplay: () => {

    },

    copyErrorLog: () => {
        const logContent = elementsModule.errorLogDisplay?.value;
        if (logContent && navigator.clipboard) {
            navigator.clipboard.writeText(logContent).then(() => {

            }).catch(err => {
                _logAndDisplayError(`Failed to copy error log: ${err}`, 'copyErrorLog');

                alert('Failed to copy error log. See console.');
            });
        } else if (!logContent) {
            _logAndDisplayError('Error log is empty, nothing to copy.', 'copyErrorLog');
        } else {
            _logAndDisplayError('Clipboard API not available.', 'copyErrorLog');
            alert('Clipboard API not available in this browser.');
        }
    },

    clearAllConfiguration: async () => {

         try {
             const response = await fetch('/clear-all-config', { method: 'POST' });
             const result = await response.json();
             if (!response.ok) {
                 throw new Error(result.error || `HTTP error! status: ${response.status}`);
             }


             location.reload();
         } catch (error) {
             _logAndDisplayError(`清除全部配置失败: ${error.message}`, 'clearAllConfiguration');
             alert(`清除全部配置失败: ${error.message}`);
         }

    },

    exportConfiguration: () => {
        if (typeof uiChatModule !== 'undefined' && uiChatModule.saveChatHistoryToServer) {
            uiChatModule.saveChatHistoryToServer();
        }
        window.location.href = '/export-full-config-zip';
    },

    importConfiguration: () => {
        elementsModule.importConfigFile.click();
    },

    handleImportConfig: async (event) => {
         const file = event.target.files[0];
         if (!file) return;
         if (!file.name.toLowerCase().endsWith('.zip')) {
              _logAndDisplayError('请选择一个 .zip 文件进行导入。', 'handleImportConfig');
              alert('请选择一个 .zip 文件进行导入。');
              event.target.value = null;
              return;
         }

         const formData = new FormData();
         formData.append('config_zip', file);

         try {
              const response = await fetch('/import-full-config-zip', {
                  method: 'POST',
                  body: formData,
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! status: ${response.status}`);
              }

              alert(result.message || "配置导入成功！");

              await configModule.loadConfig();

              initializationModule.initializeConfig();

         } catch (error) {
              _logAndDisplayError(`导入配置失败: ${error.message}`, 'handleImportConfig');
              alert(`导入配置失败: ${error.message}`);
         } finally {
             event.target.value = null;
         }
    },

    addChatroomNovel: async () => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) {
            _logAndDisplayError("请先选择一个聊天室。", 'addChatroomNovel');
            return;
        }
        const roomName = chatroomDetails.config.name;

        const name = prompt("请输入新小说名称:");
        if (!name || name.trim() === "") return;
        const trimmedName = name.trim();

        const nameExists = chatroomDetails.novels.some(n => n.name === trimmedName);
        if (nameExists) {
            _logAndDisplayError(`小说名称 "${trimmedName}" 在当前聊天室已存在。`, 'addChatroomNovel');
            return;
        }

        const text = prompt(`请在此粘贴小说《${trimmedName}》的内容:`);
        if (text === null) return;
        if (!text) { _logAndDisplayError("小说内容不能为空。", 'addChatroomNovel'); return; }

        try {
            const processResponse = await fetch('/process-novel-content', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: text })
            });
             if (!processResponse.ok) {
                 const errorData = await processResponse.json().catch(() => ({ error: `HTTP error! status: ${processResponse.status}` }));
                 throw new Error(errorData.error || `HTTP error! status: ${processResponse.status}`);
             }
            const processedData = await processResponse.json();

            const newNovel = {
                id: `novel-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
                name: trimmedName,
                segments: processedData.segments,
                toc: processedData.toc
            };

             const createSuccess = await apiModule.createNovel(roomName, newNovel);
             if (createSuccess) {
                  await apiModule.fetchChatroomDetails(roomName);
                  uiSettingsModule.updateChatroomNovelPage();
                  if (stateModule.isNovelInterfaceVisible && stateModule.activeNovelPage === 'novel-bookshelf-page') {
                      uiSettingsModule.novelUI_updateBookshelfPage();
                  }

             } else {
                  alert(`添加小说文件失败，请检查控制台。`);
             }
        } catch (error) {
             _logAndDisplayError(`添加小说失败: ${error.message}`, 'addChatroomNovel');

        }
    },

    renameChatroomNovel: async (novelId, currentName) => {
         const chatroomDetails = stateModule.currentChatroomDetails;
         if (!chatroomDetails) return;
         const roomName = chatroomDetails.config.name;

         const novelIndex = chatroomDetails.novels.findIndex(n => n.id === novelId);
         if (novelIndex === -1) {
             _logAndDisplayError(`无法找到要重命名的小说，ID: ${novelId}`, 'renameChatroomNovel');
             return;
         }
         const novelData = chatroomDetails.novels[novelIndex];

         const newName = prompt(`输入小说 "${currentName}" 的新名称:`, currentName);
         if (!newName || newName.trim() === "" || newName === currentName) return;
         const trimmedNewName = newName.trim();

         const nameExists = chatroomDetails.novels.some(n => n.name === trimmedNewName && n.id !== novelId);
         if (nameExists) {
             _logAndDisplayError(`小说名称 "${trimmedNewName}" 在当前聊天室已存在。`, 'renameChatroomNovel');
             return;
         }

         const updatedNovelData = { ...novelData, name: trimmedNewName };
         const success = await apiModule.updateNovel(roomName, novelId, updatedNovelData);

         if (success) {
             await apiModule.fetchChatroomDetails(roomName);
             uiSettingsModule.updateChatroomNovelPage();
             if (stateModule.isNovelInterfaceVisible && stateModule.activeNovelPage === 'novel-bookshelf-page') {
                 uiSettingsModule.novelUI_updateBookshelfPage();
             }

         } else {
              alert(`重命名小说失败，请检查控制台。`);
         }
     },

    deleteChatroomNovel: async (novelId, novelName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) return;
        const roomName = chatroomDetails.config.name;

        const novelIndex = chatroomDetails.novels.findIndex(n => n.id === novelId);
        if (novelIndex === -1) {
             _logAndDisplayError(`未在当前聊天室找到小说 "${novelName}"，无法删除。`, "deleteChatroomNovel");
             return;
        }


         const success = await apiModule.deleteNovel(roomName, novelId);
         if (success) {

              await apiModule.fetchChatroomDetails(roomName);

              if (stateModule.currentNovelId === novelId) {
                  stateModule.currentNovelId = null;
                  stateModule.config.lastViewedNovelId = null;
                  if (elementsModule.novelContentDisplay) {
                      elementsModule.novelContentDisplay.innerHTML = '<p style="text-align: center; padding-top: 20px;">请在书目(📚)中选择小说</p>';
                      elementsModule.novelContentDisplay.scrollTop = 0;
                      elementsModule.novelContentDisplay.removeAttribute('data-novel-id');
                  }
                  if (typeof mainModule !== 'undefined') mainModule.triggerDebouncedSave();
              }

              uiSettingsModule.updateChatroomNovelPage();
              if (stateModule.isNovelInterfaceVisible && stateModule.activeNovelPage === 'novel-bookshelf-page') {
                  uiSettingsModule.novelUI_updateBookshelfPage();
              }

         } else {
              alert(`删除小说失败，请检查控制台。`);
         }

    },

    _createChatroomNovelListItem: (novel) => {
        const item = document.createElement('div');
        item.className = 'novel-item';
        item.dataset.novelId = novel.id;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'novel-name';
        nameSpan.textContent = novel.name;

        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'item-actions';

        const renameButton = document.createElement('div');
        renameButton.className = 'std-button item-rename';
        renameButton.textContent = '✎';
        renameButton.style.width = '28px';
        renameButton.style.height = '28px';

        const deleteButton = document.createElement('div');
        deleteButton.className = 'std-button item-delete';
        deleteButton.textContent = '✕';
        deleteButton.style.width = '28px';
        deleteButton.style.height = '28px';

        actionsDiv.appendChild(renameButton);
        actionsDiv.appendChild(deleteButton);

        item.appendChild(nameSpan);
        item.appendChild(actionsDiv);

        return item;
    },

    updateChatroomNovelPage: () => {
        const container = elementsModule.novelListContainer;
        const chatroomDetails = stateModule.currentChatroomDetails;

        if (!container) return;
        if (!chatroomDetails) {
            container.innerHTML = '<p style="text-align: center;">请先选择一个聊天室。</p>';
            return;
        }
        container.innerHTML = '';

        const addNovelButton = document.createElement('div');
        addNovelButton.id = 'add-chatroom-novel-button';
        addNovelButton.className = 'settings-menu-item';
        addNovelButton.textContent = '十 添加小说 (从剪贴板)';
        addNovelButton.addEventListener('click', uiSettingsModule.addChatroomNovel);
        container.appendChild(addNovelButton);

        const novels = chatroomDetails.novels || [];
        const sortedNovels = [...novels].sort((a, b) => (a.name || '').localeCompare(b.name || ''));

        if (sortedNovels.length === 0) {
            const noNovelsMsg = document.createElement('p');
            noNovelsMsg.textContent = '此聊天室暂无小说。';
            noNovelsMsg.style.textAlign = 'center';
            container.appendChild(noNovelsMsg);
        } else {
            const fragment = document.createDocumentFragment();
            sortedNovels.forEach(novel => {
                if(novel && novel.id && novel.name) {
                   fragment.appendChild(uiSettingsModule._createChatroomNovelListItem(novel));
                }
            });
            container.appendChild(fragment);
        }
    },


    novelUI_toggleNovelInterface: () => {
        stateModule.isNovelInterfaceVisible = !stateModule.isNovelInterfaceVisible;
        elementsModule.novelInterface.classList.toggle('active', stateModule.isNovelInterfaceVisible);

        if (stateModule.isNovelInterfaceVisible) {
            if (elementsModule.settingsPanel.classList.contains('active')) {
                uiSettingsModule.toggleSettings();
            }
            uiSettingsModule.novelUI_hideAllNovelPages();
            stateModule.novelPageStack = [];
            stateModule.activeNovelPage = null;

            const displayArea = elementsModule.novelContentDisplay;
            const currentlyDisplayedNovelId = displayArea?.dataset.novelId;
            const currentChatroomDetails = stateModule.currentChatroomDetails;

            if (stateModule.currentNovelId && currentlyDisplayedNovelId === stateModule.currentNovelId) {

            } else if (stateModule.currentNovelId && currentChatroomDetails) {
                 const isAssociated = currentChatroomDetails.novels?.some(n => n.id === stateModule.currentNovelId);
                 if (isAssociated) {
                     uiSettingsModule.novelUI_loadAndDisplayNovelContent(stateModule.currentNovelId);
                 } else {
                     stateModule.currentNovelId = null;
                     stateModule.config.lastViewedNovelId = null;
                     if (displayArea) {
                         displayArea.innerHTML = '<p style="text-align: center; padding-top: 20px;">请在书目(📚)中选择小说</p>';
                         displayArea.removeAttribute('data-novel-id');
                     }
                 }
            } else {
                if (displayArea) {
                     displayArea.innerHTML = '<p style="text-align: center; padding-top: 20px;">请在书目(📚)中选择小说</p>';
                     displayArea.removeAttribute('data-novel-id');
                }
            }
        } else {
            uiSettingsModule.novelUI_hideAllNovelPages();
            stateModule.novelPageStack = [];
            stateModule.activeNovelPage = null;

        }
    },

    novelUI_hideAllNovelPages: () => {
        if (elementsModule.novelBookshelfPage) elementsModule.novelBookshelfPage.classList.remove('active');
        if (elementsModule.novelTocPage) elementsModule.novelTocPage.classList.remove('active');
        stateModule.activeNovelPage = null;
    },

    novelUI_showNovelSection: (pageId) => {
        uiSettingsModule.novelUI_hideAllNovelPages();
        let pageElement = null;
        if (pageId === 'novel-bookshelf-page') {
            pageElement = elementsModule.novelBookshelfPage;
            uiSettingsModule.novelUI_updateBookshelfPage();
        } else if (pageId === 'novel-toc-page') {
            pageElement = elementsModule.novelTocPage;
             uiSettingsModule.novelUI_updateTocPage();
        }

        if (pageElement) {
            pageElement.classList.add('active');
            stateModule.activeNovelPage = pageId;
            if (stateModule.novelPageStack[stateModule.novelPageStack.length - 1] !== pageId) {
                stateModule.novelPageStack.push(pageId);
            }
        } else {
            stateModule.novelPageStack = [];
            stateModule.activeNovelPage = null;
        }
    },

    novelUI_closeCurrentNovelSection: (pageId) => {
        let pageElement = null;
        if (pageId === 'novel-bookshelf-page') pageElement = elementsModule.novelBookshelfPage;
        else if (pageId === 'novel-toc-page') pageElement = elementsModule.novelTocPage;

        if (pageElement) {
            pageElement.classList.remove('active');

            if (stateModule.novelPageStack[stateModule.novelPageStack.length - 1] === pageId) {
                stateModule.novelPageStack.pop();
            } else {
                 const index = stateModule.novelPageStack.indexOf(pageId);
                 if (index > -1) stateModule.novelPageStack.splice(index, 1);
            }

            if (stateModule.novelPageStack.length > 0) {
                const previousPageId = stateModule.novelPageStack[stateModule.novelPageStack.length - 1];
                uiSettingsModule.novelUI_showNovelSection(previousPageId);
            } else {
                stateModule.activeNovelPage = null;
            }
        }
    },

    novelUI_updateBookshelfPage: () => {
        const container = elementsModule.novelBookshelfListContainer;
        if (!container) return;
        container.innerHTML = '';

        const chatroomDetails = stateModule.currentChatroomDetails;

        if (!chatroomDetails || !chatroomDetails.config) {
            container.innerHTML = '<p style="text-align: center;">请先选择一个聊天室</p>';
            return;
        }
        const currentChatroomName = chatroomDetails.config.name;
        const associatedNovels = chatroomDetails.novels || [];

        if (associatedNovels.length === 0) {
            container.innerHTML = '<p style="text-align: center;">当前聊天室无小说<br>(请在 设置 -> 聊天室设置 -> 聊天室详情 -> 聊天室小说 中添加)</p>';
            return;
        }

        const activeIdsInRoom = new Set(chatroomDetails.config.activeNovelIds || []);
        const fragment = document.createDocumentFragment();

        const sortedNovels = [...associatedNovels]
            .filter(Boolean)
            .sort((a, b) => (a.name || '').localeCompare(b.name || ''));

        if (sortedNovels.length === 0) {
             container.innerHTML = '<p style="text-align: center;">关联的小说似乎已被删除</p>';
             return;
        }

        sortedNovels.forEach(novel => {
             if (!novel || !novel.id || !novel.name || !novel.segments || !novel.toc) return;
            const item = document.createElement('div');
            item.className = 'novel-bookshelf-item';
            item.dataset.novelId = novel.id;

            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'currentNovelSelection';
            radio.value = novel.id;
            radio.id = `novel-select-${currentChatroomName}-${novel.id}`;
            radio.checked = stateModule.currentNovelId === novel.id;

            const label = document.createElement('label');
            label.textContent = novel.name;
            label.htmlFor = radio.id;
             label.style.cursor = 'pointer';
            if (stateModule.currentNovelId === novel.id) {
                label.style.fontWeight = 'bold';
            }

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'novel-activation-checkbox';
            checkbox.value = novel.id;
            checkbox.id = `novel-activate-${currentChatroomName}-${novel.id}`;
            checkbox.checked = activeIdsInRoom.has(novel.id);

            item.appendChild(radio);
            item.appendChild(label);
            item.appendChild(checkbox);
            fragment.appendChild(item);
        });

        container.appendChild(fragment);
    },

    novelUI_handleNovelSelection: (novelId) => {
        if (stateModule.currentNovelId !== novelId) {
            stateModule.currentNovelId = novelId;
            stateModule.config.lastViewedNovelId = novelId;
            if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                mainModule.triggerDebouncedSave();
            }

             uiSettingsModule.novelUI_updateBookshelfPage();
             uiSettingsModule.novelUI_loadAndDisplayNovelContent(novelId);
        } else {
            const displayArea = elementsModule.novelContentDisplay;
             if (displayArea?.dataset.novelId !== novelId) {
                  uiSettingsModule.novelUI_loadAndDisplayNovelContent(novelId);
             }
        }

         uiSettingsModule.novelUI_closeCurrentNovelSection('novel-bookshelf-page');
    },

    novelUI_handleNovelActivation: (novelId, isChecked) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !chatroomDetails.config) return;

        let activeIds = chatroomDetails.config.activeNovelIds || [];
        const index = activeIds.indexOf(novelId);

        if (isChecked && index === -1) {
            activeIds.push(novelId);
        } else if (!isChecked && index > -1) {
            activeIds.splice(index, 1);
        } else {
             return;
        }

        chatroomDetails.config.activeNovelIds = activeIds;
        apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
        updateChatContextCache();
    },

    novelUI_loadAndDisplayNovelContent: (novelId) => {
        const displayArea = elementsModule.novelContentDisplay;
        if (!displayArea || stateModule.isNovelLoading) return;

        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) {
             _logAndDisplayError("无法加载小说：未找到激活聊天室数据。", 'novelUI_loadAndDisplayNovelContent');
             return;
        }

        const novelData = chatroomDetails.novels.find(n => n.id === novelId);
        if (!novelData || !novelData.segments || !novelData.toc) {
            displayArea.innerHTML = '<p style="text-align: center; color: red;">无法加载小说数据</p>';
            displayArea.removeAttribute('data-novel-id');
            stateModule.currentNovelId = null;
            stateModule.config.lastViewedNovelId = null;
            _logAndDisplayError(`无法找到小说数据 ID: ${novelId}`, 'novelUI_loadAndDisplayNovelContent');
            return;
        }

        stateModule.isNovelLoading = true;
        displayArea.innerHTML = '<p style="text-align: center; padding-top: 20px;">正在加载...</p>';

        const fragment = document.createDocumentFragment();
        const tocMap = new Map();
        novelData.toc.forEach((item, index) => {
            if (item && item.segmentId !== undefined && !tocMap.has(item.segmentId)) {
                tocMap.set(item.segmentId, { index: index, title: item.title });
            }
        });

        novelData.segments.forEach(segment => {
            if (segment && segment.id !== undefined && segment.content !== undefined) {
                if (tocMap.has(segment.id)) {
                    const tocEntry = tocMap.get(segment.id);
                    const markerId = `novel-chapter-marker-${novelId}-${tocEntry.index}`;
                    const marker = document.createElement('span');
                    marker.className = 'novel-chapter-marker';
                    marker.id = markerId;
                    marker.dataset.segmentId = segment.id;
                    marker.textContent = tocEntry.title.replace(/</g, "<").replace(/>/g, ">");
                    fragment.appendChild(marker);
                    fragment.appendChild(document.createElement('br'));
                }

                const segmentSpan = document.createElement('span');
                segmentSpan.className = 'novel-segment';
                segmentSpan.dataset.segmentId = segment.id;
                segmentSpan.textContent = segment.content.replace(/</g, "<").replace(/>/g, ">");
                fragment.appendChild(segmentSpan);
                fragment.appendChild(document.createTextNode('\n'));
            }
        });

        displayArea.innerHTML = '';
        displayArea.appendChild(fragment);
        displayArea.dataset.novelId = novelId;

        setTimeout(() => {
            const savedSegmentId = chatroomDetails.config.novelCurrentSegmentIds?.[novelId];
            let targetElement = null;
            if (savedSegmentId !== undefined) {
                 targetElement = displayArea.querySelector(`.novel-segment[data-segment-id="${savedSegmentId}"]`);
                 if (!targetElement) {
                     targetElement = displayArea.querySelector(`.novel-chapter-marker[data-segment-id="${savedSegmentId}"]`);
                 }
            }
            if (targetElement) {
                 targetElement.scrollIntoView({ behavior: 'auto', block: 'start' });
            } else {
                 displayArea.scrollTop = 0;
                 if (chatroomDetails.config.novelCurrentSegmentIds) {
                      chatroomDetails.config.novelCurrentSegmentIds[novelId] = 0;
                      apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
                 }
                 stateModule.currentTocIndexByNovel[novelId] = 0;

            }
        }, 50);
        stateModule.isNovelLoading = false;

    },

    novelUI_updateTocPage: () => {
        const container = elementsModule.novelTocListContainer;
        const novelId = stateModule.currentNovelId;
        const chatroomDetails = stateModule.currentChatroomDetails;

        if (!container) return;
        if (!chatroomDetails || !novelId) {
            container.innerHTML = '<p style="text-align: center;">请先在书目中选择一本小说</p>';
            return;
        }

        container.innerHTML = '';
        const novelData = chatroomDetails.novels.find(n => n.id === novelId);

        if (!novelData || !novelData.toc || novelData.toc.length === 0) {
             container.innerHTML = '<p style="text-align: center;">未找到章节信息</p>';
             return;
        }

        const currentTocIndex = stateModule.currentTocIndexByNovel[novelId];
        const fragment = document.createDocumentFragment();

        novelData.toc.forEach((tocItem, index) => {
            if (tocItem && tocItem.segmentId !== undefined && tocItem.title !== undefined) {
                const tocElement = document.createElement('div');
                tocElement.className = 'novel-toc-item';
                tocElement.textContent = tocItem.title.replace(/</g, "<").replace(/>/g, ">");
                tocElement.dataset.targetSegmentId = tocItem.segmentId;
                if (index === currentTocIndex) {
                    tocElement.classList.add('current-chapter');
                }
                tocElement.addEventListener('click', uiSettingsModule.novelUI_handleTocJump);
                fragment.appendChild(tocElement);
            }
        });

        container.appendChild(fragment);

         if (currentTocIndex !== undefined && currentTocIndex !== null && novelData.toc[currentTocIndex]) {
              const targetSegmentId = novelData.toc[currentTocIndex].segmentId;
              if (targetSegmentId !== undefined) {
                 setTimeout(() => {
                    const targetTocElement = container.querySelector(`.novel-toc-item[data-target-segment-id="${targetSegmentId}"]`);
                    if (targetTocElement) {
                        targetTocElement.scrollIntoView({ block: 'center', behavior: 'auto' });
                    }
                 }, 50);
             }
         }
    },

    novelUI_handleTocJump: (event) => {
        const targetSegmentId = event.currentTarget.dataset.targetSegmentId;
        const novelId = stateModule.currentNovelId;
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (targetSegmentId === undefined || !novelId || !chatroomDetails) return;

        const displayArea = elementsModule.novelContentDisplay;
        let targetElement = displayArea.querySelector(`.novel-chapter-marker[data-segment-id="${targetSegmentId}"]`);
        if (!targetElement) {
             targetElement = displayArea.querySelector(`.novel-segment[data-segment-id="${targetSegmentId}"]`);
        }

        if (targetElement && displayArea) {
             targetElement.scrollIntoView({ behavior: 'auto', block: 'start' });
             if (chatroomDetails.config.novelCurrentSegmentIds) {
                  chatroomDetails.config.novelCurrentSegmentIds[novelId] = parseInt(targetSegmentId, 10);
                  apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
             }
             const novelData = chatroomDetails.novels.find(n => n.id === novelId);
             const tocIndex = novelData?.toc.findIndex(item => item.segmentId === parseInt(targetSegmentId, 10));
             if (tocIndex !== undefined && tocIndex !== -1) {
                 stateModule.currentTocIndexByNovel[novelId] = tocIndex;
             }

        }

        uiSettingsModule.novelUI_closeCurrentNovelSection('novel-toc-page');
    },


    novelUI_saveScrollPosition: () => {
         clearTimeout(stateModule.scrollUpdateTimer);
         stateModule.scrollUpdateTimer = setTimeout(() => {
             const currentNovelId = stateModule.currentNovelId;
             const displayArea = elementsModule.novelContentDisplay;
             const chatroomDetails = stateModule.currentChatroomDetails;

             if (currentNovelId && displayArea && chatroomDetails && chatroomDetails.config && chatroomDetails.config.novelCurrentSegmentIds && displayArea.dataset.novelId === currentNovelId && stateModule.isNovelInterfaceVisible && !stateModule.activeNovelPage) {

                 let topSegmentId = 0;
                 const segments = displayArea.querySelectorAll('.novel-segment, .novel-chapter-marker[data-segment-id]');
                 const viewportTop = displayArea.scrollTop;
                 const viewportBottom = viewportTop + displayArea.clientHeight;

                 for (let i = 0; i < segments.length; i++) {
                      const segmentElement = segments[i];
                      const elementTop = segmentElement.offsetTop;
                      const elementBottom = elementTop + segmentElement.offsetHeight;

                      if (elementTop >= viewportTop || elementBottom > viewportTop) {
                           topSegmentId = parseInt(segmentElement.dataset.segmentId, 10);
                           break;
                      }
                 }
                 if (isNaN(topSegmentId)) topSegmentId = 0;

                 if(chatroomDetails.config.novelCurrentSegmentIds[currentNovelId] !== topSegmentId) {
                    chatroomDetails.config.novelCurrentSegmentIds[currentNovelId] = topSegmentId;
                    apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
                 }

                 const novelData = chatroomDetails.novels.find(n => n.id === currentNovelId);
                 let currentTocIndex = 0;
                 if (novelData && novelData.toc && novelData.toc.length > 0) {
                    let foundTocIndex = -1;
                    for(let i = novelData.toc.length - 1; i >= 0; i--) {
                        if (novelData.toc[i].segmentId <= topSegmentId) {
                            foundTocIndex = i;
                            break;
                        }
                    }
                    if (foundTocIndex !== -1) {
                         currentTocIndex = foundTocIndex;
                    }
                 }
                 stateModule.currentTocIndexByNovel[currentNovelId] = currentTocIndex;

             }
         }, 250);
    },

    _triggerDownload: (filename, data) => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },

    exportRole: () => {
        const roleName = stateModule.currentRole;
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!roleName || !chatroomDetails) {
            _logAndDisplayError("没有当前选定的角色或聊天室可导出。", 'exportRole');
            return;
        }
        const roleData = chatroomDetails.roles.find(r => r.name === roleName);
        const isTemporary = !roleData;

        if (isTemporary || roleName === "管理员") {
            _logAndDisplayError(`无法导出角色 "${roleName}" (临时角色或管理员)。`, 'exportRole');
            return;
        }

        uiSettingsModule._triggerDownload(`role_${roleName}.json`, roleData);
    },

    importRole: () => {
        elementsModule.importRoleFile.click();
    },

    handleImportRoleFile: (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) {
            _logAndDisplayError("请先选择一个聊天室来导入角色。", 'handleImportRoleFile');
            event.target.value = null;
            return;
        }
        const roomName = chatroomDetails.config.name;

        const reader = new FileReader();
        reader.onload = async function(e) {
            let importedRoleData;
            try {
                importedRoleData = JSON.parse(e.target.result);
            } catch (err) {
                 _logAndDisplayError(`导入角色失败: 文件不是有效的 JSON. ${err.message}`, 'handleImportRoleFile');
                 event.target.value = null;
                 return;
            }

            if (!importedRoleData || typeof importedRoleData !== 'object' || !importedRoleData.name || typeof importedRoleData.name !== 'string') {
                _logAndDisplayError("导入的文件格式无效，缺少 'name' 字段。", 'handleImportRoleFile');
                 event.target.value = null;
                 return;
            }

            let importName = importedRoleData.name;
            let finalName = importName;
            const existingNames = Object.keys(chatroomDetails.config.roleStates || {});

            while (existingNames.includes(finalName)) {
                finalName = prompt(`名称 "${finalName}" 在此聊天室已存在。请输入新的角色名称：`, `${importName}_imported`);
                if (!finalName || finalName.trim() === "") {
                    event.target.value = null;
                    return;
                }
                finalName = finalName.trim();
            }

            const newRole = {
                name: finalName,
                setting: importedRoleData.setting || '',
                memory: importedRoleData.memory || '',
                drawingTemplate: importedRoleData.drawingTemplate || '',
            };

            const success = await apiModule.createRole(roomName, newRole);
            if(success) {
                 await apiModule.fetchChatroomDetails(roomName);
                 uiSettingsModule.updateChatroomRolePage();
                 if (typeof uiChatModule !== 'undefined') {
                     uiChatModule.updateRoleButtonsList();
                 }
                 updateChatContextCache();

            } else {
                 alert(`Failed to import role '${finalName}'.`);
            }

            event.target.value = null;
        };
        reader.onerror = function(e) {
            event.target.value = null;
            _logAndDisplayError("读取文件时出错。", 'handleImportRoleFile');
        };
        reader.readAsText(file);
    },

    exportChatroom: () => {
         const roomName = stateModule.config.activeChatRoomName;
         if (!roomName) {
             _logAndDisplayError("没有当前选定的聊天室可导出。", 'exportChatroom');
             return;
         }
          window.location.href = '/export-chatroom-zip/' + encodeURIComponent(roomName);
    },

    importChatroom: () => {
        elementsModule.importChatroomFile.click();
    },

    handleImportChatroomFile: async (event) => {
         const file = event.target.files[0];
         if (!file) return;
         if (!file.name.toLowerCase().endsWith('.zip')) {
              _logAndDisplayError('请选择一个 .zip 文件进行导入。', 'handleImportChatroomFile');
              event.target.value = null;
              return;
         }

         const formData = new FormData();
         formData.append('chatroom_zip', file);

         try {
              const response = await fetch('/import-chatroom-zip', {
                  method: 'POST',
                  body: formData,
              });
              const result = await response.json();
              if (!response.ok) {
                  throw new Error(result.error || `HTTP error! status: ${response.status}`);
              }

              alert(result.message || "聊天室导入成功！");


              await configModule.loadConfig();

              initializationModule.initializeConfig();
              uiSettingsModule.updateChatroomList();
              if (stateModule.config.activeChatRoomName) {
                  await uiSettingsModule.switchActiveChatroom(stateModule.config.activeChatRoomName);
              }


         } catch (error) {
              _logAndDisplayError(`导入聊天室失败: ${error.message}`, 'handleImportChatroomFile');
              alert(`导入聊天室失败: ${error.message}`);
         } finally {
             event.target.value = null;
         }
    },

    loadRoleplayRulesSetting: () => {
        const textarea = elementsModule.roleplayRulesTextarea;
        if (textarea) {
            const details = stateModule.currentChatroomDetails;
            if (details && details.config) {
                 textarea.value = details.config.roleplayRules || "";
                 textarea.disabled = false;
            } else {
                 textarea.value = "";
                 textarea.disabled = true;
            }
        }
    },

    saveRoleplayRulesSetting: () => {
        const textarea = elementsModule.roleplayRulesTextarea;
        const details = stateModule.currentChatroomDetails;
        if (details && details.config && textarea) {
             const newValue = textarea.value;
             if (details.config.roleplayRules !== newValue) {
                details.config.roleplayRules = newValue;
                apiModule.triggerDebouncedChatroomConfigSave(details.config.name);
                updateChatContextCache();
             }
        }
    },

    loadPublicInfoSetting: () => {
        const textarea = elementsModule.publicInfoTextarea;
        if (textarea) {
             const details = stateModule.currentChatroomDetails;
            if (details && details.config) {
                textarea.value = details.config.publicInfo || "";
                textarea.disabled = false;
            } else {
                textarea.value = "";
                textarea.disabled = true;
            }
        }
    },

    savePublicInfoSetting: () => {
        const textarea = elementsModule.publicInfoTextarea;
        const details = stateModule.currentChatroomDetails;
        if (details && details.config && textarea) {
            const newValue = textarea.value;
            if (details.config.publicInfo !== newValue) {
                details.config.publicInfo = newValue;
                apiModule.triggerDebouncedChatroomConfigSave(details.config.name);
                updateChatContextCache();
            }
        }
    },

    loadChatroomUserSetting: () => {
        const input = elementsModule.chatroomUserSetting;
        if (input) {
             const details = stateModule.currentChatroomDetails;
            if (details && details.config) {
                input.value = details.config.user || "";
                input.disabled = false;
            } else {
                input.value = "";
                input.disabled = true;
            }
        }
    },

    saveChatroomUserSetting: () => {
        const input = elementsModule.chatroomUserSetting;
        const details = stateModule.currentChatroomDetails;
        if (details && details.config && input) {
            const newValue = input.value;
            if (details.config.user !== newValue) {
                details.config.user = newValue;
                apiModule.triggerDebouncedChatroomConfigSave(details.config.name);
                updateChatContextCache();
            }
        }
    },

    loadPromptPresetSettings: () => {
        if (elementsModule.systemInstructionPresetSettings) {
            elementsModule.systemInstructionPresetSettings.value = stateModule.config.systemInstruction || '';
        }

    },

    savePromptPresetSetting: (key) => {
         let element = null;
         if (key === 'systemInstruction') {
              element = elementsModule.systemInstructionPresetSettings;
         }
         if (element) {
              stateModule.config[key] = element.value;
              if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                 mainModule.triggerDebouncedSave();
              }
         }
    },

    renderPromptPresetsList: () => {
        const container = elementsModule.promptPresetListContainer;
        if (!container) return;
        container.innerHTML = '';
        const turns = stateModule.config.promptPresetTurns || [];

        turns.forEach((turn, index) => {
            const item = document.createElement('div');
            item.className = 'prompt-preset-item';
            item.dataset.index = index;

            const roleLabel = document.createElement('span');
            roleLabel.className = 'preset-role-label';
            roleLabel.textContent = turn.role === 'user' ? 'U' : 'M';

            const textarea = document.createElement('textarea');
            textarea.className = 'preset-instruction-textarea';
            textarea.value = turn.instruction || '';
            textarea.addEventListener('input', () => uiSettingsModule.updatePromptPresetTurn(index, textarea.value));
            textarea.addEventListener('change', () => uiSettingsModule.updatePromptPresetTurn(index, textarea.value));

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'item-actions';

            const upButton = document.createElement('div');
            upButton.className = 'std-button preset-move-up';
            upButton.textContent = '↑';
            upButton.disabled = index === 0;
            if (index === 0) upButton.style.opacity = '0.5';
            upButton.addEventListener('click', () => uiSettingsModule.movePromptPresetTurn(index, -1));

            const downButton = document.createElement('div');
            downButton.className = 'std-button preset-move-down';
            downButton.textContent = '↓';
            downButton.disabled = index === turns.length - 1;
            if (index === turns.length - 1) downButton.style.opacity = '0.5';
            downButton.addEventListener('click', () => uiSettingsModule.movePromptPresetTurn(index, 1));

            const deleteButton = document.createElement('div');
            deleteButton.className = 'std-button preset-delete';
            deleteButton.textContent = '✕';
            deleteButton.addEventListener('click', () => uiSettingsModule.deletePromptPresetTurn(index));

            actionsDiv.appendChild(upButton);
            actionsDiv.appendChild(downButton);
            actionsDiv.appendChild(deleteButton);

            item.appendChild(roleLabel);
            item.appendChild(textarea);
            item.appendChild(actionsDiv);
            container.appendChild(item);
        });
    },

    addPromptPresetTurn: (role) => {
        if (!stateModule.config.promptPresetTurns) {
             stateModule.config.promptPresetTurns = [];
        }
        stateModule.config.promptPresetTurns.push({ role: role, instruction: "" });
        uiSettingsModule.renderPromptPresetsList();
        if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
            mainModule.triggerDebouncedSave();
        }
    },

    updatePromptPresetTurn: (index, instruction) => {
        if (stateModule.config.promptPresetTurns && stateModule.config.promptPresetTurns[index]) {
             stateModule.config.promptPresetTurns[index].instruction = instruction;
             if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                 mainModule.triggerDebouncedSave();
             }
        }
    },

    movePromptPresetTurn: (index, direction) => {
        const turns = stateModule.config.promptPresetTurns;
        if (!turns || index < 0 || index >= turns.length) return;
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= turns.length) return;

        const itemToMove = turns.splice(index, 1)[0];
        turns.splice(newIndex, 0, itemToMove);

        uiSettingsModule.renderPromptPresetsList();
        if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
            mainModule.triggerDebouncedSave();
        }
    },

    deletePromptPresetTurn: (index) => {
         if (stateModule.config.promptPresetTurns && stateModule.config.promptPresetTurns[index]) {
             stateModule.config.promptPresetTurns.splice(index, 1);
             uiSettingsModule.renderPromptPresetsList();
             if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                 mainModule.triggerDebouncedSave();
             }
         }
    },

    handleImportPromptPresets: (event) => {
        const file = event.target.files[0];
        if (file) {
            apiModule.importPromptPresets(file);
        }
        event.target.value = null;
    },

    loadChatroomModelSetting: () => {
         const selectElement = elementsModule.chatroomModelSelectSettings;
         if (selectElement) {
             const savedValue = stateModule.config.model || '';
             selectElement.value = savedValue;
             if (!savedValue && selectElement.options.length > 0 && selectElement.options[0].disabled) {

             } else if (savedValue && !selectElement.querySelector(`option[value="${savedValue}"]`)) {
                  const tempOption = new Option(`${savedValue} (Saved)`, savedValue, true, true);
                  selectElement.add(tempOption, 0);
             }
         }
    },

    saveChatroomModelSetting: () => {
         const selectElement = elementsModule.chatroomModelSelectSettings;
         if (selectElement) {
              const selectedValue = selectElement.value;
              stateModule.config.model = selectedValue;
              if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                  mainModule.triggerDebouncedSave();
              }

              const tempOption = selectElement.querySelector(`option[value="${selectedValue}"]`);
              if (tempOption && tempOption.text.includes('(Saved)')) {
                   tempOption.text = selectedValue;
              }
         }
    },

    saveChatroomCommonSetting: (key) => {
         const element = elementsModule[`${key}Settings`];
         if (element) {
              stateModule.config[key] = element.value;
              if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                 mainModule.triggerDebouncedSave();
              }
         }
    },

    loadChatroomMainPromptSetting: () => {
        const element = elementsModule.chatroomMainPromptSettings;
        if (element) {
             element.value = stateModule.config.mainPrompt || '';
        }
    },

    saveChatroomMainPromptSetting: () => {
         const element = elementsModule.chatroomMainPromptSettings;
         if (element) {
              stateModule.config.mainPrompt = element.value;
              if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                  mainModule.triggerDebouncedSave();
              }
         }
    },

    saveToolModelSetting: (toolName) => {
        const selectElement = elementsModule[`${toolName}ModelSettings`];
        if (selectElement && stateModule.config.toolSettings[toolName]) {
             const selectedValue = selectElement.value;
             stateModule.config.toolSettings[toolName].model = selectedValue;
             if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                  mainModule.triggerDebouncedSave();
             }

             const tempOption = selectElement.querySelector(`option[value="${selectedValue}"]`);
             if (tempOption && tempOption.text.includes('(Saved)')) {
                  tempOption.text = selectedValue;
              }
         }
    },

    saveToolMainPromptSetting: (toolName) => {
         const textareaElement = elementsModule[`${toolName}MainPromptSettings`];
         if (textareaElement && stateModule.config.toolSettings[toolName]) {
              stateModule.config.toolSettings[toolName].mainPrompt = textareaElement.value;
              if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
                  mainModule.triggerDebouncedSave();
              }
         }
    },

    _toggleOverrideSectionInputs: (sectionType, enabled) => {
        const keys = ['ModelSelect', 'ResponseSchemaJson', 'ResponseSchemaParserJs', 'MainPrompt'];
        let dbInstructionKey;
        if(sectionType === 'general') {
            dbInstructionKey = 'SharedDatabaseInstruction';
        } else {
            dbInstructionKey = 'ToolDatabaseInstruction';
        }
        keys.push(dbInstructionKey);

        if (sectionType === 'drawingMaster') {
            keys.push('NovelContent');
        }

        keys.forEach(keySuffix => {
            const elementId = `chatroomOverride${sectionType.charAt(0).toUpperCase() + sectionType.slice(1)}${keySuffix}`;
            const element = elementsModule[elementId];
            if (element) {
                element.disabled = !enabled;
                element.style.opacity = enabled ? 1 : 0.5;
            }
        });
    },

    loadChatroomOverrideGeneralSettings: () => {
        const details = stateModule.currentChatroomDetails;
        if (!details || !details.config || !details.config.overrideSettings || !details.config.overrideSettings.general) {
             return;
        }
        const settings = details.config.overrideSettings.general;
        const enabledCheckbox = elementsModule.chatroomOverrideGeneralEnabled;
        const modelSelect = elementsModule.chatroomOverrideGeneralModelSelect;
        const schemaJson = elementsModule.chatroomOverrideGeneralResponseSchemaJson;
        const schemaParser = elementsModule.chatroomOverrideGeneralResponseSchemaParserJs;
        const sharedDb = elementsModule.chatroomOverrideGeneralSharedDatabaseInstruction;
        const mainPrompt = elementsModule.chatroomOverrideGeneralMainPrompt;

        enabledCheckbox.checked = settings.enabled || false;
        const savedValue = settings.model || '';
        modelSelect.value = savedValue;
         if (!savedValue && modelSelect.options.length > 0 && modelSelect.options[0].disabled) {

         } else if (savedValue && !modelSelect.querySelector(`option[value="${savedValue}"]`)) {
              const tempOption = new Option(`${savedValue} (Saved)`, savedValue, true, true);
              modelSelect.add(tempOption, 0);
         }
        schemaJson.value = settings.responseSchemaJson || '';
        schemaParser.value = settings.responseSchemaParserJs || '';
        sharedDb.value = settings.sharedDatabaseInstruction || '';
        mainPrompt.value = settings.mainPrompt || '';

        uiSettingsModule._toggleOverrideSectionInputs('general', enabledCheckbox.checked);
    },

    loadChatroomOverrideToolSettings: (toolName) => {
        const details = stateModule.currentChatroomDetails;
        if (!details || !details.config || !details.config.overrideSettings || !details.config.overrideSettings[toolName]) {
             return;
        }
        const settings = details.config.overrideSettings[toolName];
        const toolNameCapitalized = toolName.charAt(0).toUpperCase() + toolName.slice(1);

        const enabledCheckbox = elementsModule[`chatroomOverride${toolNameCapitalized}Enabled`];
        const modelSelect = elementsModule[`chatroomOverride${toolNameCapitalized}ModelSelect`];
        const schemaJson = elementsModule[`chatroomOverride${toolNameCapitalized}ResponseSchemaJson`];
        const schemaParser = elementsModule[`chatroomOverride${toolNameCapitalized}ResponseSchemaParserJs`];
        const toolDb = elementsModule[`chatroomOverride${toolNameCapitalized}ToolDatabaseInstruction`];
        const mainPrompt = elementsModule[`chatroomOverride${toolNameCapitalized}MainPrompt`];
        const novelContent = (toolName === 'drawingMaster') ? elementsModule.chatroomOverrideDrawingMasterNovelContent : null;

        if(enabledCheckbox) enabledCheckbox.checked = settings.enabled || false;
        if(modelSelect) {
             const savedValue = settings.model || '';
             modelSelect.value = savedValue;
             if (!savedValue && modelSelect.options.length > 0 && modelSelect.options[0].disabled) {

             } else if (savedValue && !modelSelect.querySelector(`option[value="${savedValue}"]`)) {
                  const tempOption = new Option(`${savedValue} (Saved)`, savedValue, true, true);
                  modelSelect.add(tempOption, 0);
             }
        }
        if(schemaJson) schemaJson.value = settings.responseSchemaJson || '';
        if(schemaParser) schemaParser.value = settings.responseSchemaParserJs || '';
        if(toolDb) toolDb.value = settings.toolDatabaseInstruction || '';
        if(mainPrompt) mainPrompt.value = settings.mainPrompt || '';
        if(novelContent) novelContent.value = settings.novelContent || '';

        if(enabledCheckbox) uiSettingsModule._toggleOverrideSectionInputs(toolName, enabledCheckbox.checked);
    },

    saveChatroomOverrideEnabled: (sectionType) => {
        const details = stateModule.currentChatroomDetails;
        if (!details || !details.config || !details.config.overrideSettings || !details.config.overrideSettings[sectionType]) {
             return;
        }
        const enabledCheckbox = elementsModule[`chatroomOverride${sectionType.charAt(0).toUpperCase() + sectionType.slice(1)}Enabled`];
        if (!enabledCheckbox) return;

        const isEnabled = enabledCheckbox.checked;
        details.config.overrideSettings[sectionType].enabled = isEnabled;
        uiSettingsModule._toggleOverrideSectionInputs(sectionType, isEnabled);

        apiModule.triggerDebouncedChatroomConfigSave(details.config.name);
    },

    saveChatroomOverrideSetting: (sectionType, key) => {
        const details = stateModule.currentChatroomDetails;
        if (!details || !details.config || !details.config.overrideSettings || !details.config.overrideSettings[sectionType]) {
             return;
        }

        let elementKey = key.charAt(0).toUpperCase() + key.slice(1);

        if(key === 'sharedDatabaseInstruction' && sectionType === 'general') {
             elementKey = 'SharedDatabaseInstruction';
        } else if (key === 'toolDatabaseInstruction' && sectionType !== 'general') {
             elementKey = 'ToolDatabaseInstruction';
        } else if (key === 'model') {
             elementKey = 'ModelSelect';
        } else if (key === 'responseSchemaJson') {
             elementKey = 'ResponseSchemaJson';
        } else if (key === 'responseSchemaParserJs') {
             elementKey = 'ResponseSchemaParserJs';
        } else if (key === 'mainPrompt') {
             elementKey = 'MainPrompt';
        } else if (key === 'novelContent' && sectionType === 'drawingMaster') {
             elementKey = 'NovelContent';
        } else {

             return;
        }

        const element = elementsModule[`chatroomOverride${sectionType.charAt(0).toUpperCase() + sectionType.slice(1)}${elementKey}`];
        if (element) {
             let value = element.value;
             if (element.tagName === 'SELECT') {
                  value = element.value;

                   const tempOption = element.querySelector(`option[value="${value}"]`);
                   if (tempOption && tempOption.text.includes('(Saved)')) {
                        tempOption.text = value;
                   }
             }

             details.config.overrideSettings[sectionType][key] = value;
             apiModule.triggerDebouncedChatroomConfigSave(details.config.name);
        }
    },
    handleRoleVisibilityChange: (roleName, isVisible) => {
         const chatroomDetails = stateModule.currentChatroomDetails;
         if (!chatroomDetails || !chatroomDetails.config || !chatroomDetails.config.roleVisibility) {
             return;
         }
         chatroomDetails.config.roleVisibility[roleName] = isVisible;
         apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
         if (typeof uiChatModule !== 'undefined') {
             uiChatModule.updateRoleButtonsList();
         }
     },
};
```
--- END OF FILE ui_settings.js ---


--- START OF FILE ui_chat.js ---
```javascript
const uiChatModule = {
    ROLE_STATE_DEFAULT: '默',
    ROLE_STATE_ACTIVE: '活',
    ROLE_STATE_USER_CONTROL: '用',
    ROLE_STATE_UPDATE: '更',
    CHARACTER_SETTINGS_SEPARATOR: '\n--- CHARACTER_SETTINGS_START ---\n',
    _generateMessageId: () => {
        return `msg-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    },
    _parseAIResponse: (textContentString, roleName, roleType) => {
        let parserJsCode = '';
        const chatroomDetails = stateModule.currentChatroomDetails;
        let sectionType = (roleType === 'role' || roleType === 'temporary_role') ? 'general' : roleName;
        let useOverrideParser = false;

        if (chatroomDetails && chatroomDetails.config && chatroomDetails.config.overrideSettings && chatroomDetails.config.overrideSettings[sectionType]) {
            const overrideSection = chatroomDetails.config.overrideSettings[sectionType];
            if (overrideSection.enabled && overrideSection.responseSchemaParserJs && overrideSection.responseSchemaParserJs.trim() !== '') {
                parserJsCode = overrideSection.responseSchemaParserJs;
                useOverrideParser = true;
            }
        }

        if (!useOverrideParser) {
            if (roleType === 'tool' && stateModule.config.toolSettings[roleName]) {
                parserJsCode = stateModule.config.toolSettings[roleName].responseSchemaParserJs || '';
            } else if (roleType === 'role' || roleType === 'temporary_role') {
                parserJsCode = stateModule.config.responseSchemaParserJs || '';
            }
        }

        let parsedResult = null;
        let parserError = null;

        if (typeof textContentString !== 'string' || textContentString.trim() === '') {
            return { parsedResult: null, parserError: "No valid text content", rawText: textContentString };
        }

        if (parserJsCode) {
            try {
                const responseJsonMock = {
                    candidates: [{
                        content: {
                            parts: [{
                                text: textContentString
                            }]
                        }
                    }]
                };
                const parserFunction = new Function('responseJson', parserJsCode);
                parsedResult = parserFunction(responseJsonMock);
                if (parsedResult && typeof parsedResult === 'object' && parsedResult.error) {
                    parserError = parsedResult.error;
                    parsedResult = null;
                } else if (parsedResult === null || parsedResult === undefined) {
                    parserError = 'Parser returned null/undefined';
                    parsedResult = null;
                }
            } catch (e) {
                 parserError = `Error executing parser: ${e.message}`;
                 parsedResult = null;
            }
        } else {
             parserError = `Parser not defined for ${roleName}`;
             parsedResult = null;
             try {
                 const regexMatch = textContentString.match(/\{[\s\S]*\}/);
                 if (regexMatch && regexMatch[0]) {
                     parsedResult = JSON.parse(regexMatch[0]);
                     parserError = null;
                 } else {
                     parserError += " and could not extract fallback JSON.";
                 }
             } catch(fallbackError){
                  parserError += ` and fallback JSON parsing failed: ${fallbackError.message}`;
                  parsedResult = null;
             }
        }

        if (parserError && parsedResult === null && (roleType === 'role' || roleType === 'temporary_role')) {
             parsedResult = { formattedText: textContentString, nextRoleToAct: null };
             parserError = null;
        }

        return { parsedResult, parserError, rawText: textContentString };
    },
     _formatCharacterUpdateMasterDisplay: (parsedResult) => {
        if (!parsedResult || typeof parsedResult !== 'object') {
            return "[无法格式化角色更新：无效的解析结果]";
        }
        return parsedResult.formattedUpdate || "[角色更新：缺少 formattedUpdate 字段]";
     },
     _getFormattedDisplayText: (parsedResult, roleType, roleName, parserError) => {
        if (parserError && !parsedResult) {
            return `[${roleName} 解析错误: ${parserError}]`;
        }
        if (!parsedResult) {
             return "[无法格式化: 无解析结果]";
        }
        if (roleType === 'role' || roleType === 'temporary_role') {
             return parsedResult.formattedText || (typeof parsedResult === 'string' ? parsedResult : "[角色/临时角色: 无有效文本]");
        } else if (roleType === 'tool') {
            if (roleName === 'writingMaster') {
                 return parsedResult.description || (typeof parsedResult === 'string' ? parsedResult : "[写作大师: 无描述]");
            } else if (roleName === 'gameHost') {
                 return '';
            } else if (roleName === 'drawingMaster') {
                 return "[图片绘制]";
            } else if (roleName === 'characterUpdateMaster') {
                 return parsedResult.formattedUpdate || "[角色更新: 无格式化文本]";
            } else if (roleName === 'privateAssistant') {
                 return parsedResult.responseContent || "[私人助理: 无响应内容]";
            } else {
                return parsedResult.text || (typeof parsedResult === 'string' ? JSON.stringify(parsedResult) : JSON.stringify(parsedResult)) || `[未知工具: ${roleName}]`;
            }
        } else {
            return "[未知角色类型]";
        }
    },
    _appendMessageAndScroll: (messageObject) => {
        const messageElement = uiChatModule.displayChatMessageElement(messageObject);
        if (!messageElement) {
            _logAndDisplayError("Failed to create message element from object: " + JSON.stringify(messageObject), '_appendMessageAndScroll');
            return null;
        }
        elementsModule.chatArea.appendChild(messageElement);
        updateChatContextCache();
        return messageElement;
    },
    _handlePostResponseActions: async (messageContainer, roleName, roleType, parsedResult, parserError, targetRoleName = null) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (roleName === 'gameHost') {
            if (messageContainer) {
                const messageId = messageContainer.dataset.messageId;
                const messageObject = stateModule.currentChatHistoryData.find(msg => msg.id === messageId);
                if (messageObject) {
                     uiChatModule._renderGameHostContent(messageContainer, messageObject.activeView || 'time');
                }
            }
            if (!parserError && parsedResult && chatroomDetails) {
                 const updatedCharName = parsedResult.processedCharacterInfo?.characterName;
                 if (updatedCharName) {
                     const charInfo = parsedResult.processedCharacterInfo;
                     const formatItemsToText = (items) => Array.isArray(items) ? items.join(', ') : (items || '无');
                     let charDetailText = '';
                     charDetailText += `Demeanor: ${formatItemsToText(charInfo.demeanorItems)}\n`;
                     charDetailText += `Outerwear: ${formatItemsToText(charInfo.outerwearItems)}\n`;
                     charDetailText += `Underwear: ${formatItemsToText(charInfo.underwearItems)}\n`;
                     charDetailText += `Accessories: ${formatItemsToText(charInfo.accessories)}\n`;
                     charDetailText += `Short Status: ${formatItemsToText(charInfo.shortTermStatusItems)}\n`;
                     charDetailText += `Long Status: ${formatItemsToText(charInfo.longTermStatusItems)}\n`;
                     charDetailText += `Pose: ${formatItemsToText(charInfo.actionPoseItems)}\n`;
                     charDetailText += `Action: ${formatItemsToText(charInfo.currentActionItems)}\n`;
                     charDetailText += `Other Status: ${formatItemsToText(charInfo.otherCharacterStatusItems)}`;
                     if (!chatroomDetails.config.roleDetailedStates) chatroomDetails.config.roleDetailedStates = {};
                     chatroomDetails.config.roleDetailedStates[updatedCharName] = `${updatedCharName}：\n${charDetailText.trim()}`;
                     apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
                    const roleData = chatroomDetails.roles.find(r => r.name === updatedCharName);
                    const drawingTemplate = roleData?.drawingTemplate;
                    const drawingMasterEnabled = stateModule.config.toolSettings.drawingMaster?.enabled;
                    if (drawingTemplate && drawingTemplate.trim() !== '' && drawingMasterEnabled) {
                         await updateChatContextCache();
                         apiModule.triggerRoleResponse('drawingMaster', updatedCharName);
                    }
                }
                const addRoles = parsedResult.addRoles || [];
                const removeRoles = parsedResult.removeRoles || [];
                let roleStatesChanged = false;
                if (Array.isArray(addRoles)) {
                     for (const nameToAdd of addRoles) {
                         try {
                             if (typeof nameToAdd !== 'string' || nameToAdd.trim() === '') continue;
                             const trimmedName = nameToAdd.trim();
                             if (trimmedName === "管理员") continue;
                             const roleStates = chatroomDetails.config.roleStates || {};
                             if (roleStates[trimmedName] !== undefined) {
                                 await uiChatModule.selectRoleState(trimmedName, uiChatModule.ROLE_STATE_ACTIVE);
                                 roleStatesChanged = true;
                             const isPermanent = chatroomDetails.roles.some(r => r.name === trimmedName);
                             if (isPermanent) {
                                 if (!chatroomDetails.config.roleVisibility) {
                                     chatroomDetails.config.roleVisibility = {};
                                 }
                                 if (chatroomDetails.config.roleVisibility[trimmedName] !== true) {
                                     chatroomDetails.config.roleVisibility[trimmedName] = true;
                                     apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
                                     uiChatModule.updateRoleButtonsList();
                                     if (document.getElementById('role-list-page')?.classList.contains('active')) {
                                         uiSettingsModule.updateChatroomRolePage();
                                     }
                                 }
                             }
                             } else {
                                  const added = await uiChatModule.addTemporaryRole(trimmedName);
                                  if (added) {
                                      await uiChatModule.selectRoleState(trimmedName, uiChatModule.ROLE_STATE_ACTIVE);
                                      uiChatModule.updateRoleButtonsList();
                                      roleStatesChanged = true;
                                  }
                             }
                         } catch (addError) {
                             _logAndDisplayError(`Error adding/activating role '${nameToAdd}' from game host: ${addError.message}`, '_handlePostResponseActions');
                         }
                     }
                }
                 if (Array.isArray(removeRoles)) {
                     for (const nameToRemove of removeRoles) {
                         try {
                             if (typeof nameToRemove !== 'string' || nameToRemove.trim() === '') continue;
                             const trimmedName = nameToRemove.trim();
                             if (trimmedName === "管理员") continue;
                             const roleStates = chatroomDetails.config.roleStates || {};
                             if (roleStates[trimmedName] !== undefined) {
                                 const isPermanent = chatroomDetails.roles.some(r => r.name === trimmedName);
                                 if (isPermanent) {
                                     await uiChatModule.selectRoleState(trimmedName, uiChatModule.ROLE_STATE_DEFAULT);
                                 } else {
                                      await uiChatModule.deleteTemporaryRole(trimmedName, false);
                                 }
                                 roleStatesChanged = true;
                             }
                         } catch (removeError) {
                             _logAndDisplayError(`Error removing/deactivating role '${nameToRemove}' from game host: ${removeError.message}`, '_handlePostResponseActions');
                         }
                     }
                 }
                 let nextRoleToAct = parsedResult?.nextRoleToAct;
                 if (roleStatesChanged || nextRoleToAct) {
                     await updateChatContextCache();
                 }
                 if (nextRoleToAct && chatroomDetails && chatroomDetails.config.roleStates) {
                     const targetRoleState = chatroomDetails.config.roleStates[nextRoleToAct];
                     if (targetRoleState !== undefined) {
                         if (targetRoleState === uiChatModule.ROLE_STATE_ACTIVE) {
                             apiModule.triggerRoleResponse(nextRoleToAct);
                         } else if (targetRoleState === uiChatModule.ROLE_STATE_USER_CONTROL) {
                             uiChatModule.setPauseState(true);
                             uiChatModule._removePendingActionButton();
                             uiChatModule._createPendingActionButton(nextRoleToAct);
                         }
                     } else {
                         _logAndDisplayError(`Role ${roleName} specified next role ${nextRoleToAct}, but it was not found in the room's role states.`, '_handlePostResponseActions');
                     }
                 }
            }
        } else if ((roleType === 'role' || roleType === 'temporary_role') && !parserError) {
             let nextRoleToAct = parsedResult?.nextRoleToAct;
             let shouldTriggerGameHost = stateModule.config.toolSettings.gameHost?.enabled;
             if (shouldTriggerGameHost || nextRoleToAct) {
                 await updateChatContextCache();
             }
             if (shouldTriggerGameHost) {
                 apiModule.triggerRoleResponse('gameHost');
             }
            if (nextRoleToAct && chatroomDetails && chatroomDetails.config.roleStates) {
                 const targetRoleState = chatroomDetails.config.roleStates[nextRoleToAct];
                 if (targetRoleState !== undefined) {
                     if (targetRoleState === uiChatModule.ROLE_STATE_ACTIVE) {
                         apiModule.triggerRoleResponse(nextRoleToAct);
                     } else if (targetRoleState === uiChatModule.ROLE_STATE_USER_CONTROL) {
                         uiChatModule.setPauseState(true);
                         uiChatModule._removePendingActionButton();
                         uiChatModule._createPendingActionButton(nextRoleToAct);
                     }
                 } else {
                     _logAndDisplayError(`Role ${roleName} specified next role ${nextRoleToAct}, but it was not found in the room's role states.`, '_handlePostResponseActions');
                 }
            }
        } else if (roleName === 'drawingMaster' && parsedResult && !parserError) {
            const rawJsonText = messageContainer?.dataset?.rawJsonText || JSON.stringify(parsedResult || {});
            try {
                 const naiPayload = await apiModule._prepareNovelAiPayload(parsedResult, rawJsonText);
                 if (naiPayload) {
                     const messageId = messageContainer ? messageContainer.dataset.messageId : null;
                     apiModule.addNaiRequestToQueue(naiPayload, messageId);
                 }
            } catch (e) {
                 _logAndDisplayError(`Error preparing or queuing NovelAI request: ${e.message}`, '_handlePostResponseActions');
            }
         } else if (roleName === 'characterUpdateMaster' && parsedResult && !parserError) {
             const characterNameMatch = parsedResult.formattedUpdate?.match(/--- 更新后记忆 \((.*?)\) ---/);
             const characterName = characterNameMatch ? characterNameMatch[1] : null;
             if (characterName && chatroomDetails && chatroomDetails.config.roleDetailedStates) {
             } else if (!characterName) {
                  _logAndDisplayError(`CharacterUpdateMaster failed to find target character name in formattedUpdate`, '_handlePostResponseActions');
             }
         }
        uiChatModule.updateChatroomHistoryDisplay();
        uiChatModule.triggerDebouncedHistorySave();
    },
    displayAIResponse: (responseData, roleName, targetRoleName = null) => {
        const timestamp = Date.now();
        let roleType = 'unknown';
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (roleName && toolNameMap.hasOwnProperty(roleName)) {
            roleType = 'tool';
        } else if (chatroomDetails && roleName && chatroomDetails.config?.roleStates && (roleName in chatroomDetails.config.roleStates)) {
             const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
             roleType = isPermanent ? 'role' : 'temporary_role';
        }
        if (roleType === 'unknown') {
             _logAndDisplayError(`Could not determine role type for ${roleName} in displayAIResponse.`, 'displayAIResponse');
             return;
        }

        let messageObject;
        let messageContainer = null;
        let parsedResult = null;
        let parserError = null;
        let rawJson = responseData.text_content || '';
        if (responseData.error) {
            _logAndDisplayError(`Backend error for ${roleName}: ${responseData.error}`, 'displayAIResponse');
             return;
        } else if (roleName !== 'drawingMaster') {
            const msgId = uiChatModule._generateMessageId();
            const parseOutput = uiChatModule._parseAIResponse(rawJson, roleName, roleType);
            parsedResult = parseOutput.parsedResult;
            parserError = parseOutput.parserError;

            if (roleName === 'privateAssistant' && parserError) {
                 _logAndDisplayError(`Parser error for privateAssistant (will be retried): ${parserError}`, 'displayAIResponse');
                 return;
            }
            const formattedTextForHistory = uiChatModule._getFormattedDisplayText(parsedResult, roleType, roleName, parserError);
            messageObject = {
                id: msgId,
                timestamp: timestamp,
                sourceType: 'ai',
                roleName: roleName,
                roleType: roleType,
                targetRoleName: targetRoleName,
                speechActionText: formattedTextForHistory,
                rawJson: rawJson,
                parsedResult: parsedResult,
                displayMode: 'formatted',
                parserError: parserError,
                activeView: roleName === 'gameHost' ? 'time' : undefined
            };
            stateModule.currentChatHistoryData.push(messageObject);
            messageContainer = uiChatModule._appendMessageAndScroll(messageObject);
        } else {
             const parseOutput = uiChatModule._parseAIResponse(rawJson, roleName, roleType);
             parsedResult = parseOutput.parsedResult;
             parserError = parseOutput.parserError;
             if (parserError && parsedResult === null) {
                 _logAndDisplayError(`Drawing Master response parsing error: ${parserError}`, 'displayAIResponse');
             }
             apiModule._prepareNovelAiPayload(parsedResult, rawJson).then(naiPayload => {
                 if (naiPayload) {
                     apiModule.addNaiRequestToQueue(naiPayload);
                 }
             }).catch(e => {
                  _logAndDisplayError(`Error preparing or queuing NovelAI request: ${e.message}`, 'displayAIResponse');
             });
             return;
        }
        uiChatModule._handlePostResponseActions(messageContainer, roleName, roleType, parsedResult, parserError, targetRoleName);
    },
    formatStateObjectToText: (stateObj) => {
        if (!stateObj || typeof stateObj !== 'object') return '[Invalid state object]';
        let text = '';
        for (const key in stateObj) {
            if (stateObj.hasOwnProperty(key)) {
                 let value = stateObj[key];
                 if (typeof value === 'object' && value !== null) {
                      try { value = JSON.stringify(value); } catch(e) { value = '[Cannot serialize object]'; }
                 }
                 text += `${key}: ${value}\n`;
            }
        }
        return text.trim() || '[Empty state object]';
    },
    _createRoleNameButtonElement: (roleName, sourceType, messageContainer) => {
        const roleNameButton = document.createElement('div');
        roleNameButton.className = 'std-button role-name-button-above-bubble';
        let buttonText = '';
        if (roleName === 'privateAssistant') { buttonText = '‍💼'; }
        else if (roleName === 'characterUpdateMaster') { buttonText = '📇'; }
        else if (roleName === 'gameHost') { buttonText = '🎲'; }
        else if (roleName === 'drawingMaster') { buttonText = '🎨'; }
        else if (roleName === 'writingMaster') { buttonText = '🖋️'; }
        else if (roleName === '管理员') { buttonText = '📏'; }
        else {
            const bottomButton = uiChatModule.findBottomRoleButton(roleName);
            buttonText = bottomButton ? bottomButton.textContent : (roleName ? roleName.charAt(0).toUpperCase() : (sourceType === 'user' ? 'U' : 'AI'));
        }
        roleNameButton.textContent = buttonText;
        return roleNameButton;
    },
    _createMessageActionsElement: (sourceType, roleType, roleName, messageContainer) => {
        const messageActionsContainer = document.createElement('div');
        messageActionsContainer.className = 'message-actions-container';
        if (sourceType === 'ai') {
            const toggleButton = document.createElement('div');
            toggleButton.className = 'std-button message-action-button toggle-raw-button';
            toggleButton.textContent = '🔄';
            messageActionsContainer.appendChild(toggleButton);

            const messageId = messageContainer.dataset.messageId;
            const hasImage = stateModule.tempImageUrls[messageId];
            if (roleName === 'drawingMaster' && hasImage) {
                const redrawButton = document.createElement('div');
                redrawButton.className = 'std-button message-action-button redraw-button';
                redrawButton.textContent = '🖌️';
                messageActionsContainer.appendChild(redrawButton);
            }
            if (roleName === 'characterUpdateMaster') {
                const saveButton = document.createElement('div');
                saveButton.className = 'std-button message-action-button save-character-update-button';
                saveButton.textContent = '💾';
                messageActionsContainer.appendChild(saveButton);
            }
        }
        const deleteButton = document.createElement('div');
        deleteButton.className = 'std-button message-action-button delete-button';
        deleteButton.textContent = '✕';
        messageActionsContainer.appendChild(deleteButton);
        return messageActionsContainer;
    },
    _handleGameHostViewChange: (event) => {
         const button = event.currentTarget;
         const messageContainer = button.closest('.message-container');
         const viewToShow = button.dataset.view;
         if (!messageContainer || !viewToShow) return;
         const messageId = messageContainer.dataset.messageId;
         const messageObject = stateModule.currentChatHistoryData.find(msg => msg.id === messageId);
         if (!messageObject) return;
         messageObject.activeView = viewToShow;
         uiChatModule._renderGameHostContent(messageContainer, viewToShow);
         uiChatModule.triggerDebouncedHistorySave();
    },
     _createValueBlock: (value) => {
         if (value === null || value === undefined || value === '' || value === '无') return '';
         const span = document.createElement('span');
         span.className = 'value-block';
         span.textContent = String(value);
         return span.outerHTML;
     },
    _formatGameHostContent: (parsedResult, view) => {
        const createBlock = uiChatModule._createValueBlock;
        let content = '';
        if (!parsedResult || typeof parsedResult !== 'object' || !parsedResult.processedSceneContext || !parsedResult.processedCharacterInfo) {
            return createBlock('[Invalid Data Format]');
        }
        const scene = parsedResult.processedSceneContext;
        const charInfo = parsedResult.processedCharacterInfo;
        const icons = {
             map: '🗺️', people: '👥', name: '✨', demeanor: '😐', clothing: '👕', underwear: '👙',
             accessories: '💍', pose: '🤸', statusLong: '⚕️', statusShort: '🩹', action: '⚡',
             sceneOther: 'ℹ️', charOther: '📝'
        };

        const renderItems = (items, icon = '') => {
            if (!Array.isArray(items) || items.length === 0) return '';
            let itemHTML = '';
            items.forEach(item => { itemHTML += createBlock(item); });
            return `<div>${icon ? `<span class="icon">${icon}</span>` : ''}${itemHTML}</div>`;
        };

        switch (view) {
            case 'time':
                content = renderItems(scene.timeItems, '');
                break;
            case 'location':
                content += renderItems(scene.locationItems, icons.map);
                content += renderItems(scene.characterPositionItems, icons.people);
                content += renderItems(scene.otherSceneInfoItems, icons.sceneOther);
                break;
            case 'character':
                 if (!charInfo) {
                     content = `<div>${createBlock('[Character Info Unavailable]')}</div>`;
                     break;
                 }
                 content += `<div><span class="icon">${icons.name}</span>${createBlock(charInfo.characterName || '[Unknown Name]')}</div>`;
                 content += renderItems(charInfo.demeanorItems, icons.demeanor);
                 content += renderItems(charInfo.outerwearItems, icons.clothing);
                 content += renderItems(charInfo.underwearItems, icons.underwear);
                 content += renderItems(charInfo.accessories, icons.accessories);
                 content += renderItems(charInfo.actionPoseItems, icons.pose);
                 content += renderItems(charInfo.shortTermStatusItems, icons.statusShort);
                 content += renderItems(charInfo.longTermStatusItems, icons.statusLong);
                 content += renderItems(charInfo.currentActionItems, icons.action);
                 content += renderItems(charInfo.otherCharacterStatusItems, icons.charOther);
                 break;
            default:
                content = `<div>${createBlock('[Unknown View]')}</div>`;
        }
        return content || `<div>${createBlock('[No relevant data]')}</div>`;
    },
    _renderGameHostContent: (messageContainer, viewToShow) => {
         const contentDiv = messageContainer.querySelector('.game-host-content');
         const controlsDiv = messageContainer.querySelector('.game-host-controls');

         if (!contentDiv || !controlsDiv) return;
         const messageId = messageContainer.dataset.messageId;
         const messageObject = stateModule.currentChatHistoryData.find(msg => msg.id === messageId);
         if (!messageObject || messageObject.parserError || !messageObject.parsedResult?.processedSceneContext || !messageObject.parsedResult?.processedCharacterInfo) {
              contentDiv.innerHTML = uiChatModule._createValueBlock(messageObject?.parserError ? `[Parse Error: ${messageObject.parserError}]` : "[Cannot load data]");
              controlsDiv.querySelectorAll('.game-host-view-button').forEach(btn => btn.classList.remove('active'));
              return;
         }

         const formattedContent = uiChatModule._formatGameHostContent(messageObject.parsedResult, viewToShow);
         contentDiv.innerHTML = formattedContent;
         messageContainer.dataset.activeView = viewToShow;


         controlsDiv.querySelectorAll('.game-host-view-button').forEach(btn => {
             btn.classList.toggle('active', btn.dataset.view === viewToShow);
         });
    },
    showImageViewer: (imageSrc) => {
        if (!imageSrc || !elementsModule.imageViewerPage || !elementsModule.imageViewerContent) {
            return;
        }
        elementsModule.imageViewerContent.src = imageSrc;
        elementsModule.imageViewerPage.classList.add('active');
    },
    hideImageViewer: () => {
        if (!elementsModule.imageViewerPage || !elementsModule.imageViewerContent) {
             return;
        }
        elementsModule.imageViewerPage.classList.remove('active');
        elementsModule.imageViewerContent.src = '';
    },
    handleSetBackgroundClick: (event) => {
         const button = event.target.closest('.set-background-button');
         if (!button) return;
         const msgCont = button.closest('.message-container');
         if (!msgCont) return;
         const messageId = msgCont.dataset.messageId;
         const imageUrl = stateModule.tempImageUrls[messageId];
         const activeRoomName = stateModule.config.activeChatRoomName;
         if (!activeRoomName) {
             _logAndDisplayError("Cannot set background, no active chatroom.", "handleSetBackgroundClick");
             return;
         }
         if (imageUrl) {
             apiModule.setBackgroundImage(activeRoomName, imageUrl);
             uiChatModule.hideAllMessageActions();
         } else if (!imageUrl) {
              _logAndDisplayError("Cannot set background, image URL not found.", "handleSetBackgroundClick");
         }
    },
    handleDownloadImageLongPress: (event) => {
         const button = event.target.closest('.set-background-button');
         if (!button) return;
         const msgCont = button.closest('.message-container');
         if (!msgCont) return;
         const messageId = msgCont.dataset.messageId;
         const imageUrl = stateModule.tempImageUrls[messageId];
         if (imageUrl) {
             const a = document.createElement('a');
             a.href = imageUrl;
             a.download = `nai-image-${messageId}.png`;
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);
             uiChatModule.hideAllMessageActions();
         } else {
              _logAndDisplayError("Cannot download, image URL not found.", "handleDownloadImageLongPress");
         }
    },
    handleRedrawClick: async (msgCont) => {
        const messageId = msgCont.dataset.messageId;
        if (!messageId) return;
        const messageObject = stateModule.currentChatHistoryData.find(msg => msg.id === messageId);
        if (!messageObject || messageObject.roleName !== 'drawingMaster') {
            _logAndDisplayError(`Cannot redraw: Message ${messageId} not found or not a Drawing Master message.`, 'handleRedrawClick');
            return;
        }
        const rawJson = messageObject.rawJson;
        if (!rawJson) {
             _logAndDisplayError(`Cannot redraw: Raw JSON not found for message ${messageId}.`, 'handleRedrawClick');
             return;
        }
        const { parsedResult, parserError } = uiChatModule._parseAIResponse(rawJson, 'drawingMaster', 'tool');
        if (parserError) {
             _logAndDisplayError(`Failed to re-parse for redraw: ${parserError}`, 'handleRedrawClick');
             return;
        }
        try {
            const naiPayload = await apiModule._prepareNovelAiPayload(parsedResult, rawJson);
            if (naiPayload) {
                apiModule.addNaiRequestToQueue(naiPayload, messageId);
            }
        } catch (e) {
            _logAndDisplayError(`Error preparing redraw request: ${e.message}`, 'handleRedrawClick');
        } finally {
            uiChatModule.hideAllMessageActions();
        }
    },
    displayChatMessageElement: (messageObject) => {
        if (!messageObject || !messageObject.id) {
            return null;
        }
        const {
            id, timestamp, sourceType, roleName, roleType, targetRoleName,
            speechActionText, rawJson, parsedResult, displayMode, parserError, activeView, naiPayloadSource
        } = messageObject;
        const messageContainer = document.createElement('div');
        messageContainer.className = `message-container`;
        messageContainer.dataset.messageId = id;
        messageContainer.dataset.displayMode = displayMode || 'formatted';
        messageContainer.dataset.roleName = roleName || '';
        if (targetRoleName) messageContainer.dataset.targetRoleName = targetRoleName;
        messageContainer.dataset.sourceType = sourceType;
        messageContainer.dataset.roleType = roleType;
        const currentActiveView = activeView || (roleName === 'gameHost' ? 'time' : undefined);
        if (currentActiveView) messageContainer.dataset.activeView = currentActiveView;
        if (naiPayloadSource && typeof naiPayloadSource === 'object') messageContainer.dataset.naiPayloadSource = JSON.stringify(naiPayloadSource);
        else if (naiPayloadSource) messageContainer.dataset.naiPayloadSource = naiPayloadSource;
        if (rawJson) messageContainer.dataset.rawJsonText = rawJson;
        const roleNameButton = uiChatModule._createRoleNameButtonElement(roleName, sourceType, messageContainer);
        messageContainer.appendChild(roleNameButton);
        const messageDiv = document.createElement('div');
        messageDiv.className = sourceType === 'user' ? 'user-message' : 'ai-response';
        const isGameHost = roleName === 'gameHost' && sourceType === 'ai';
        const isDrawingMaster = roleName === 'drawingMaster' && sourceType === 'ai';
        const isPrivateAssistant = roleName === 'privateAssistant' && sourceType === 'ai';
        const isCharacterUpdateMaster = roleName === 'characterUpdateMaster' && sourceType === 'ai';
        const isStandardRole = (roleType === 'role' || roleType === 'temporary_role') && sourceType === 'ai';
        let hasImage = false;
        let formattedTextToDisplay = speechActionText;
        if (parsedResult) {
             if (isStandardRole && parsedResult.formattedText) formattedTextToDisplay = parsedResult.formattedText;
             else if (isCharacterUpdateMaster && parsedResult.formattedUpdate) formattedTextToDisplay = parsedResult.formattedUpdate;
             else if (isPrivateAssistant && parsedResult.responseContent) formattedTextToDisplay = parsedResult.responseContent;
        }
        if (isGameHost) {
             messageDiv.innerHTML = '';
             const controlsDiv = document.createElement('div');
             controlsDiv.className = 'game-host-controls';
             ['time', 'location', 'character'].forEach(view => {
                 const btn = document.createElement('div');
                 btn.className = 'std-button game-host-view-button';
                 btn.dataset.view = view;
                 btn.textContent = view === 'time' ? '🕒' : (view === 'location' ? '📍' : '👤');
                 btn.addEventListener('click', uiChatModule._handleGameHostViewChange);
                 controlsDiv.appendChild(btn);
             });
             messageDiv.appendChild(controlsDiv);
             const contentDiv = document.createElement('div');
             contentDiv.className = 'game-host-content';
             messageDiv.appendChild(contentDiv);
             const rawDiv = document.createElement('div');
             rawDiv.className = 'game-host-raw';
             rawDiv.style.display = 'none';
             rawDiv.textContent = rawJson || '';
             messageDiv.appendChild(rawDiv);
             if (displayMode === 'raw') {
                 controlsDiv.style.display = 'none';
                 contentDiv.style.display = 'none';
                 rawDiv.style.display = 'block';
             } else {
                 uiChatModule._renderGameHostContent(messageContainer, currentActiveView);
             }
        } else if (isDrawingMaster) {
             const imageUrl = stateModule.tempImageUrls[id];
             if (imageUrl) {
                 const img = document.createElement('img');
                 img.src = imageUrl;
                 img.alt = formattedTextToDisplay || "[AI Generated Image]";
                 img.addEventListener('click', (event) => uiChatModule.showImageViewer(event.target.src));
                 messageDiv.innerHTML = '';
                 messageDiv.appendChild(img);
                 hasImage = true;
             } else {
                 messageDiv.textContent = formattedTextToDisplay || "[Image Loading or Error]";
             }
        } else if (displayMode === 'raw' && sourceType === 'ai') {
             messageDiv.textContent = rawJson || '';
        } else {
             messageDiv.textContent = formattedTextToDisplay;
        }
        messageContainer.appendChild(messageDiv);
        const messageActionsContainer = uiChatModule._createMessageActionsElement(sourceType, roleType, roleName, messageContainer);
        if (hasImage && messageActionsContainer) {
             let backgroundButton = messageActionsContainer.querySelector('.set-background-button');
             if (!backgroundButton) {
                 backgroundButton = document.createElement('div');
                 backgroundButton.className = 'std-button message-action-button set-background-button';
                 backgroundButton.textContent = '🖼️';
                 const redrawBtn = messageActionsContainer.querySelector('.redraw-button');
                 if(redrawBtn) {
                      messageActionsContainer.insertBefore(backgroundButton, redrawBtn);
                 } else {
                      const deleteBtn = messageActionsContainer.querySelector('.delete-button');
                      if(deleteBtn) {
                          messageActionsContainer.insertBefore(backgroundButton, deleteBtn);
                      } else {
                           messageActionsContainer.appendChild(backgroundButton);
                      }
                 }
             }
        }
        messageContainer.appendChild(messageActionsContainer);
        return messageContainer;
    },
     toggleRawJsonDisplay: (msgCont) => {
         const messageId = msgCont.dataset.messageId;
         if (msgCont.dataset.sourceType !== 'ai' || !messageId) return;
         const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === messageId);
         if (messageIndex === -1) {
             _logAndDisplayError(`Cannot find message data for ID ${messageId} during toggleRawJsonDisplay.`, 'toggleRawJsonDisplay');
             return;
         }
         const messageObject = stateModule.currentChatHistoryData[messageIndex];
         const roleName = messageObject.roleName;
         const isGameHost = roleName === 'gameHost';
         const isDrawingMaster = roleName === 'drawingMaster';
         const div = msgCont.querySelector('.ai-response');
         if (!div) return;
         const currentMode = messageObject.displayMode;
         const rawTextContent = messageObject.rawJson || '';
         if (currentMode === 'formatted') {
             messageObject.displayMode = 'raw';
             msgCont.dataset.displayMode = 'raw';
             if (isGameHost) {
                  const controlsDiv = div.querySelector('.game-host-controls');
                  const contentDiv = div.querySelector('.game-host-content');
                  const rawDiv = div.querySelector('.game-host-raw');
                  if (controlsDiv) controlsDiv.style.display = 'none';
                  if (contentDiv) contentDiv.style.display = 'none';
                  if (rawDiv) {
                      rawDiv.textContent = rawTextContent;
                      rawDiv.style.display = 'block';
                  }
             } else {
                 div.textContent = rawTextContent;
             }
         } else {
             messageObject.displayMode = 'formatted';
             msgCont.dataset.displayMode = 'formatted';
             const parsedResult = messageObject.parsedResult;
             const parserError = messageObject.parserError;
             const formattedText = uiChatModule._getFormattedDisplayText(parsedResult, messageObject.roleType, roleName, parserError);
             if (isGameHost) {
                  const controlsDiv = div.querySelector('.game-host-controls');
                  const contentDiv = div.querySelector('.game-host-content');
                  const rawDiv = div.querySelector('.game-host-raw');
                  if (controlsDiv) controlsDiv.style.display = 'flex';
                  if (contentDiv) contentDiv.style.display = '';
                  if (rawDiv) rawDiv.style.display = 'none';
                  uiChatModule._renderGameHostContent(msgCont, messageObject.activeView || 'time');
             } else if (isDrawingMaster) {
                  const imageUrl = stateModule.tempImageUrls[messageId];
                  if (imageUrl) {
                      const img = document.createElement('img');
                      img.src = imageUrl;
                      img.alt = formattedText || "[AI Generated Image]";
                      img.addEventListener('click', (event) => uiChatModule.showImageViewer(event.target.src));
                      div.innerHTML = '';
                      div.appendChild(img);
                  } else {
                      div.textContent = formattedText || "[Image Loading or Error]";
                  }
             } else {
                   div.textContent = formattedText;
             }
         }
         updateChatContextCache();
         uiChatModule.triggerDebouncedHistorySave();
     },
    findBottomRoleButton: (roleName) => {
        if (!roleName) return null;
        const btns = elementsModule.roleButtonsListContainer.querySelectorAll('.role-button-container > .std-button');
        for (const btn of btns) {
            if (btn.dataset.roleName === roleName) return btn;
        }
        return null;
    },
    toggleMessageActions: (msgCont) => {
        const ac = msgCont.querySelector('.message-actions-container');
        if (ac) {
            if (stateModule.activeMessageActions === msgCont) {
                ac.classList.remove('active');
                stateModule.activeMessageActions = null;
            } else {
                uiChatModule.hideAllMessageActions();
                ac.classList.add('active');
                stateModule.activeMessageActions = msgCont;
            }
        }
    },
    hideAllMessageActions: () => {
        if (stateModule.activeMessageActions) {
            const ac = stateModule.activeMessageActions.querySelector('.message-actions-container');
            if (ac) ac.classList.remove('active');
            stateModule.activeMessageActions = null;
        }
    },
    toggleMessageEditMode: (msgCont) => {
        const div = msgCont.querySelector('.user-message') || msgCont.querySelector('.ai-response');
        const roleName = msgCont.dataset.roleName;
        const isGameHost = roleName === 'gameHost';
        const isCharacterUpdateMaster = roleName === 'characterUpdateMaster';
        const displayMode = msgCont.dataset.displayMode;
        if (!div) return;
        let targetElement = div;
        let isEditingRaw = false;
        if (isGameHost && displayMode !== 'raw') {
             return;
        } else if (isGameHost && displayMode === 'raw') {
             targetElement = msgCont.querySelector('.game-host-raw');
             if (!targetElement) targetElement = div;
             isEditingRaw = true;
        } else if (roleName === 'drawingMaster' && displayMode === 'formatted') {
             return;
        } else if (displayMode === 'raw' && msgCont.dataset.sourceType === 'ai') {
             isEditingRaw = true;
        }
        const isEditing = targetElement.getAttribute('contenteditable') === 'true';
        const messageId = msgCont.dataset.messageId;
        if (isEditing) {
            targetElement.removeAttribute('contenteditable');
            targetElement.style.backgroundColor = '';
             if (targetElement._blurHandler) targetElement.removeEventListener('blur', targetElement._blurHandler);
             if (targetElement._keydownHandler) targetElement.removeEventListener('keydown', targetElement._keydownHandler);
             delete targetElement._blurHandler;
             delete targetElement._keydownHandler;
            if (stateModule.editingMessageContainer === msgCont) stateModule.editingMessageContainer = null;
            uiChatModule.saveEditedMessage(msgCont);
        } else {
             const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === messageId);
             if (messageIndex === -1) {
                 targetElement.textContent = "[Cannot load content for editing]";
                 _logAndDisplayError(`Cannot find message data for ID ${messageId} during toggleMessageEditMode.`, 'toggleMessageEditMode');
                 return;
             }
            const messageObject = stateModule.currentChatHistoryData[messageIndex];
            uiChatModule.hideAllMessageActions();
            let editText = '';
            if (isEditingRaw) {
                editText = messageObject.rawJson || '';
            } else if (isCharacterUpdateMaster) {
                 editText = messageObject.parsedResult?.formattedUpdate || messageObject.speechActionText || '';
            } else {
                 editText = messageObject.speechActionText || '';
            }

            targetElement.innerText = editText;
            targetElement.setAttribute('contenteditable', 'true');
            targetElement.style.backgroundColor = '#FFFFFF';
            targetElement.focus();
            try { const selection = window.getSelection(); const range = document.createRange(); range.selectNodeContents(targetElement); range.collapse(false); selection.removeAllRanges(); selection.addRange(range); } catch(e) {}
            const blurH = () => uiChatModule.saveEditedMessage(msgCont);
            const keydownH = (e) => uiChatModule.handleEnterKeyInEditMode(e, msgCont);
            if (targetElement._blurHandler) targetElement.removeEventListener('blur', targetElement._blurHandler);
            if (targetElement._keydownHandler) targetElement.removeEventListener('keydown', targetElement._keydownHandler);
            targetElement.addEventListener('blur', blurH);
            targetElement.addEventListener('keydown', keydownH);
            targetElement._blurHandler = blurH;
            targetElement._keydownHandler = keydownH;
            stateModule.editingMessageContainer = msgCont;
        }
    },
    handleEnterKeyInEditMode: (e, msgCont) => {
    },
    saveEditedMessage: (msgCont) => {
        if (!msgCont) return;
        const roleName = msgCont.dataset.roleName;
        const roleType = msgCont.dataset.roleType;
        const sourceType = msgCont.dataset.sourceType;
        const isGameHost = roleName === 'gameHost';
        const isCharacterUpdateMaster = roleName === 'characterUpdateMaster';
        const isPrivateAssistant = roleName === 'privateAssistant';
        const displayMode = msgCont.dataset.displayMode;
        let targetElement;
        let wasEditingRaw = false;
        if (isGameHost && displayMode !== 'raw') {
            return;
        } else if (isGameHost && displayMode === 'raw') {
            targetElement = msgCont.querySelector('.game-host-raw');
            wasEditingRaw = true;
        } else if (displayMode === 'raw' && sourceType === 'ai') {
            targetElement = msgCont.querySelector('.ai-response');
            wasEditingRaw = true;
        } else {
            targetElement = msgCont.querySelector('.user-message') || msgCont.querySelector('.ai-response');
        }
        if (!targetElement || targetElement.getAttribute('contenteditable') !== 'true') {
            if (stateModule.editingMessageContainer === msgCont) stateModule.editingMessageContainer = null;
            return;
        }
        const newText = targetElement.innerText;
        const messageId = msgCont.dataset.messageId;
        let changed = false;
        const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === messageId);
        if (messageIndex === -1) {
            targetElement.removeAttribute('contenteditable');
            targetElement.style.backgroundColor = '';
            if (stateModule.editingMessageContainer === msgCont) stateModule.editingMessageContainer = null;
            _logAndDisplayError(`Failed to save edit: Cannot find message ID ${messageId}`, 'saveEditedMessage');
            return;
        }
        const messageObject = stateModule.currentChatHistoryData[messageIndex];
        if (wasEditingRaw) {
            const currentRaw = messageObject.rawJson || '';
            if (currentRaw !== newText) {
                messageObject.rawJson = newText;
                const { parsedResult, parserError } = uiChatModule._parseAIResponse(newText, roleName, roleType);
                messageObject.parsedResult = parsedResult;
                messageObject.parserError = parserError;
                messageObject.speechActionText = uiChatModule._getFormattedDisplayText(parsedResult, roleType, roleName, parserError);
                messageObject.displayMode = 'formatted';
                msgCont.dataset.displayMode = 'formatted';
                changed = true;
            }
        } else {
             let currentDisplayValue = '';
              if (isCharacterUpdateMaster) {
                  currentDisplayValue = messageObject.parsedResult?.formattedUpdate || messageObject.speechActionText || '';
              } else if (isPrivateAssistant) {
                   currentDisplayValue = messageObject.parsedResult?.responseContent || messageObject.speechActionText || '';
              }
              else {
                  currentDisplayValue = messageObject.speechActionText || '';
              }
              if (currentDisplayValue !== newText) {
                  messageObject.speechActionText = newText;
                  if (isCharacterUpdateMaster && messageObject.parsedResult) {
                      messageObject.parsedResult.formattedUpdate = newText;
                  } else if (isPrivateAssistant && messageObject.parsedResult) {
                      messageObject.parsedResult.responseContent = newText;
                  } else if (roleType === 'role' || roleType === 'temporary_role') {
                        if(messageObject.parsedResult) messageObject.parsedResult.formattedText = newText;
                  } else if (roleName === 'writingMaster') {
                       if(messageObject.parsedResult) messageObject.parsedResult.description = newText;
                  }
                  targetElement.textContent = messageObject.speechActionText;
                  changed = true;
              }
        }
        targetElement.removeAttribute('contenteditable');
        targetElement.style.backgroundColor = '';
        if (targetElement._blurHandler) targetElement.removeEventListener('blur', targetElement._blurHandler);
        if (targetElement._keydownHandler) targetElement.removeEventListener('keydown', targetElement._keydownHandler);
        delete targetElement._blurHandler;
        delete targetElement._keydownHandler;
        if (stateModule.editingMessageContainer === msgCont) stateModule.editingMessageContainer = null;
        if (changed && wasEditingRaw) {
             const mainDiv = msgCont.querySelector('.ai-response');
             if (isGameHost) {
                 const controlsDiv = mainDiv.querySelector('.game-host-controls');
                 const rawDiv = mainDiv.querySelector('.game-host-raw');
                 if (controlsDiv) controlsDiv.style.display = 'flex';
                 if (rawDiv) rawDiv.style.display = 'none';
                 uiChatModule._renderGameHostContent(msgCont, messageObject.activeView || 'time');
             } else if (roleName === 'drawingMaster') {
                  const imageUrl = stateModule.tempImageUrls[messageId];
                  if (imageUrl) {
                      const img = document.createElement('img'); img.src = imageUrl; img.alt = messageObject.speechActionText;
                      img.addEventListener('click', (event) => uiChatModule.showImageViewer(event.target.src));
                      mainDiv.innerHTML = ''; mainDiv.appendChild(img);
                  } else { mainDiv.textContent = messageObject.speechActionText || "[Image Loading or Error]"; }
             } else {
                  mainDiv.textContent = messageObject.speechActionText;
             }
        }
        if (changed) {
            updateChatContextCache();
            uiChatModule.updateChatroomHistoryDisplay();
            uiChatModule.triggerDebouncedHistorySave();
        }
    },
    deleteMessage: (msgCont) => {
        const messageId = msgCont.dataset.messageId;
        if (!messageId) {
             return;
        }
        const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === messageId);
         if (messageIndex > -1) {
             stateModule.currentChatHistoryData.splice(messageIndex, 1);
         }
        msgCont.remove();
        if (stateModule.tempImageUrls[messageId]) {
             delete stateModule.tempImageUrls[messageId];
             const imgIndex = stateModule.displayedImageOrder.indexOf(messageId);
             if (imgIndex > -1) stateModule.displayedImageOrder.splice(imgIndex, 1);
             stateModule.displayedImageCount--;
        }
        updateChatContextCache();
        uiChatModule.updateChatroomHistoryDisplay();
        uiChatModule.triggerDebouncedHistorySave();
    },
    deleteMessageAndBelow: (msgCont) => {
         const messageId = msgCont.dataset.messageId;
         if (!messageId) {
             return;
         }
         const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === messageId);
         if (messageIndex === -1) {
             return;
         }
         const messagesToRemove = stateModule.currentChatHistoryData.slice(messageIndex);
         const messageIdsToRemove = messagesToRemove.map(msg => msg.id);
         const allMessageElements = Array.from(elementsModule.chatArea.children);
         for (let i = allMessageElements.length - 1; i >= 0; i--) {
             const el = allMessageElements[i];
             const elId = el.dataset.messageId;
             if (messageIdsToRemove.includes(elId)) {
                 el.remove();
             }
         }
         messagesToRemove.forEach(msg => {
             if (stateModule.tempImageUrls[msg.id]) {
                 delete stateModule.tempImageUrls[msg.id];
                 const imgIndex = stateModule.displayedImageOrder.indexOf(msg.id);
                 if (imgIndex > -1) stateModule.displayedImageOrder.splice(imgIndex, 1);
                 stateModule.displayedImageCount--;
             }
         });
         stateModule.currentChatHistoryData.splice(messageIndex);
         updateChatContextCache();
         uiChatModule.updateChatroomHistoryDisplay();
         uiChatModule.triggerDebouncedHistorySave();
    },
    clearChatArea: () => {
        elementsModule.chatArea.innerHTML = '';
        stateModule.currentChatHistoryData = [];
        stateModule.tempImageUrls = {};
        stateModule.displayedImageCount = 0;
        stateModule.displayedImageOrder = [];
        uiChatModule._removePendingActionButton();
    },
    triggerDebouncedHistorySave: () => {
        clearTimeout(stateModule.historySaveDebounceTimer);
        stateModule.historySaveDebounceTimer = setTimeout(() => {
            uiChatModule.saveChatHistoryToServer();
        }, stateModule.historySaveDebounceDelay);
    },
    saveChatHistoryToServer: async () => {
        const roomName = stateModule.config.activeChatRoomName;
        if (!roomName) return;
        const historyToSave = stateModule.currentChatHistoryData.map(msg => {
             let savedParsedResult = null;
             if (msg.parsedResult && typeof msg.parsedResult === 'object') {
                try {
                    savedParsedResult = JSON.stringify(msg.parsedResult);
                } catch (e) {
                     savedParsedResult = JSON.stringify({ error: `Serialization failed: ${e.message}` });
                     _logAndDisplayError(`Failed to stringify parsedResult for msg ${msg.id}: ${e.message}`, 'saveChatHistoryToServer');
                }
             } else if (msg.parsedResult) {
                 savedParsedResult = String(msg.parsedResult);
             }
            const savedMsg = {
                id: msg.id,
                timestamp: msg.timestamp,
                sourceType: msg.sourceType,
                roleName: msg.roleName,
                roleType: msg.roleType,
                targetRoleName: msg.targetRoleName,
                speechActionText: msg.speechActionText,
                rawJson: msg.rawJson,
                displayMode: msg.displayMode,
                parserError: msg.parserError,
                activeView: msg.activeView,
                parsedResult: savedParsedResult,
                naiPayloadSource: msg.naiPayloadSource ? JSON.stringify(msg.naiPayloadSource) : null
             };

             if (savedMsg.naiPayloadSource === 'null') delete savedMsg.naiPayloadSource;
             if (savedMsg.parsedResult === null || savedMsg.parsedResult === 'null') delete savedMsg.parsedResult;
            return savedMsg;
        });
        try {
            const response = await fetch(`/history/${encodeURIComponent(roomName)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(historyToSave)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Failed to save history: ${response.status} ${errorData.error || ''}`);
            }
        } catch (error) {
            _logAndDisplayError(`Error saving history for ${roomName}: ${error.message}`, 'saveChatHistoryToServer');
        }
    },
    loadChatHistory: async (roomName) => {
        uiChatModule.clearChatArea();
        if (!roomName) return;
        let historyData = [];
        try {
            const response = await fetch(`/history/${encodeURIComponent(roomName)}`);
            if (response.ok) {
                historyData = await response.json();
            } else if (response.status !== 404) {
                throw new Error(`Failed to load history: ${response.status}`);
            }
        } catch (error) {
             _logAndDisplayError(`Error loading history for ${roomName}: ${error.message}`, 'loadChatHistory');
        }
        stateModule.currentChatHistoryData = [];
        const frag = document.createDocumentFragment();
        historyData.forEach(msg => {
             if (!msg || typeof msg !== 'object') {
                 return;
             }
             let parsedResult = null;
             if (msg.parsedResult && typeof msg.parsedResult === 'string') {
                try {
                    parsedResult = JSON.parse(msg.parsedResult);
                } catch (e) {
                    parsedResult = { error: `Failed to parse stored parsedResult: ${e.message}` };
                    msg.parserError = msg.parserError || `Failed to parse stored parsedResult: ${e.message}`;
                    msg.displayMode = 'formatted';
                    msg.speechActionText = `[Load Parse Error: ${e.message}]`;
                }
             } else if (msg.parsedResult !== undefined && msg.parsedResult !== null) {
                 parsedResult = msg.parsedResult;
             }
             let naiPayloadSource = null;
              if (msg.naiPayloadSource && typeof msg.naiPayloadSource === 'string') {
                  try {
                      naiPayloadSource = JSON.parse(msg.naiPayloadSource);
                  } catch (e) {
                       _logAndDisplayError(`Failed to parse naiPayloadSource for msg ${msg.id}: ${e.message}`, 'loadChatHistory');
                  }
              } else if (msg.naiPayloadSource) {
                   naiPayloadSource = msg.naiPayloadSource;
              }

             const messageObject = {
                id: msg.id || uiChatModule._generateMessageId(),
                timestamp: msg.timestamp || Date.now(),
                sourceType: msg.sourceType,
                roleName: msg.roleName,
                roleType: msg.roleType,
                targetRoleName: msg.targetRoleName,
                speechActionText: msg.speechActionText,
                rawJson: msg.rawJson,
                parsedResult: parsedResult,
                displayMode: msg.displayMode || 'formatted',
                parserError: msg.parserError,
                activeView: msg.activeView || (msg.roleName === 'gameHost' ? 'time' : undefined),
                naiPayloadSource: naiPayloadSource
             };
             if (messageObject.roleName === 'drawingMaster' && messageObject.sourceType === 'ai' && !messageObject.parserError && !naiPayloadSource && parsedResult) {
                  messageObject.naiPayloadSource = parsedResult;
             }

            stateModule.currentChatHistoryData.push(messageObject);
            const el = uiChatModule.displayChatMessageElement(messageObject);
            if (el) frag.appendChild(el);
        });
        elementsModule.chatArea.appendChild(frag);
        if (elementsModule.chatArea.scrollHeight > elementsModule.chatArea.clientHeight) {
             elementsModule.chatArea.scrollTop = elementsModule.chatArea.scrollHeight;
        }
        await updateChatContextCache();
        uiChatModule.updateChatroomHistoryDisplay();
    },
    updateChatroomHistoryDisplay: () => {
        let historyText = "";
        const lines = [];
        stateModule.currentChatHistoryData.forEach(messageObject => {
             const roleType = messageObject.roleType;
             const roleName = messageObject.roleName;
             let displayContent = messageObject.speechActionText || '';
             if (messageObject.parsedResult) {
                 if ((roleType === 'role' || roleType === 'temporary_role') && messageObject.parsedResult.formattedText) {
                     displayContent = messageObject.parsedResult.formattedText;
                 } else if (roleName === 'characterUpdateMaster' && messageObject.parsedResult.formattedUpdate) {
                     displayContent = messageObject.parsedResult.formattedUpdate;
                 } else if (roleName === 'privateAssistant' && messageObject.parsedResult.responseContent) {
                      displayContent = messageObject.parsedResult.responseContent;
                 }
             }
             if (roleType === 'role' || roleType === 'temporary_role' || (roleType === 'tool' && roleName === 'privateAssistant')) {
                 const actorName = roleName || (messageObject.sourceType === 'user' ? 'User' : 'AI');
                 let content = (displayContent || '').trim();
                 if (content && content !== "[图片绘制]") {
                    if(roleName === 'privateAssistant') {
                        lines.push(content);
                    } else {
                        lines.push(`${actorName}：\n${content}`);
                    }
                 }
             } else if (roleName === 'gameHost' && messageObject.sourceType === 'ai' && messageObject.parsedResult && !messageObject.parserError) {

             }
        });
        historyText = lines.join('\n');
        if (elementsModule.chatroomHistoryDisplay) {
            elementsModule.chatroomHistoryDisplay.value = historyText;
        }
    },
    getLatestRoleStateText: (name) => {
        if (stateModule.chatContextCache) {
             return stateModule.chatContextCache.roleDetailedStates[name] || `[${name} state not in cache]`;
        }
        return `[${name} state unavailable - cache empty]`;
    },
    toggleRunPause: function() {
        const wasPaused = stateModule.config.isRunPaused;
        stateModule.config.isRunPaused = !stateModule.config.isRunPaused;
        elementsModule.runPauseButton.textContent = stateModule.config.isRunPaused ? '▶' : '◼';
        const triggerList = elementsModule.activeRoleTriggerList;
        if (triggerList) triggerList.style.display = 'none';
        if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
            mainModule.triggerDebouncedSave();
        }
        if (wasPaused && !stateModule.config.isRunPaused) {
            const chatroomDetails = stateModule.currentChatroomDetails;
            if (chatroomDetails && chatroomDetails.config?.roleStates) {
                const roleStates = chatroomDetails.config.roleStates;
                const activeRoles = Object.entries(roleStates)
                    .filter(([name, state]) => state === uiChatModule.ROLE_STATE_ACTIVE)
                    .map(([name, state]) => name);
                if (activeRoles.length === 1) {
                    apiModule.triggerRoleResponse(activeRoles[0]);
                } else if (activeRoles.length > 1) {
                    uiChatModule.showActiveRoleTriggerList(activeRoles);
                }
            }
            const gameHostEnabled = stateModule.config.toolSettings.gameHost?.enabled;
            const lastActorName = stateModule.chatContextCache?.lastActor;
            const roleStates = stateModule.currentChatroomDetails?.config?.roleStates;
            if (gameHostEnabled && lastActorName && roleStates) {
                const lastActorState = roleStates[lastActorName];
                if (lastActorState === uiChatModule.ROLE_STATE_USER_CONTROL) {
                    apiModule.triggerRoleResponse('gameHost');
                }
            }
            const lastMessage = stateModule.currentChatHistoryData[stateModule.currentChatHistoryData.length - 1];
            if (lastMessage && lastMessage.sourceType === 'user') {
                 let text = lastMessage.speechActionText;
                 if(lastMessage.parsedResult?.formattedText) text = lastMessage.parsedResult.formattedText;
                 const writingMasterEnabled = stateModule.config.toolSettings.writingMaster?.enabled;
                 if (text && writingMasterEnabled) {
                     const keywords = ['看', '听', '闻', '模', '尝'];
                     const containsKeyword = keywords.some(keyword => text.includes(keyword));
                     if (containsKeyword) {
                          apiModule.triggerRoleResponse('writingMaster');
                     }
                 }
            }
        }
        if (stateModule.config.isRunPaused) {
            uiChatModule._removePendingActionButton();
        }
    },
    showActiveRoleTriggerList: (activeRoleNames) => {
        const listContainer = elementsModule.activeRoleTriggerList;
        if (!listContainer) return;
        listContainer.innerHTML = '';
        activeRoleNames.forEach(roleName => {
            const button = document.createElement('div');
            button.className = 'active-role-trigger-button';
            button.textContent = roleName;
            button.dataset.roleName = roleName;
            button.addEventListener('click', () => {
                listContainer.style.display = 'none';
                apiModule.triggerRoleResponse(roleName);
            });
            listContainer.appendChild(button);
        });
        listContainer.style.display = 'flex';
    },
    setPauseState: function(shouldPause) {
        if (shouldPause && !stateModule.config.isRunPaused) {
            uiChatModule.toggleRunPause();
        } else if (!shouldPause && stateModule.config.isRunPaused) {
            uiChatModule.toggleRunPause();
        }
    },
    toggleRoleList: () => {
        stateModule.config.isRoleListVisible = !stateModule.config.isRoleListVisible;
        elementsModule.roleButtonsListContainer.style.display = stateModule.config.isRoleListVisible ? 'flex' : 'none';
        if (typeof mainModule !== 'undefined' && mainModule.triggerDebouncedSave) {
            mainModule.triggerDebouncedSave();
        }
        if (!stateModule.config.isRoleListVisible) {
            uiChatModule.hideRoleStateButtons();
        }
    },
    handleRoleDefaultStateLongPress: (roleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !chatroomDetails.config || !chatroomDetails.config.roleVisibility) {
            return;
        }
        const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
        if (!isPermanent || roleName === "管理员") return;

        chatroomDetails.config.roleVisibility[roleName] = false;
        apiModule.triggerDebouncedChatroomConfigSave(chatroomDetails.config.name);
        uiChatModule.updateRoleButtonsList();

        const settingsRoleListPageActive = document.getElementById('role-list-page')?.classList.contains('active');
        if (settingsRoleListPageActive) {
             const checkbox = elementsModule.roleListContainer.querySelector(`.role-visibility-checkbox[data-role-name="${roleName}"]`);
             if (checkbox) {
                 checkbox.checked = false;
             }
        }
        uiChatModule.hideRoleStateButtons();
    },
    updateRoleButtonsList: () => {
        const frag = document.createDocumentFragment();
        const chatroomDetails = stateModule.currentChatroomDetails;
        const usedChars = new Set();
        const roleDataForButtons = [];
        if (chatroomDetails && chatroomDetails.config?.roleStates) {
            const roleStates = chatroomDetails.config.roleStates;
            const roleVisibility = chatroomDetails.config.roleVisibility || {};
            const permanentRoles = new Set(chatroomDetails.roles.map(r => r.name));
            const allRoleNames = Object.keys(roleStates);
            const sortedRoleNames = allRoleNames.sort((a, b) => {
                const isTempA = !permanentRoles.has(a);
                const isTempB = !permanentRoles.has(b);
                if (isTempA && !isTempB) return -1;
                if (!isTempA && isTempB) return 1;
                if (a === "管理员") return -1;
                if (b === "管理员") return 1;
                return a.localeCompare(b);
            });
            sortedRoleNames.forEach(name => {
                 if (name === "管理员") return;
                 const isPermanent = permanentRoles.has(name);
                 const isVisible = roleVisibility[name] ?? true;
                 if (isPermanent && !isVisible) {
                     return;
                 }
                 const isTemporary = !isPermanent;
                 const char1 = name.charAt(0).toUpperCase();
                 let charToUse = null;
                 if (!usedChars.has(char1)) {
                     charToUse = char1; usedChars.add(char1);
                 } else {
                     const charL = name.charAt(name.length - 1).toUpperCase();
                     if (!usedChars.has(charL)) { charToUse = charL; usedChars.add(charL); }
                     else {
                         let fallbackChar = name.charAt(0).toUpperCase() + '2';
                         let i = 2;
                         while (usedChars.has(fallbackChar)) { fallbackChar = name.charAt(0).toUpperCase() + ++i; }
                         charToUse = fallbackChar; usedChars.add(fallbackChar);
                     }
                 }
                 roleDataForButtons.push({ name, char: charToUse, isTemporary });
            });
            roleDataForButtons.forEach(({ name, char, isTemporary }) => {
                const cont = document.createElement('div'); cont.className = 'role-button-container';
                const btn = document.createElement('div'); btn.className = 'std-button'; btn.textContent = char; btn.dataset.roleName = name;
                if (isTemporary) {
                    btn.style.backgroundColor = 'white';
                    btn.style.color = '#3a3a3a';
                    btn.style.borderColor = '#3a3a3a';
                }
                cont.appendChild(btn);
                const statesDiv = document.createElement('div'); statesDiv.className = 'role-state-buttons'; statesDiv.dataset.roleName = name;
                const statesToShow = [uiChatModule.ROLE_STATE_DEFAULT, uiChatModule.ROLE_STATE_ACTIVE, uiChatModule.ROLE_STATE_USER_CONTROL, uiChatModule.ROLE_STATE_UPDATE];
                statesToShow.forEach(s => {
                    const sBtn = document.createElement('div'); sBtn.className = 'std-button role-state-button';
                    sBtn.textContent = s;
                    sBtn.dataset.roleName = name;
                    sBtn.dataset.state = s;
                    statesDiv.appendChild(sBtn);
                });
                cont.appendChild(statesDiv);
                frag.appendChild(cont);
            });
        }
        elementsModule.roleButtonsListContainer.innerHTML = '';
        elementsModule.roleButtonsListContainer.appendChild(frag);
        const roleButtonContainers = elementsModule.roleButtonsListContainer.querySelectorAll('.role-button-container');
        roleButtonContainers.forEach(container => {
            const mainButton = container.querySelector('.std-button:not(.role-state-button)');
            const stateButtons = container.querySelectorAll('.role-state-button');
            const roleName = mainButton.dataset.roleName;
            const roleInfo = roleDataForButtons.find(r => r.name === roleName);
            const roleIsTemporary = roleInfo ? roleInfo.isTemporary : false;
            const isPermanent = !roleIsTemporary;
            const mainShortPress = () => uiChatModule.toggleRoleStateButtons(roleName);
            const mainLongPress = () => {
                if (!elementsModule.settingsPanel.classList.contains('active')) {
                    uiSettingsModule.toggleSettings();
                }
                uiSettingsModule.showRoleDetailPage(roleName);
                uiChatModule.hideRoleStateButtons();
                if (stateModule.config.isRoleListVisible) uiChatModule.toggleRoleList();
                 uiChatModule.hideRoleStateButtons();
            };
            if (mainButton) eventListenersModule._setupLongPressListener(mainButton, mainShortPress, mainLongPress, false);
            stateButtons.forEach(sBtn => {
                const state = sBtn.dataset.state;
                const isDisabled = sBtn.classList.contains('edit-disabled');
                const stateShortPress = isDisabled ? null : () => uiChatModule.selectRoleState(roleName, state);
                let stateLongPress = null;
                if (!isDisabled && state === uiChatModule.ROLE_STATE_USER_CONTROL) {
                    stateLongPress = () => {
                        uiChatModule.createAndEditMessageForRole(roleName);
                        uiChatModule.hideRoleStateButtons();
                    };
                } else if (!isDisabled && state === uiChatModule.ROLE_STATE_DEFAULT && roleIsTemporary) {
                     stateLongPress = () => uiChatModule.deleteTemporaryRole(roleName, true);
                } else if (!isDisabled && state === uiChatModule.ROLE_STATE_DEFAULT && isPermanent) {
                     stateLongPress = () => uiChatModule.handleRoleDefaultStateLongPress(roleName);
                } else if (!isDisabled && state === uiChatModule.ROLE_STATE_ACTIVE) {
                     stateLongPress = () => uiChatModule.handleActivateButtonLongPress(roleName);
                }
                if (sBtn) eventListenersModule._setupLongPressListener(sBtn, stateShortPress, stateLongPress, false);
            });
        });
        roleDataForButtons.forEach(({ name }) => {
            uiChatModule.updateRoleStateButtonVisual(name);
        });
    },
    toggleRoleStateButtons: (name) => {
        const div = document.querySelector(`.role-state-buttons[data-role-name="${name}"]`);
        if (div) {
            if (stateModule.activeRoleStateButtons === name) {
                div.classList.remove('active');
                stateModule.activeRoleStateButtons = null;
            } else {
                uiChatModule.hideRoleStateButtons();
                div.classList.add('active');
                stateModule.activeRoleStateButtons = name;
            }
        }
    },
    hideRoleStateButtons: () => {
        document.querySelectorAll('.role-state-buttons.active').forEach(el => el.classList.remove('active'));
        stateModule.activeRoleStateButtons = null;
        const triggerList = elementsModule.activeRoleTriggerList;
        if (triggerList) triggerList.style.display = 'none';
    },
    selectRoleState: async (name, state) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || !chatroomDetails.config.roleStates) return;
        const currentStates = chatroomDetails.config.roleStates;
        if (state === uiChatModule.ROLE_STATE_UPDATE) {
            const isPermanent = chatroomDetails.roles.some(r => r.name === name);
            if (!isPermanent) {
                const newRoleData = { name: name, setting: "", memory: "", drawingTemplate: "" };
                const createSuccess = await apiModule.createRole(chatroomDetails.config.name, newRoleData);
                if (createSuccess) {
                    await apiModule.fetchChatroomDetails(chatroomDetails.config.name);
                    uiChatModule.updateRoleButtonsList();
                    uiSettingsModule.updateChatroomRolePage();
                    await updateChatContextCache();
                    apiModule.triggerCharacterUpdateForRole(name);
                } else {
                    _logAndDisplayError(`Failed to convert temporary role ${name} to permanent before update.`, "selectRoleState");
                    alert(`创建永久角色文件失败，无法更新角色 ${name}`);
                }
            } else {
                await updateChatContextCache();
                apiModule.triggerCharacterUpdateForRole(name);
            }
        } else {
            currentStates[name] = state;
            const updatePayload = { roleStates: currentStates };
            if (!chatroomDetails.config.roleDetailedStates) chatroomDetails.config.roleDetailedStates = {};
            updatePayload.roleDetailedStates = chatroomDetails.config.roleDetailedStates;
            if (!chatroomDetails.config.roleVisibility) chatroomDetails.config.roleVisibility = {};
            updatePayload.roleVisibility = chatroomDetails.config.roleVisibility;
            const success = await apiModule.updateChatroomConfig(chatroomDetails.config.name, updatePayload);
            if (success) {
                uiChatModule.updateRoleStateButtonVisual(name);
                await updateChatContextCache();
            } else {
                 await apiModule.fetchChatroomDetails(chatroomDetails.config.name);
                 uiChatModule.updateRoleStateButtonVisual(name);
                 _logAndDisplayError(`Failed to save state change for role ${name}`, "selectRoleState");
                 alert(`保存角色 ${name} 状态失败`);
            }
        }
        uiChatModule.hideRoleStateButtons();
    },

    handleDefaultStateLongPress: async (roleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails || roleName === "管理员") return;
        const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
        if (!isPermanent) return;

        const newStates = { ...chatroomDetails.config.roleStates };
        delete newStates[roleName];
        const updatePayload = { roleStates: newStates };
        if (chatroomDetails.config.roleDetailedStates && roleName in chatroomDetails.config.roleDetailedStates) {
            const newDetailedStates = { ...chatroomDetails.config.roleDetailedStates };
            delete newDetailedStates[roleName];
            updatePayload.roleDetailedStates = newDetailedStates;
        }
        if (chatroomDetails.config.roleVisibility && roleName in chatroomDetails.config.roleVisibility) {
             const newVisibility = { ...chatroomDetails.config.roleVisibility };
             delete newVisibility[roleName];
             updatePayload.roleVisibility = newVisibility;
        }

        const success = await apiModule.updateChatroomConfig(chatroomDetails.config.name, updatePayload);
        if (success) {
            chatroomDetails.config.roleStates = newStates;
            if (updatePayload.roleDetailedStates) {
                chatroomDetails.config.roleDetailedStates = updatePayload.roleDetailedStates;
            }
            if (updatePayload.roleVisibility) {
                 chatroomDetails.config.roleVisibility = updatePayload.roleVisibility;
            }
            uiChatModule.updateRoleButtonsList();
            uiSettingsModule.updateChatroomRolePage();
            await updateChatContextCache();
        } else {
            _logAndDisplayError(`Failed to remove role ${roleName} from states`, "handleDefaultStateLongPress");
            alert(`移除角色 ${roleName} 失败`);
        }
        uiChatModule.hideRoleStateButtons();
    },
    updateRoleStateButtonVisual: (name) => {
        const div = document.querySelector(`.role-state-buttons[data-role-name="${name}"]`);
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (div && chatroomDetails && chatroomDetails.config.roleStates) {
            const currentState = chatroomDetails.config.roleStates[name] || uiChatModule.ROLE_STATE_DEFAULT;
            div.childNodes.forEach(btn => {
                if (btn.classList?.contains('role-state-button')) {
                    btn.classList.remove('role-state-active');
                    if (btn.dataset.state === currentState) {
                        btn.classList.add('role-state-active');
                    }
                }
            });
        }
    },
    createAndEditMessageForRole: (roleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) { _logAndDisplayError("请先选择一个激活的聊天室。", "createAndEditMessageForRole"); return; }
        const roleState = chatroomDetails.config.roleStates?.[roleName];
        if (roleState === undefined) {
             _logAndDisplayError(`角色 "${roleName}" 不在当前聊天室。`, "createAndEditMessageForRole"); return;
        }
        const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
        const roleType = isPermanent ? 'role' : 'temporary_role';
        const msgId = uiChatModule._generateMessageId();
        const timestamp = Date.now();
        const messageObject = {
            id: msgId,
            timestamp: timestamp,
            sourceType: 'user',
            roleName: roleName,
            roleType: roleType,
            targetRoleName: null,
            speechActionText: '',
            rawJson: null,
            parsedResult: null,
            displayMode: 'formatted',
            parserError: null
        };
        stateModule.currentChatHistoryData.push(messageObject);
        const msgCont = uiChatModule._appendMessageAndScroll(messageObject);
        if(msgCont) {
            uiChatModule.toggleMessageEditMode(msgCont);
        }
    },
    createAdminMessage: () => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) {
             _logAndDisplayError("请先选择一个激活的聊天室。", "createAdminMessage"); return;
        }
        const adminRoleName = '管理员';
        const msgId = uiChatModule._generateMessageId();
        const timestamp = Date.now();
        const messageObject = {
            id: msgId,
            timestamp: timestamp,
            sourceType: 'user',
            roleName: adminRoleName,
            roleType: 'temporary_role',
            targetRoleName: null,
            speechActionText: '',
            rawJson: null,
            parsedResult: null,
            displayMode: 'formatted',
            parserError: null
        };
        stateModule.currentChatHistoryData.push(messageObject);
        const msgCont = uiChatModule._appendMessageAndScroll(messageObject);
        if(msgCont) {
            uiChatModule.toggleMessageEditMode(msgCont);
        }
    },
    addTemporaryRole: async (roleName) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) {
             _logAndDisplayError("添加失败：没有激活的聊天室。", 'addTemporaryRole');
             return false;
        }
        if (!roleName || typeof roleName !== 'string' || roleName.trim() === '') {
            _logAndDisplayError("添加失败：名称不能为空。", 'addTemporaryRole');
            return false;
        }
        const trimmedName = roleName.trim();
        if (Object.keys(chatroomDetails.config.roleStates || {}).includes(trimmedName)) {
            _logAndDisplayError(`添加失败：名称 "${trimmedName}" 已存在于当前聊天室。`, 'addTemporaryRole');
            return false;
        }
        const newStates = { ...chatroomDetails.config.roleStates, [trimmedName]: uiChatModule.ROLE_STATE_ACTIVE };
        const updatePayload = { roleStates: newStates };
        if (!chatroomDetails.config.roleDetailedStates) chatroomDetails.config.roleDetailedStates = {};
        updatePayload.roleDetailedStates = { ...chatroomDetails.config.roleDetailedStates, [trimmedName]: "" };
        if (!chatroomDetails.config.roleVisibility) chatroomDetails.config.roleVisibility = {};
        updatePayload.roleVisibility = { ...chatroomDetails.config.roleVisibility };
        const success = await apiModule.updateChatroomConfig(chatroomDetails.config.name, updatePayload);
        if (success) {
             chatroomDetails.config.roleStates = newStates;
             chatroomDetails.config.roleDetailedStates = updatePayload.roleDetailedStates;
             chatroomDetails.config.roleVisibility = updatePayload.roleVisibility;
             return true;
        } else {
             _logAndDisplayError(`Failed to add temporary role ${trimmedName} via API`, 'addTemporaryRole');
             return false;
        }
    },
    deleteTemporaryRole: async (roleName, confirmDeletion = true) => {
        const chatroomDetails = stateModule.currentChatroomDetails;
        if (!chatroomDetails) {
            _logAndDisplayError("删除失败：没有激活的聊天室。", 'deleteTemporaryRole');
            return false;
        }
        if (roleName === "管理员") {
            _logAndDisplayError("不能删除管理员角色。", 'deleteTemporaryRole');
            return false;
        }
        const isPermanent = chatroomDetails.roles.some(r => r.name === roleName);
        if (isPermanent) {
            _logAndDisplayError(`删除失败：角色 "${roleName}" 不是临时角色。`, 'deleteTemporaryRole');
            return false;
        }
        if (!chatroomDetails.config.roleStates || !(roleName in chatroomDetails.config.roleStates)) {
            _logAndDisplayError(`删除失败：临时角色 "${roleName}" 不存在于状态中。`, 'deleteTemporaryRole');
            return false;
        }
        if (confirmDeletion) {
        }

        const newStates = { ...chatroomDetails.config.roleStates };
        delete newStates[roleName];
        const updatePayload = { roleStates: newStates };
        if (chatroomDetails.config.roleDetailedStates && roleName in chatroomDetails.config.roleDetailedStates) {
            const newDetailedStates = { ...chatroomDetails.config.roleDetailedStates };
            delete newDetailedStates[roleName];
            updatePayload.roleDetailedStates = newDetailedStates;
        }
        if (chatroomDetails.config.roleVisibility && roleName in chatroomDetails.config.roleVisibility) {
             const newVisibility = { ...chatroomDetails.config.roleVisibility };
             delete newVisibility[roleName];
             updatePayload.roleVisibility = newVisibility;
        }
        const success = await apiModule.updateChatroomConfig(chatroomDetails.config.name, updatePayload);
        if (success) {
            chatroomDetails.config.roleStates = newStates;
            if (updatePayload.roleDetailedStates) {
                chatroomDetails.config.roleDetailedStates = updatePayload.roleDetailedStates;
            }
            if (updatePayload.roleVisibility) {
                 chatroomDetails.config.roleVisibility = updatePayload.roleVisibility;
            }
            uiChatModule.updateRoleButtonsList();
            uiSettingsModule.updateChatroomRolePage();
            await updateChatContextCache();
            return true;
        } else {
            _logAndDisplayError(`Failed to delete temporary role ${roleName} via API`, 'deleteTemporaryRole');
            return false;
        }
    },
    handleNovelAiResponse: (responseData, originalDrawingMasterData, rawJsonText, targetMessageId = null) => {
        if (responseData.error) {
             _logAndDisplayError(`NovelAI Error: ${responseData.error}`, 'handleNovelAiResponse');
             return;
        }
        if (!responseData.imageDataUrl) {
             _logAndDisplayError("[NovelAI returned unknown response or no image data]", 'handleNovelAiResponse');
             return;
        }
        const imageUrl = responseData.imageDataUrl;
        if (targetMessageId) {
             const msgCont = document.querySelector(`.message-container[data-message-id="${targetMessageId}"]`);
             if (msgCont) {
                 const imgElement = msgCont.querySelector('.ai-response img');
                 if (imgElement) {
                     stateModule.tempImageUrls[targetMessageId] = imageUrl;
                     imgElement.src = imageUrl;
                 } else {
                      _logAndDisplayError(`Image element not found in message ${targetMessageId} for replacement.`, 'handleNovelAiResponse');
                 }
                 const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === targetMessageId);
                 if (messageIndex > -1) {
                     stateModule.currentChatHistoryData[messageIndex].timestamp = Date.now();
                     stateModule.currentChatHistoryData[messageIndex].naiPayloadSource = originalDrawingMasterData || null;
                     stateModule.currentChatHistoryData[messageIndex].rawJson = rawJsonText || JSON.stringify(originalDrawingMasterData || {});
                 }
                 uiChatModule.triggerDebouncedHistorySave();
             } else {
                  _logAndDisplayError(`Could not find target message ${targetMessageId} for redraw.`, 'handleNovelAiResponse');
             }
        } else {
             const msgId = uiChatModule._generateMessageId();
             const timestamp = Date.now();
             const roleName = 'drawingMaster';
             const roleType = 'tool';
             const messageObject = {
                id: msgId,
                timestamp: timestamp,
                sourceType: 'ai',
                roleName: roleName,
                roleType: roleType,
                targetRoleName: null,
                speechActionText: "[图片绘制]",
                rawJson: rawJsonText || JSON.stringify(originalDrawingMasterData || {}),
                parsedResult: originalDrawingMasterData || null,
                displayMode: 'formatted',
                parserError: null,
                naiPayloadSource: originalDrawingMasterData || null
             };
             stateModule.tempImageUrls[msgId] = imageUrl;
             stateModule.displayedImageCount++;
             stateModule.displayedImageOrder.push(msgId);
             const MAX_IMAGES = 20;
             if (stateModule.displayedImageCount > MAX_IMAGES) {
                const oldestMsgId = stateModule.displayedImageOrder.shift();
                delete stateModule.tempImageUrls[oldestMsgId];
                stateModule.displayedImageCount--;
             }
            stateModule.currentChatHistoryData.push(messageObject);
            const messageContainer = uiChatModule._appendMessageAndScroll(messageObject);
            if (messageContainer) {
                 const actionsContainer = messageContainer.querySelector('.message-actions-container');
                 if (actionsContainer) {
                     let bgButton = actionsContainer.querySelector('.set-background-button');
                     if (!bgButton) {
                         bgButton = document.createElement('div');
                         bgButton.className = 'std-button message-action-button set-background-button';
                         bgButton.textContent = '🖼️';
                         bgButton._interactionListenersAttached = true;
                         eventListenersModule._setupLongPressListener(
                             bgButton,
                             () => uiChatModule.handleSetBackgroundClick({ target: bgButton }),
                             () => uiChatModule.handleDownloadImageLongPress({ target: bgButton }),
                             false
                         );
                         const redrawBtn = actionsContainer.querySelector('.redraw-button');
                          if(redrawBtn) {
                               actionsContainer.insertBefore(bgButton, redrawBtn);
                          } else {
                               const deleteBtn = actionsContainer.querySelector('.delete-button');
                               if(deleteBtn) {
                                   actionsContainer.insertBefore(bgButton, deleteBtn);
                               } else {
                                    actionsContainer.appendChild(bgButton);
                               }
                          }
                     }
                 }
            }
            uiChatModule.triggerDebouncedHistorySave();
        }
    },
    saveCharacterUpdate: async (messageContainer) => {
        if (!messageContainer) return;
        const messageId = messageContainer.dataset.messageId;
        const chatroomDetails = stateModule.currentChatroomDetails;
        const messageIndex = stateModule.currentChatHistoryData.findIndex(msg => msg.id === messageId);
        if (messageIndex === -1 || stateModule.currentChatHistoryData[messageIndex].roleName !== 'characterUpdateMaster') {
             _logAndDisplayError(`Cannot save character update: Message ${messageId} not found or not a character update message.`, 'saveCharacterUpdate');
            return;
        }
        const messageObject = stateModule.currentChatHistoryData[messageIndex];
        const parsedResult = messageObject.parsedResult;
        if (!parsedResult || messageObject.parserError || !parsedResult.formattedUpdate) {
             _logAndDisplayError(`Cannot save character update: Parsed result for message ${messageId} is invalid, contains errors, or lacks formattedUpdate.`, 'saveCharacterUpdate');
             return;
        }
        const targetRoleName = messageObject.targetRoleName;
        if (!chatroomDetails || !targetRoleName) {
             _logAndDisplayError(`Cannot save character update: Active chatroom details or target role name is missing.`, 'saveCharacterUpdate');
            return;
        }
        const roleIndex = chatroomDetails.roles.findIndex(r => r.name === targetRoleName);
        if (roleIndex === -1) {
            _logAndDisplayError(`Cannot save character update: Target role ${targetRoleName} not found in chatroom roles (might be temporary).`, 'saveCharacterUpdate');
             alert(`无法保存：目标角色 ${targetRoleName} 是临时角色或已被删除。`);
            return;
        }
        const roleToUpdate = chatroomDetails.roles[roleIndex];
        const formattedUpdateString = parsedResult.formattedUpdate;
        const parts = formattedUpdateString.split(uiChatModule.CHARACTER_SETTINGS_SEPARATOR);
        if (parts.length === 2) {
             let newMemoryPart = parts[0].replace(/^---\s*更新后记忆.*?---\s*\n?/, '').trim();
             let newSettingString = parts[1].replace(/^---\s*更新后设定.*?---\s*\n?/, '').trim();
             const currentMemory = roleToUpdate.memory || '';
             const combinedMemory = currentMemory ? `${currentMemory}\n${newMemoryPart}` : newMemoryPart;

             const updatedRoleData = {
                 ...roleToUpdate,
                 memory: combinedMemory,
                 setting: newSettingString
             };
             const success = await apiModule.updateRole(chatroomDetails.config.name, targetRoleName, updatedRoleData);
             if(success) {
                 Object.assign(roleToUpdate, updatedRoleData);
                 uiChatModule.hideAllMessageActions();
                 const roleDetailOpen = document.getElementById('role-detail-page')?.classList.contains('active');
                 if (roleDetailOpen && stateModule.currentRole === targetRoleName) {
                    uiSettingsModule.loadRoleSettings(targetRoleName, roleToUpdate, false);
                 }
             } else {
                  _logAndDisplayError(`Failed to save character update for ${targetRoleName} via API`, 'saveCharacterUpdate');
                  alert(`保存角色 ${targetRoleName} 更新失败。`);
             }
        } else {
             _logAndDisplayError(`Output format error for CharacterUpdateMaster message ${messageId}, cannot save. Formatted string: ${formattedUpdateString}`, 'saveCharacterUpdate');
        }
    },
    showLoadingSpinner: () => {
        if (elementsModule.loadingSpinner) {
            elementsModule.loadingSpinner.style.display = 'block';
            elementsModule.loadingSpinner.classList.add('spinning');
        }
    },
    hideLoadingSpinner: () => {
        if (elementsModule.loadingSpinner) {
            elementsModule.loadingSpinner.style.display = 'none';
            elementsModule.loadingSpinner.classList.remove('spinning');
        }
    },
    showRetryIndicator: () => {
        const spinner = elementsModule.loadingSpinner;
        if (spinner) {
            spinner.classList.add('retry-indicator');
            setTimeout(() => {
                spinner.classList.remove('retry-indicator');
            }, 200);
        }
    },
    _createPendingActionButton: (roleName) => {
        const container = elementsModule.pendingActionButtonContainer;
        if (!container) return;
        uiChatModule._removePendingActionButton();
        const button = document.createElement('div');
        button.className = 'std-button';
        button.textContent = '💬';
        button.dataset.roleName = roleName;
        button.addEventListener('click', () => {
            uiChatModule.createAndEditMessageForRole(roleName);
            uiChatModule._removePendingActionButton();
        });
        container.appendChild(button);
    },
    _removePendingActionButton: () => {
        const container = elementsModule.pendingActionButtonContainer;
        if (container) {
            container.innerHTML = '';
        }
    },
    handleActivateButtonLongPress: (roleName) => {
        if (stateModule.config.isRunPaused) {
            uiChatModule.toggleRunPause();
        }
        apiModule.triggerRoleResponse(roleName);
        uiChatModule.hideRoleStateButtons();
    },
};
```
--- END OF FILE ui_chat.js ---


--- START OF FILE main.js ---
```javascript
const mainModule = {
    debounceTimer: null,
    debounceDelay: 1500,

    debounce: (func, delay) => {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    },

    triggerDebouncedSave: () => {
        clearTimeout(mainModule.debounceTimer);
        mainModule.debounceTimer = setTimeout(() => {
            configModule.autoSaveConfig();
        }, mainModule.debounceDelay);
    },

    handleModelSelectClick: (event) => {

    }
};


const initializationModule = {

    _initializeApiSettingsUI: () => {
        uiSettingsModule.loadApiKeysSetting();
        uiSettingsModule.updateApiKeyFailureCountsDisplay();
        const googleKeys = apiKeyManager.getApiKeys();
        const allSelects = document.querySelectorAll('.settings-select[id*="-model-"]');
        const defaultPlaceholder = googleKeys.length === 0 ? '请输入 API 密钥' : '请点击 拉取模型列表';
        allSelects.forEach(sel => {
            if (sel.id !== 'novelai-model-settings') {
                const placeholderOption = sel.querySelector('option[disabled][selected]');
                if (!placeholderOption) {
                    sel.innerHTML = `<option value="" disabled selected>${defaultPlaceholder}</option>`;
                } else {
                    placeholderOption.textContent = defaultPlaceholder;
                }
            }
        });
    },

    _initializeNovelAiSettingsUI: () => {
        uiSettingsModule.loadNovelAiSettings();
        uiSettingsModule.updateLastNaiPromptDisplay(stateModule.lastNaiPrompt);
    },

    _initializeGeneralSettingsUI: () => {
        ['temperature', 'topP', 'topK', 'maxOutputTokens',
         'responseMimeType',
         'originalNovelLength',
        ].forEach(key => uiSettingsModule.loadSettingValue(key));

        uiSettingsModule.loadChatroomModelSetting();
        uiSettingsModule.loadSettingValue('responseSchemaJson');
        uiSettingsModule.loadSettingValue('responseSchemaParserJs');
        uiSettingsModule.loadSettingValue('sharedDatabaseInstruction');
        uiSettingsModule.loadChatroomMainPromptSetting();
    },

     _initializePromptPresetSettingsUI: () => {
        uiSettingsModule.loadPromptPresetSettings();
        uiSettingsModule.renderPromptPresetsList();
     },

    _initializeToolSettingsUI: () => {
        ['drawingMaster', 'gameHost', 'writingMaster', 'characterUpdateMaster', 'privateAssistant'].forEach(toolName => {
            uiSettingsModule.loadGodSettings(toolName);
        });
    },

    _initializeChatroomListUI: () => {
        uiSettingsModule.updateChatroomList();
    },

    _initializeTopToolbarUI: () => {
        elementsModule.runPauseButton.textContent = stateModule.config.isRunPaused ? '▶' : '◼';
        elementsModule.roleButtonsListContainer.style.display = stateModule.config.isRoleListVisible ? 'flex' : 'none';

    },

    _initializeErrorLogUI: () => {

        uiSettingsModule.displayErrorLog([]);
    },

    _initializeNovelInterfaceUI: () => {
        elementsModule.novelInterface.classList.remove('active');
        stateModule.isNovelInterfaceVisible = false;
        uiSettingsModule.novelUI_hideAllNovelPages();
        stateModule.novelPageStack = [];
        stateModule.activeNovelPage = null;
        stateModule.currentNovelId = null;

        stateModule.currentTocIndexByNovel = {};


        let shouldLoadNovel = false;
        const lastViewedNovelId = stateModule.config.lastViewedNovelId;
        const currentChatroomDetails = stateModule.currentChatroomDetails;

        if (lastViewedNovelId && currentChatroomDetails) {
            const novelExists = currentChatroomDetails.novels?.some(n => n.id === lastViewedNovelId);
            if (novelExists) {
                stateModule.currentNovelId = lastViewedNovelId;
                shouldLoadNovel = true;
            } else {
                 stateModule.config.lastViewedNovelId = null;
                 mainModule.triggerDebouncedSave();
            }
        }

        if (shouldLoadNovel) {

        } else if (elementsModule.novelContentDisplay) {
             elementsModule.novelContentDisplay.innerHTML = '<p style="text-align: center; padding-top: 20px;">请在书目(📚)中选择小说</p>';
             elementsModule.novelContentDisplay.removeAttribute('data-novel-id');
        }
    },

    _initializeBackground: () => {
        const backgroundFilename = stateModule.currentChatroomDetails?.config?.backgroundImageFilename;
        const activeRoomName = stateModule.config.activeChatRoomName;

        if (backgroundFilename && activeRoomName && elementsModule.chatContainer) {
             const bgUrl = `/chatrooms/${encodeURIComponent(activeRoomName)}/${encodeURIComponent(backgroundFilename)}?t=${Date.now()}`;
             elementsModule.chatContainer.style.backgroundImage = `url('${bgUrl}')`;
        } else if (elementsModule.chatContainer) {
            elementsModule.chatContainer.style.backgroundImage = '';
        }
    },

    _initializeChatroomSpecificUI: () => {

        if (stateModule.currentChatroomDetails) {

             if (!stateModule.currentChatroomDetails.config.overrideSettings) {
                 stateModule.currentChatroomDetails.config.overrideSettings = JSON.parse(JSON.stringify(defaultChatroomOverrideSettings));
                 _logAndDisplayError(`Chatroom ${stateModule.config.activeChatRoomName} config missing overrideSettings, added default.`, '_initializeChatroomSpecificUI');
             }
             if (!stateModule.currentChatroomDetails.config.roleVisibility) {
                  stateModule.currentChatroomDetails.config.roleVisibility = {};

                  const permanentRoles = new Set(stateModule.currentChatroomDetails.roles.map(r => r.name));
                  for (const roleName in stateModule.currentChatroomDetails.config.roleStates) {
                     if (permanentRoles.has(roleName)) {
                         stateModule.currentChatroomDetails.config.roleVisibility[roleName] = true;
                     }
                  }
                   _logAndDisplayError(`Chatroom ${stateModule.config.activeChatRoomName} config missing roleVisibility, initialized.`, '_initializeChatroomSpecificUI');
             }

            uiChatModule.loadChatHistory(stateModule.currentChatroomDetails.config.name);
            uiChatModule.updateRoleButtonsList();
            initializationModule._initializeBackground();
            initializationModule._initializeNovelInterfaceUI();
             if (document.getElementById('role-list-page').classList.contains('active')) {
                 uiSettingsModule.updateChatroomRolePage();
             }
             if (document.getElementById('story-mode-page').classList.contains('active')) {
                 uiSettingsModule.updateChatroomNovelPage();
             }
        } else {

            uiChatModule.clearChatArea();
            uiChatModule.updateRoleButtonsList();
            initializationModule._initializeBackground();
            initializationModule._initializeNovelInterfaceUI();
        }
        updateChatContextCache();
        uiSettingsModule.updateWorldInfoDisplay();
        uiSettingsModule.loadRoleplayRulesSetting();
        uiSettingsModule.loadPublicInfoSetting();
        uiSettingsModule.loadChatroomUserSetting();
    },

    initializeConfig: async () => {

        await configModule.loadConfig();


        initializationModule._initializeApiSettingsUI();
        initializationModule._initializeNovelAiSettingsUI();
        initializationModule._initializeGeneralSettingsUI();
        initializationModule._initializePromptPresetSettingsUI();
        initializationModule._initializeToolSettingsUI();
        initializationModule._initializeTopToolbarUI();
        initializationModule._initializeErrorLogUI();
        initializationModule._initializeChatroomListUI();


        initializationModule._initializeChatroomSpecificUI();


        uiSettingsModule.hideAllSettingPages();
        elementsModule.settingsPanel.classList.remove('active');
        stateModule.pageStack = [];
    },
};

const eventListenersModule = {
    _longPressDelay: 200,
    _cooldownDuration: 200,

    _isFullscreen: () => {
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    },

    _requestFullscreen: () => {
        const element = document.documentElement;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    },

    _exitFullscreen: () => {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    },

    _toggleFullscreen: () => {
        if (eventListenersModule._isFullscreen()) {
            eventListenersModule._exitFullscreen();
        } else {
            eventListenersModule._requestFullscreen();
        }
    },

    _activateCooldown: () => {
        clearTimeout(stateModule.cooldownTimer);
        stateModule.isCooldownActive = true;
        stateModule.cooldownTimer = setTimeout(() => {
            stateModule.isCooldownActive = false;
            stateModule.cooldownTimer = null;
        }, eventListenersModule._cooldownDuration);
    },

    _setupLongPressListener: (element, shortPressAction, longPressAction, allowScroll = false) => {
        let startX, startY, startTime, isMoved = false;

        const handlePointerDown = (event) => {
            if (event.button !== 0 && event.pointerType === 'mouse') return;
            event.preventDefault();

            startX = event.clientX;
            startY = event.clientY;
            startTime = Date.now();
            isMoved = false;
            element.dataset.interactionActive = 'true';

            element.addEventListener('pointermove', handlePointerMove, { passive: true });
            element.addEventListener('pointerup', handlePointerUp);
            element.addEventListener('pointercancel', handlePointerEnd);
            element.addEventListener('pointerleave', handlePointerLeave);
        };

        const handlePointerMove = (event) => {
            if (element.dataset.interactionActive !== 'true') return;
            const deltaX = Math.abs(event.clientX - startX);
            const deltaY = Math.abs(event.clientY - startY);
            const MOVE_THRESHOLD = 10;
            if (deltaX > MOVE_THRESHOLD || deltaY > MOVE_THRESHOLD) {
                isMoved = true;
                handlePointerEnd();
            }
        };

        const handlePointerUp = (event) => {
            if (element.dataset.interactionActive !== 'true') return;

            if (stateModule.isCooldownActive) {
                handlePointerEnd();
                event.preventDefault();
                return;
            }

            const duration = Date.now() - startTime;

            if (!isMoved) {
                if (duration >= eventListenersModule._longPressDelay && longPressAction) {
                    longPressAction();
                } else if (shortPressAction) {
                    shortPressAction();
                }
            }

            handlePointerEnd();
            event.preventDefault();
        };

         const handlePointerLeave = (event) => {
             const rect = element.getBoundingClientRect();
             const isOutside = event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom;
             if (element.dataset.interactionActive === 'true' && isOutside) {
                 handlePointerEnd();
             }
         };

        const handlePointerEnd = () => {
            if (element.dataset.interactionActive === 'true') {
                eventListenersModule._activateCooldown();
            }
            delete element.dataset.interactionActive;
            element.removeEventListener('pointermove', handlePointerMove);
            element.removeEventListener('pointerup', handlePointerUp);
            element.removeEventListener('pointercancel', handlePointerEnd);
            element.removeEventListener('pointerleave', handlePointerLeave);
            isMoved = false;
            startTime = 0;
        };

        element.removeEventListener('pointerdown', handlePointerDown);
        element.addEventListener('pointerdown', handlePointerDown);
    },


    setupEventListeners: () => {

        eventListenersModule._setupLongPressListener(
            elementsModule.settingsIcon,
            () => uiSettingsModule.toggleSettings(),
            () => eventListenersModule._toggleFullscreen(),
            false
        );

        eventListenersModule._setupLongPressListener(
             elementsModule.roleButton,
             () => uiChatModule.toggleRoleList(),
             () => {
                 if (!elementsModule.settingsPanel.classList.contains('active')) {
                      uiSettingsModule.toggleSettings();
                 }
                 stateModule.currentChatRoom = stateModule.config.activeChatRoomName;
                 uiSettingsModule.showSection('role-list-page');
                 if (stateModule.config.isRoleListVisible) uiChatModule.toggleRoleList();
             },
             false
        );


        elementsModule.settingsMenuItems.forEach(item => item.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.showSection(item.dataset.target); }));

        elementsModule.chatRoomSettingsMenuItems.forEach(item => item.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.showSection(item.dataset.target); }));
        elementsModule.chatroomDetailSettingsMenuItems.forEach(item => item.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.showSection(item.dataset.target); }));
        elementsModule.closeButtons.forEach(button => button.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.closeCurrentSection(button.closest('.setting-page-template').id); }));



        elementsModule.copyErrorLogButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.copyErrorLog(); });
        elementsModule.clearAllConfigButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.clearAllConfiguration(); });
        elementsModule.exportConfigButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) window.location.href = '/export-full-config-zip'; });
        elementsModule.importConfigButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) elementsModule.importConfigFile.click(); });
        elementsModule.importConfigFile.addEventListener('change', uiSettingsModule.handleImportConfig);


        elementsModule.apiKeyTextareaSettings.addEventListener('change', uiSettingsModule.saveApiKeysSetting);
        if(elementsModule.fetchModelsButton) {
             elementsModule.fetchModelsButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) apiModule.fetchModels(); });
        }


        ['temperature', 'topP', 'topK', 'maxOutputTokens', 'responseMimeType'
        ].forEach(key => {
            const el = elementsModule[`${key}Settings`];
            if (el) el.addEventListener('change', () => {
                stateModule.config[key] = el.value;
                mainModule.triggerDebouncedSave();
            });
        });
         if (elementsModule.originalNovelLengthSettings) {
             elementsModule.originalNovelLengthSettings.addEventListener('change', uiSettingsModule.saveOriginalNovelLengthSetting);
         }
         if (elementsModule.systemInstructionPresetSettings) {
            elementsModule.systemInstructionPresetSettings.addEventListener('change', () => uiSettingsModule.savePromptPresetSetting('systemInstruction'));
            elementsModule.systemInstructionPresetSettings.addEventListener('input', () => uiSettingsModule.savePromptPresetSetting('systemInstruction'));
         }

         if (elementsModule.addPromptUserTurnButton) {
             elementsModule.addPromptUserTurnButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.addPromptPresetTurn('user'); });
         }
         if (elementsModule.addPromptModelTurnButton) {
             elementsModule.addPromptModelTurnButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.addPromptPresetTurn('model'); });
         }
         if (elementsModule.exportPromptPresetsButton) {
             elementsModule.exportPromptPresetsButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) apiModule.exportPromptPresets(); });
         }
         if (elementsModule.importPromptPresetsButton) {
             elementsModule.importPromptPresetsButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) elementsModule.importPromptPresetsFile.click(); });
         }
         if (elementsModule.importPromptPresetsFile) {
             elementsModule.importPromptPresetsFile.addEventListener('change', uiSettingsModule.handleImportPromptPresets);
         }


        const novelaiKeys = [
            "novelaiApiKey", "novelaiModel", "novelaiArtistChain",
            "novelaiDefaultPositivePrompt", "novelaiDefaultNegativePrompt",
            "novelaiWidth", "novelaiHeight", "novelaiSteps", "novelaiScale",
            "novelaiCfgRescale", "novelaiSampler", "novelaiNoiseSchedule", "novelaiSeed"
        ];
        novelaiKeys.forEach(key => {
            const el = elementsModule[`${key}Settings`];
            if (el) {
                const changeHandler = () => { uiSettingsModule.saveNovelAiSetting(key); };
                el.addEventListener('change', changeHandler);

                if (key !== 'novelaiApiKey' && (el.type === 'number' || el.tagName === 'TEXTAREA' || el.type === 'text')) {
                    el.addEventListener('input', changeHandler);
                }
            }
        });


        elementsModule.toolListMenuItems.forEach(item => item.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.showSection(item.dataset.target); }));
        ['drawingMaster', 'gameHost', 'writingMaster', 'characterUpdateMaster', 'privateAssistant'].forEach(godName => {
            const settings = ['responseSchemaJson', 'responseSchemaParserJs', 'toolDatabaseInstruction', 'enabled', 'model', 'mainPrompt'];
            if (godName === 'drawingMaster') {
                 settings.push('novelContent');
            }
            settings.forEach(settingType => {
                 let elementIdSuffix = 'Settings';
                 if (settingType === 'toolDatabaseInstruction') {
                      elementIdSuffix = 'ToolDatabaseInstructionSettings';
                 } else if (settingType !== 'model'){
                      elementIdSuffix = `${settingType.charAt(0).toUpperCase() + settingType.slice(1)}Settings`;
                 } else {
                      elementIdSuffix = 'ModelSettings';
                 }
                const elId = `${godName}${elementIdSuffix}`;
                const el = elementsModule[elId];
                if (el) {
                    if (el.type === 'checkbox' || el.tagName === 'SELECT') {
                         el.addEventListener('change', () => uiSettingsModule.saveGodSettings(godName));
                    } else {
                         el.addEventListener('input', () => uiSettingsModule.saveGodSettings(godName));
                         el.addEventListener('change', () => uiSettingsModule.saveGodSettings(godName));
                    }
                    if(settingType === 'mainPrompt') {
                         el.addEventListener('input', () => uiSettingsModule.saveToolMainPromptSetting(godName));
                         el.addEventListener('change', () => uiSettingsModule.saveToolMainPromptSetting(godName));
                    }
                }
            });
        });


        elementsModule.roleInstructionTextarea.addEventListener('change', uiSettingsModule.saveRoleSettings);
        elementsModule.roleMemoryTextarea.addEventListener('change', uiSettingsModule.saveRoleSettings);
        elementsModule.roleInstructionTextarea.addEventListener('input', uiSettingsModule.saveRoleSettings);
        elementsModule.roleMemoryTextarea.addEventListener('input', uiSettingsModule.saveRoleSettings);
        elementsModule.roleDrawingTemplateSettings.addEventListener('change', uiSettingsModule.saveRoleSettings);
        elementsModule.roleDrawingTemplateSettings.addEventListener('input', uiSettingsModule.saveRoleSettings);


        elementsModule.roleListContainer.addEventListener('click', (event) => {
             if (stateModule.isCooldownActive) return;
             const targetButton = event.target.closest('.item-actions > .std-button');
             if (!targetButton || targetButton.classList.contains('edit-disabled')) return;

             const roleItem = targetButton.closest('.role-item');
             if (!roleItem) return;
             const roleName = roleItem.dataset.roleName;

             if (targetButton.classList.contains('item-rename')) {
                 event.stopPropagation();
                 uiSettingsModule.renameChatroomRole(roleName);
             } else if (targetButton.classList.contains('item-delete')) {
                 event.stopPropagation();
                 uiSettingsModule.deleteChatroomRole(roleName);
             }
         });
        elementsModule.roleListContainer.addEventListener('change', (event) => {
             if (stateModule.isCooldownActive) return;
             const targetCheckbox = event.target.closest('.role-visibility-checkbox');
             if (targetCheckbox) {
                 const roleName = targetCheckbox.dataset.roleName;
                 const isVisible = targetCheckbox.checked;
                 uiSettingsModule.handleRoleVisibilityChange(roleName, isVisible);
             }
         });

        if (elementsModule.exportRoleButton) elementsModule.exportRoleButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.exportRole(); });
        if (elementsModule.importRoleButton) elementsModule.importRoleButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.importRole(); });
        if (elementsModule.importRoleFile) elementsModule.importRoleFile.addEventListener('change', uiSettingsModule.handleImportRoleFile);
        if (elementsModule.addChatroomRoleButton) elementsModule.addChatroomRoleButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.addChatroomRole(); });


        elementsModule.addChatroomButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.addChatroom(); });
        elementsModule.clearChatroomHistoryButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.clearCurrentChatroomHistory(); });
        elementsModule.chatroomListContainer.addEventListener('click', (event) => {
             if (stateModule.isCooldownActive) return;

             const targetRadio = event.target.closest('input[type="radio"]');
             const targetLabel = event.target.closest('label');
             const roomItem = event.target.closest('.chatroom-item');

             if ((targetRadio || targetLabel) && roomItem) {

             }
         });
        if (elementsModule.renameChatroomButton) elementsModule.renameChatroomButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.handleRenameChatroom(); });
        if (elementsModule.deleteChatroomButton) elementsModule.deleteChatroomButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.handleDeleteChatroom(); });
        if (elementsModule.exportChatroomButton) elementsModule.exportChatroomButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.exportChatroom(); });
        if (elementsModule.importChatroomButton) elementsModule.importChatroomButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.importChatroom(); });
        if (elementsModule.importChatroomFile) elementsModule.importChatroomFile.addEventListener('change', uiSettingsModule.handleImportChatroomFile);


        ['responseSchemaJson', 'responseSchemaParserJs', 'sharedDatabaseInstruction'].forEach(key => {
             const el = elementsModule[`${key}Settings`];
             if (el) {
                 el.addEventListener('change', () => uiSettingsModule.saveChatroomCommonSetting(key));
                 el.addEventListener('input', () => uiSettingsModule.saveChatroomCommonSetting(key));
             }
        });
        if (elementsModule.chatroomMainPromptSettings) {
             elementsModule.chatroomMainPromptSettings.addEventListener('change', uiSettingsModule.saveChatroomMainPromptSetting);
             elementsModule.chatroomMainPromptSettings.addEventListener('input', () => uiSettingsModule.saveChatroomMainPromptSetting);
        }


        elementsModule.novelListContainer.addEventListener('click', (event) => {
            if (stateModule.isCooldownActive) return;
            const novelItem = event.target.closest('.novel-item');
            if (!novelItem) return;
            const novelId = novelItem.dataset.novelId;
            const novelName = novelItem.querySelector('.novel-name')?.textContent;

            const targetButton = event.target.closest('.item-actions > .std-button');
            if (!targetButton) return;

            if (targetButton.classList.contains('item-rename')) {
                 event.stopPropagation();
                 uiSettingsModule.renameChatroomNovel(novelId, novelName);
            } else if (targetButton.classList.contains('item-delete')) {
                 event.stopPropagation();
                 uiSettingsModule.deleteChatroomNovel(novelId, novelName);
            }
        });


        eventListenersModule._setupLongPressListener(
            elementsModule.runPauseButton,
            () => uiChatModule.toggleRunPause(),
            () => {
                if (stateModule.config.toolSettings.privateAssistant?.enabled) {
                    apiModule.triggerRoleResponse('privateAssistant');
                } else {
                    _logAndDisplayError("Cannot trigger Private Assistant: Tool is not enabled in settings.", "runPauseButtonLongPress");
                }
            },
            false
        );

        if (elementsModule.ruleButton) {
            elementsModule.ruleButton.addEventListener('click', () => {
                if (stateModule.isCooldownActive) return;
                if (stateModule.config.activeChatRoomName) {
                    if (!elementsModule.settingsPanel.classList.contains('active')) {
                        uiSettingsModule.toggleSettings();
                    }
                    stateModule.currentChatRoom = stateModule.config.activeChatRoomName;
                    uiSettingsModule.showSection('current-chatroom-settings-page');
                } else {

                }
            });
        }
        if (elementsModule.roleplayRulesTextarea) {
            elementsModule.roleplayRulesTextarea.addEventListener('change', uiSettingsModule.saveRoleplayRulesSetting);
            elementsModule.roleplayRulesTextarea.addEventListener('input', uiSettingsModule.saveRoleplayRulesSetting);
        }
        if (elementsModule.publicInfoTextarea) {
            elementsModule.publicInfoTextarea.addEventListener('change', uiSettingsModule.savePublicInfoSetting);
            elementsModule.publicInfoTextarea.addEventListener('input', uiSettingsModule.savePublicInfoSetting);
        }
        if (elementsModule.chatroomUserSetting) {
             elementsModule.chatroomUserSetting.addEventListener('change', uiSettingsModule.saveChatroomUserSetting);
             elementsModule.chatroomUserSetting.addEventListener('input', uiSettingsModule.saveChatroomUserSetting);
        }


        eventListenersModule._setupLongPressListener(
            elementsModule.addAdminButton,
            () => uiChatModule.createAdminMessage(),
            async () => {
                const name = prompt("请输入新临时角色名称:");
                if (name && name.trim() && stateModule.currentChatroomDetails) {
                    const added = await uiChatModule.addTemporaryRole(name.trim());
                    if (added) {
                        uiChatModule.updateRoleButtonsList();
                        updateChatContextCache();
                        if (document.getElementById('role-list-page')?.classList.contains('active')) {
                           uiSettingsModule.updateChatroomRolePage();
                        }

                    } else {
                         alert(`Failed to add temporary role '${name.trim()}'.`);
                    }
                } else if (!stateModule.currentChatroomDetails) {
                    alert("Please select a chatroom first.");
                }
            },
            false
        );

        elementsModule.chatArea.addEventListener('pointerdown', (event) => {
             if (stateModule.isCooldownActive) return;
             const nameBtn = event.target.closest('.role-name-button-above-bubble');
             if (nameBtn && !nameBtn._interactionListenersAttached) {
                const msgContainer = nameBtn.closest('.message-container');
                eventListenersModule._setupLongPressListener(
                    nameBtn,
                    () => uiChatModule.toggleMessageActions(msgContainer),
                    () => { uiChatModule.toggleMessageEditMode(msgContainer); uiChatModule.hideAllMessageActions(); },
                    false
                );
                nameBtn._interactionListenersAttached = true;
             }

             const bgBtn = event.target.closest('.set-background-button');
              if (bgBtn && !bgBtn._interactionListenersAttached) {
                  eventListenersModule._setupLongPressListener(
                      bgBtn,
                      () => uiChatModule.handleSetBackgroundClick(event),
                      () => uiChatModule.handleDownloadImageLongPress(event),
                      false
                  );
                  bgBtn._interactionListenersAttached = true;
              }

             const deleteBtn = event.target.closest('.delete-button');
              if (deleteBtn && !deleteBtn._interactionListenersAttached) {
                  const msgContainer = deleteBtn.closest('.message-container');
                  eventListenersModule._setupLongPressListener(
                      deleteBtn,
                      () => uiChatModule.deleteMessage(msgContainer),
                      () => { if (confirm("确定要删除此消息及其之后的所有消息吗？")) { uiChatModule.deleteMessageAndBelow(msgContainer); } uiChatModule.hideAllMessageActions(); },
                      false
                  );
                  deleteBtn._interactionListenersAttached = true;
              }
        }, true);


        elementsModule.chatArea.addEventListener('click', async (event) => {
            if (stateModule.isCooldownActive) return;
            const msgContainer = event.target.closest('.message-container');
            const actionBtn = event.target.closest('.message-action-button');
            const nameBtn = event.target.closest('.role-name-button-above-bubble');

            if (actionBtn) {
                event.stopPropagation();
                 if (actionBtn.classList.contains('toggle-raw-button')) {
                     uiChatModule.toggleRawJsonDisplay(msgContainer);
                 } else if (actionBtn.classList.contains('redraw-button')) {
                     uiChatModule.handleRedrawClick(msgContainer);
                 } else if (actionBtn.classList.contains('save-character-update-button')) {
                     uiChatModule.saveCharacterUpdate(msgContainer);
                 }
            } else if (!nameBtn && !actionBtn && !msgContainer?.contains(event.target) && stateModule.activeMessageActions) {
                 uiChatModule.hideAllMessageActions();
            } else if (msgContainer && !nameBtn && !actionBtn && event.target.closest('.ai-response') && event.target.closest('.ai-response').querySelector('.game-host-controls')?.contains(event.target)) {

            }
             else if (msgContainer && !nameBtn && !actionBtn && !event.target.closest('[contenteditable="true"]') && stateModule.activeMessageActions) {
                uiChatModule.hideAllMessageActions();
            } else if (!msgContainer && stateModule.activeMessageActions) {
                uiChatModule.hideAllMessageActions();
            }

        });


        if (elementsModule.imageViewerPage) {
            elementsModule.imageViewerPage.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiChatModule.hideImageViewer(); });
        }


        elementsModule.novelButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.novelUI_toggleNovelInterface(); });
        elementsModule.novelBookshelfButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.novelUI_showNovelSection('novel-bookshelf-page'); });
        elementsModule.novelTocButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.novelUI_showNovelSection('novel-toc-page'); });
        if(elementsModule.novelBookshelfCloseButton) {
            elementsModule.novelBookshelfCloseButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.novelUI_closeCurrentNovelSection('novel-bookshelf-page'); });
        }
        if(elementsModule.novelTocCloseButton) {
            elementsModule.novelTocCloseButton.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.novelUI_closeCurrentNovelSection('novel-toc-page'); });
        }

        if (elementsModule.novelBookshelfListContainer) {
            elementsModule.novelBookshelfListContainer.addEventListener('change', (event) => {
                if (stateModule.isCooldownActive) return;
                const target = event.target;
                const item = target.closest('.novel-bookshelf-item');
                if (!item) return;
                const novelId = item.dataset.novelId;

                if (target.type === 'radio' && target.name === 'currentNovelSelection') {
                    uiSettingsModule.novelUI_handleNovelSelection(novelId);
                } else if (target.type === 'checkbox' && target.classList.contains('novel-activation-checkbox')) {
                    const isChecked = target.checked;
                    uiSettingsModule.novelUI_handleNovelActivation(novelId, isChecked);
                }
            });

             elementsModule.novelBookshelfListContainer.addEventListener('click', (event) => {
                 if (stateModule.isCooldownActive) return;
                 const label = event.target.closest('label');
                 const item = event.target.closest('.novel-bookshelf-item');
                 if (label && item) {
                     const radio = item.querySelector('input[type="radio"]');
                     if (radio && !radio.checked) {
                         radio.checked = true;
                         radio.dispatchEvent(new Event('change', { bubbles: true }));
                     }
                 }
             });
        }

         if (elementsModule.novelContentDisplay) {
             elementsModule.novelContentDisplay.addEventListener('scroll', uiSettingsModule.novelUI_saveScrollPosition, { passive: true });
         } else {
              _logAndDisplayError("Error setting up novel scroll listener: elementsModule.novelContentDisplay is null/undefined.", "setupEventListeners");
         }

        if(elementsModule.novelTocListContainer) {
             elementsModule.novelTocListContainer.addEventListener('click', (event) => {
                 if (stateModule.isCooldownActive) return;
                 const tocItem = event.target.closest('.novel-toc-item');
                 if (tocItem && tocItem.dataset.targetSegmentId !== undefined) {
                     uiSettingsModule.novelUI_handleTocJump(event);
                 }
             });
        }


        elementsModule.chatroomOverrideConfigMenuItems.forEach(item => item.addEventListener('click', () => { if (!stateModule.isCooldownActive) uiSettingsModule.showSection(item.dataset.target); }));

        const overrideSections = ['general', 'drawingMaster', 'gameHost', 'writingMaster', 'characterUpdateMaster', 'privateAssistant'];
        overrideSections.forEach(sectionType => {
            const capSection = sectionType.charAt(0).toUpperCase() + sectionType.slice(1);
            const enabledCheckbox = elementsModule[`chatroomOverride${capSection}Enabled`];
            const modelSelect = elementsModule[`chatroomOverride${capSection}ModelSelect`];
            const schemaJson = elementsModule[`chatroomOverride${capSection}ResponseSchemaJson`];
            const schemaParser = elementsModule[`chatroomOverride${capSection}ResponseSchemaParserJs`];
            const mainPrompt = elementsModule[`chatroomOverride${capSection}MainPrompt`];
            let dbInstructionKey = '';
            let dbElement = null;
            let novelContentElement = null;

            if (sectionType === 'general') {
                 dbInstructionKey = 'sharedDatabaseInstruction';
                 dbElement = elementsModule.chatroomOverrideGeneralSharedDatabaseInstruction;
            } else {
                 dbInstructionKey = 'toolDatabaseInstruction';
                 dbElement = elementsModule[`chatroomOverride${capSection}ToolDatabaseInstruction`];
            }
            if (sectionType === 'drawingMaster') {
                 novelContentElement = elementsModule.chatroomOverrideDrawingMasterNovelContent;
            }

            if (enabledCheckbox) enabledCheckbox.addEventListener('change', () => uiSettingsModule.saveChatroomOverrideEnabled(sectionType));

            if (schemaJson) {
                schemaJson.addEventListener('input', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'responseSchemaJson'));
                schemaJson.addEventListener('change', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'responseSchemaJson'));
            }
            if (schemaParser) {
                schemaParser.addEventListener('input', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'responseSchemaParserJs'));
                schemaParser.addEventListener('change', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'responseSchemaParserJs'));
            }
            if (dbElement) {
                dbElement.addEventListener('input', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, dbInstructionKey));
                dbElement.addEventListener('change', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, dbInstructionKey));
            }
            if (mainPrompt) {
                mainPrompt.addEventListener('input', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'mainPrompt'));
                mainPrompt.addEventListener('change', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'mainPrompt'));
            }
             if (novelContentElement) {
                 novelContentElement.addEventListener('input', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'novelContent'));
                 novelContentElement.addEventListener('change', () => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'novelContent'));
             }
        });


        document.addEventListener('click', (event) => {
             if (stateModule.isCooldownActive) {
                 event.preventDefault();
                 event.stopPropagation();
                 return;
             }
             const isInsideSettings = elementsModule.settingsPanel.contains(event.target);
             const isInsideNovel = elementsModule.novelInterface.contains(event.target);
             const isImageViewer = elementsModule.imageViewerPage?.contains(event.target);
             const isSettingsIcon = elementsModule.settingsIcon.contains(event.target);
             const isNovelButton = elementsModule.novelButton.contains(event.target);
             const isMessageAction = event.target.closest('.message-action-button');
             const isItemAction = event.target.closest('.item-actions > .std-button');
             const isRoleStatePopup = event.target.closest('.role-state-buttons');
             const isNovelSubPageCloseButton = event.target.closest('.novel-close-button');
             const isTopRoleButton = event.target.closest('#role-buttons-list-container .std-button');
             const isStateButton = event.target.closest('.role-state-buttons .std-button');
             const isRuleButton = elementsModule.ruleButton?.contains(event.target);
             const isNameButton = event.target.closest('.role-name-button-above-bubble');
             const isPresetAction = event.target.closest('.prompt-preset-actions > .settings-menu-item') || event.target.closest('.prompt-preset-item .item-actions > .std-button');
             const isChatroomMgmtButton = event.target.closest('#current-chatroom-settings-page .settings-menu-item') || event.target.closest('#chat-room-directory-page .settings-menu-item');
             const isRunPauseButton = elementsModule.runPauseButton.contains(event.target);


              if (stateModule.isNovelInterfaceVisible && !isInsideNovel && !isNovelButton && !isSettingsIcon && !isMessageAction && !isItemAction && !isRoleStatePopup && !isNovelSubPageCloseButton && !isImageViewer && !isRuleButton && !isPresetAction && !isChatroomMgmtButton && !isRunPauseButton) {
                 uiSettingsModule.novelUI_toggleNovelInterface();
             }

            if (stateModule.config.isRoleListVisible &&
                !elementsModule.roleButtonsListContainer.contains(event.target) &&
                !elementsModule.roleButton.contains(event.target) &&
                !isTopRoleButton &&
                !isRoleStatePopup &&
                !isStateButton)
            {
                uiChatModule.toggleRoleList();
            } else if (stateModule.activeRoleStateButtons) {
                const activeStatesDiv = document.querySelector(`.role-state-buttons.active[data-role-name="${stateModule.activeRoleStateButtons}"]`);

                let correspondingRoleBtn = null;
                 const allRoleBtns = elementsModule.roleButtonsListContainer.querySelectorAll('.role-button-container > .std-button:not(.role-state-button)');
                 allRoleBtns.forEach(b => {
                     if (b.dataset.roleName === stateModule.activeRoleStateButtons) correspondingRoleBtn = b;
                 });

                if (activeStatesDiv && !activeStatesDiv.contains(event.target) && event.target !== correspondingRoleBtn && !isStateButton) {
                    uiChatModule.hideRoleStateButtons();
                }
            }

            if (stateModule.editingMessageContainer &&
                !stateModule.editingMessageContainer.contains(event.target) &&
                !elementsModule.addAdminButton.contains(event.target))
            {
                 uiChatModule.saveEditedMessage(stateModule.editingMessageContainer);
            }

             if (stateModule.activeMessageActions && !stateModule.activeMessageActions.contains(event.target) && !isMessageAction && !isNameButton ) {
                uiChatModule.hideAllMessageActions();
             }

        }, true);

        document.querySelectorAll('.settings-select[id*="-model-"]').forEach(selectElement => {
             if (selectElement.id !== 'novelai-model-settings') {
                 selectElement.removeEventListener('change', uiSettingsModule.saveChatroomModelSetting);
                 selectElement.addEventListener('change', uiSettingsModule.saveChatroomModelSetting);

                 if(selectElement.id.startsWith('chatroom-override-')) {
                     const match = selectElement.id.match(/^chatroom-override-(general|drawingMaster|gameHost|writingMaster|characterUpdateMaster|privateAssistant)-model-select$/);
                     if(match) {
                         const sectionType = match[1];
                         selectElement.removeEventListener('change', (e) => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'model'));
                         selectElement.addEventListener('change', (e) => uiSettingsModule.saveChatroomOverrideSetting(sectionType, 'model'));
                     }
                 } else if (!selectElement.id.startsWith('chatroom-')) {
                     const toolMatch = selectElement.id.match(/^(.*)-model-settings$/);
                     if (toolMatch) {
                         const toolName = toolMatch[1].replace(/-(\w)/g, (match, p1) => p1.toUpperCase());
                         selectElement.removeEventListener('change', () => uiSettingsModule.saveToolModelSetting(toolName));
                         selectElement.addEventListener('change', () => uiSettingsModule.saveToolModelSetting(toolName));
                     }
                 }
             }
        });

        elementsModule.roleButtonsListContainer.addEventListener('pointerdown', (event) => {
            const stateButton = event.target.closest('.role-state-button');
            if (stateButton && !stateButton._interactionListenersAttached) {
                const roleName = stateButton.dataset.roleName;
                const state = stateButton.dataset.state;
                const isDisabled = stateButton.classList.contains('edit-disabled');
                const stateShortPress = isDisabled ? null : () => uiChatModule.selectRoleState(roleName, state);
                let stateLongPress = null;
                if (!isDisabled && state === uiChatModule.ROLE_STATE_USER_CONTROL) {
                    stateLongPress = () => {
                        uiChatModule.createAndEditMessageForRole(roleName);
                        uiChatModule.hideRoleStateButtons();
                    };
                } else if (!isDisabled && state === uiChatModule.ROLE_STATE_DEFAULT) {
                    const chatroomDetails = stateModule.currentChatroomDetails;
                    const isPermanent = chatroomDetails?.roles.some(r => r.name === roleName);
                    if (!isPermanent) {
                         stateLongPress = () => uiChatModule.deleteTemporaryRole(roleName, true);
                    } else {
                         stateLongPress = () => uiChatModule.handleRoleDefaultStateLongPress(roleName);
                    }
                } else if (!isDisabled && state === uiChatModule.ROLE_STATE_ACTIVE) {
                     stateLongPress = () => uiChatModule.handleActivateButtonLongPress(roleName);
                }
                eventListenersModule._setupLongPressListener(stateButton, stateShortPress, stateLongPress, false);
                stateButton._interactionListenersAttached = true;
            }
        }, true);


    }
};

const initializationModule_ui = {
    initializeUI: async () => {
        elementsModule.init();
        eventListenersModule.setupEventListeners();

        try {
            await initializationModule.initializeConfig();
        } catch (error) {
            _logAndDisplayError(`Initialization failed: ${error.message}`, 'initializeUI', 'N/A', 'N/A', error);

            Object.assign(stateModule.config, JSON.parse(JSON.stringify(defaultConfig)));
            await initializationModule.initializeConfig();
        }
    }
};

document.addEventListener('DOMContentLoaded', () => { initializationModule_ui.initializeUI(); });
```
--- END OF FILE main.js ---

